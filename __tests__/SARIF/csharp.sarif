{
  "$schema": "https://json.schemastore.org/sarif-2.1.0.json",
  "version": "2.1.0",
  "runs": [
    {
      "tool": {
        "driver": {
          "name": "CodeQL",
          "organization": "GitHub",
          "semanticVersion": "2.20.0",
          "notifications": [
            {
              "id": "cli/expected-extracted-files/csharp",
              "name": "cli/expected-extracted-files/csharp",
              "shortDescription": {
                "text": "Expected extracted files"
              },
              "fullDescription": {
                "text": "Files appearing in the source archive that are expected to be extracted."
              },
              "defaultConfiguration": {
                "enabled": true
              },
              "properties": {
                "tags": [
                  "expected-extracted-files",
                  "telemetry"
                ],
                "languageDisplayName": "C#"
              }
            },
            {
              "id": "cli/csharp/path-filtering-not-supported",
              "name": "cli/csharp/path-filtering-not-supported",
              "shortDescription": {
                "text": "Path filters have no effect for C#"
              },
              "fullDescription": {
                "text": "Path filters have no effect for C#"
              },
              "defaultConfiguration": {
                "enabled": true
              }
            },
            {
              "id": "codeql-action/bundle-download-telemetry",
              "name": "codeql-action/bundle-download-telemetry",
              "shortDescription": {
                "text": "CodeQL bundle download telemetry"
              },
              "fullDescription": {
                "text": "CodeQL bundle download telemetry"
              },
              "defaultConfiguration": {
                "enabled": true
              }
            }
          ],
          "rules": []
        },
        "extensions": [
          {
            "name": "githubsecuritylab/codeql-csharp-extensions",
            "semanticVersion": "0.0.1+a9562bd5a3fadaa40ffff1b140106614049d49de",
            "locations": [
              {
                "uri": "file:///home/runner/.codeql/packages/githubsecuritylab/codeql-csharp-extensions/0.0.1/",
                "description": {
                  "text": "The QL pack root directory."
                },
                "properties": {
                  "tags": [
                    "CodeQL/LocalPackRoot"
                  ]
                }
              },
              {
                "uri": "file:///home/runner/.codeql/packages/githubsecuritylab/codeql-csharp-extensions/0.0.1/qlpack.yml",
                "description": {
                  "text": "The QL pack definition file."
                },
                "properties": {
                  "tags": [
                    "CodeQL/LocalPackDefinitionFile"
                  ]
                }
              }
            ],
            "properties": {
              "isCodeQLModelPack": true
            }
          },
          {
            "name": "githubsecuritylab/codeql-csharp-library-sources",
            "semanticVersion": "0.0.1+a9562bd5a3fadaa40ffff1b140106614049d49de",
            "locations": [
              {
                "uri": "file:///home/runner/.codeql/packages/githubsecuritylab/codeql-csharp-library-sources/0.0.1/",
                "description": {
                  "text": "The QL pack root directory."
                },
                "properties": {
                  "tags": [
                    "CodeQL/LocalPackRoot"
                  ]
                }
              },
              {
                "uri": "file:///home/runner/.codeql/packages/githubsecuritylab/codeql-csharp-library-sources/0.0.1/qlpack.yml",
                "description": {
                  "text": "The QL pack definition file."
                },
                "properties": {
                  "tags": [
                    "CodeQL/LocalPackDefinitionFile"
                  ]
                }
              }
            ],
            "properties": {
              "isCodeQLModelPack": true
            }
          },
          {
            "name": "githubsecuritylab/codeql-java-extensions",
            "semanticVersion": "0.0.1+a9562bd5a3fadaa40ffff1b140106614049d49de",
            "locations": [
              {
                "uri": "file:///home/runner/.codeql/packages/githubsecuritylab/codeql-java-extensions/0.0.1/",
                "description": {
                  "text": "The QL pack root directory."
                },
                "properties": {
                  "tags": [
                    "CodeQL/LocalPackRoot"
                  ]
                }
              },
              {
                "uri": "file:///home/runner/.codeql/packages/githubsecuritylab/codeql-java-extensions/0.0.1/qlpack.yml",
                "description": {
                  "text": "The QL pack definition file."
                },
                "properties": {
                  "tags": [
                    "CodeQL/LocalPackDefinitionFile"
                  ]
                }
              }
            ],
            "properties": {
              "isCodeQLModelPack": true
            }
          },
          {
            "name": "githubsecuritylab/codeql-java-library-sources",
            "semanticVersion": "0.0.1+a9562bd5a3fadaa40ffff1b140106614049d49de",
            "locations": [
              {
                "uri": "file:///home/runner/.codeql/packages/githubsecuritylab/codeql-java-library-sources/0.0.1/",
                "description": {
                  "text": "The QL pack root directory."
                },
                "properties": {
                  "tags": [
                    "CodeQL/LocalPackRoot"
                  ]
                }
              },
              {
                "uri": "file:///home/runner/.codeql/packages/githubsecuritylab/codeql-java-library-sources/0.0.1/qlpack.yml",
                "description": {
                  "text": "The QL pack definition file."
                },
                "properties": {
                  "tags": [
                    "CodeQL/LocalPackDefinitionFile"
                  ]
                }
              }
            ],
            "properties": {
              "isCodeQLModelPack": true
            }
          },
          {
            "name": "codeql/csharp-queries",
            "semanticVersion": "1.0.13+3b2e55bc2ac942ac2cf2646f5c69acd081ce8ea2",
            "notifications": [
              {
                "id": "csharp/diagnostic/database-quality",
                "name": "csharp/diagnostic/database-quality",
                "shortDescription": {
                  "text": "Low C# analysis quality"
                },
                "fullDescription": {
                  "text": "Low C# analysis quality"
                },
                "defaultConfiguration": {
                  "enabled": true
                },
                "properties": {
                  "description": "Low C# analysis quality",
                  "id": "csharp/diagnostic/database-quality",
                  "kind": "diagnostic",
                  "name": "Low C# analysis quality"
                }
              },
              {
                "id": "cs/compilation-error",
                "name": "cs/compilation-error",
                "shortDescription": {
                  "text": "Compilation error"
                },
                "fullDescription": {
                  "text": "A compilation error can cause extraction problems, and could lead to inaccurate results."
                },
                "defaultConfiguration": {
                  "enabled": true
                },
                "help": {
                  "text": "# Compilation error\nThis is an internal query that finds all compilation errors reported by the C\\# compiler used by the C\\# extractor.\n\n",
                  "markdown": "# Compilation error\nThis is an internal query that finds all compilation errors reported by the C\\# compiler used by the C\\# extractor.\n\n"
                },
                "properties": {
                  "tags": [
                    "internal",
                    "non-attributable"
                  ],
                  "description": "A compilation error can cause extraction problems, and could lead to inaccurate results.",
                  "id": "cs/compilation-error",
                  "kind": "diagnostic",
                  "name": "Compilation error"
                }
              },
              {
                "id": "cs/extraction-error",
                "name": "cs/extraction-error",
                "shortDescription": {
                  "text": "Extraction error"
                },
                "fullDescription": {
                  "text": "An error message reported by the extractor, limited to those files where there are no compilation errors. This indicates a bug or limitation in the extractor, and could lead to inaccurate results."
                },
                "defaultConfiguration": {
                  "enabled": true
                },
                "help": {
                  "text": "# Extraction error\nThis is an internal query that finds all errors reported by the C\\# extractor. It excludes results from files containing compilation errors, because these errors are likely to be caused by the compilation error rather than due to an internal error in the extractor.\n\nExtractor errors can lead to inaccurate results.\n\n\n## Recommendation\nReport extractor errors to Semmle.\n\n",
                  "markdown": "# Extraction error\nThis is an internal query that finds all errors reported by the C\\# extractor. It excludes results from files containing compilation errors, because these errors are likely to be caused by the compilation error rather than due to an internal error in the extractor.\n\nExtractor errors can lead to inaccurate results.\n\n\n## Recommendation\nReport extractor errors to Semmle.\n\n"
                },
                "properties": {
                  "tags": [
                    "internal",
                    "non-attributable"
                  ],
                  "description": "An error message reported by the extractor, limited to those files where there are no\n              compilation errors. This indicates a bug or limitation in the extractor, and could lead\n              to inaccurate results.",
                  "id": "cs/extraction-error",
                  "kind": "diagnostic",
                  "name": "Extraction error"
                }
              },
              {
                "id": "cs/compilation-message",
                "name": "cs/compilation-message",
                "shortDescription": {
                  "text": "Compilation message"
                },
                "fullDescription": {
                  "text": "A message emitted by the compiler, including warnings and errors."
                },
                "defaultConfiguration": {
                  "enabled": true
                },
                "help": {
                  "text": "# Compilation message\nThis is an internal query that finds all messages reported by the C\\# compiler used by the C\\# extractor. This may include both compiler errors and compiler warnings.\n\n",
                  "markdown": "# Compilation message\nThis is an internal query that finds all messages reported by the C\\# compiler used by the C\\# extractor. This may include both compiler errors and compiler warnings.\n\n"
                },
                "properties": {
                  "tags": [
                    "internal",
                    "non-attributable"
                  ],
                  "description": "A message emitted by the compiler, including warnings and errors.",
                  "id": "cs/compilation-message",
                  "kind": "diagnostic",
                  "name": "Compilation message"
                }
              },
              {
                "id": "cs/diagnostics/extraction-errors",
                "name": "cs/diagnostics/extraction-errors",
                "shortDescription": {
                  "text": "Extraction errors"
                },
                "fullDescription": {
                  "text": "List all errors reported by the extractor or the compiler. Extractor errors are limited to those files where there are no compilation errors."
                },
                "defaultConfiguration": {
                  "enabled": true
                },
                "properties": {
                  "description": "List all errors reported by the extractor or the compiler. Extractor errors are\n              limited to those files where there are no compilation errors.",
                  "id": "cs/diagnostics/extraction-errors",
                  "kind": "diagnostic",
                  "name": "Extraction errors"
                }
              },
              {
                "id": "cs/extraction-message",
                "name": "cs/extraction-message",
                "shortDescription": {
                  "text": "Extraction message"
                },
                "fullDescription": {
                  "text": "An error message reported by the extractor. This could lead to inaccurate results."
                },
                "defaultConfiguration": {
                  "enabled": true
                },
                "help": {
                  "text": "# Extraction message\nThis is an internal query that finds all messages reported by the extractor. These results may include extraction errors that are caused by compilation errors.\n\nExtractor errors can lead to inaccurate results.\n\n",
                  "markdown": "# Extraction message\nThis is an internal query that finds all messages reported by the extractor. These results may include extraction errors that are caused by compilation errors.\n\nExtractor errors can lead to inaccurate results.\n\n"
                },
                "properties": {
                  "tags": [
                    "internal",
                    "non-attributable"
                  ],
                  "description": "An error message reported by the extractor. This could lead to inaccurate results.",
                  "id": "cs/extraction-message",
                  "kind": "diagnostic",
                  "name": "Extraction message"
                }
              },
              {
                "id": "cs/diagnostics/successfully-extracted-files",
                "name": "cs/diagnostics/successfully-extracted-files",
                "shortDescription": {
                  "text": "Extracted files"
                },
                "fullDescription": {
                  "text": "A list of all files in the source code directory that were extracted without encountering an extraction or compiler error in the file."
                },
                "defaultConfiguration": {
                  "enabled": true
                },
                "properties": {
                  "tags": [
                    "successfully-extracted-files"
                  ],
                  "description": "A list of all files in the source code directory that were extracted\n              without encountering an extraction or compiler error in the file.",
                  "id": "cs/diagnostics/successfully-extracted-files",
                  "kind": "diagnostic",
                  "name": "Extracted files"
                }
              }
            ],
            "rules": [
              {
                "id": "cs/web/debug-code",
                "name": "cs/web/debug-code",
                "shortDescription": {
                  "text": "ASP.NET: leftover debug code"
                },
                "fullDescription": {
                  "text": "Finds leftover entry points in web applications"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning"
                },
                "help": {
                  "text": "# ASP.NET: leftover debug code\nLeftover entry points in web applications can be exploited by an attacker to enter a deployed web application through a way that was not intended and probably not even considered. Static ` Main(..)` methods are typical leftover entry points that can prove harmful to your web application.\n\n\n## Recommendation\nRemove debug code if your web application is in production.\n\n\n## References\n* Common Weakness Enumeration: [CWE-489](https://cwe.mitre.org/data/definitions/489.html).\n",
                  "markdown": "# ASP.NET: leftover debug code\nLeftover entry points in web applications can be exploited by an attacker to enter a deployed web application through a way that was not intended and probably not even considered. Static ` Main(..)` methods are typical leftover entry points that can prove harmful to your web application.\n\n\n## Recommendation\nRemove debug code if your web application is in production.\n\n\n## References\n* Common Weakness Enumeration: [CWE-489](https://cwe.mitre.org/data/definitions/489.html).\n"
                },
                "properties": {
                  "tags": [
                    "security",
                    "maintainability",
                    "frameworks/asp.net",
                    "external/cwe/cwe-489"
                  ],
                  "description": "Finds leftover entry points in web applications",
                  "id": "cs/web/debug-code",
                  "kind": "problem",
                  "name": "ASP.NET: leftover debug code",
                  "precision": "low",
                  "problem.severity": "warning"
                }
              },
              {
                "id": "cs/web/html-hidden-input",
                "name": "cs/web/html-hidden-input",
                "shortDescription": {
                  "text": "Use of HTMLInputHidden"
                },
                "fullDescription": {
                  "text": "Finds uses of hidden fields on forms"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note"
                },
                "help": {
                  "text": "# Use of HTMLInputHidden\nData entered in hidden fields is cached in the same way as the rest of the page, and can be accessed or replaced by attackers that have access to the browser's cache. You should not trust the contents of hidden fields more than the contents of normal input fields.\n\n\n## Recommendation\nEnsure no sensitive information is stored in hidden fields.\n\n\n## References\n* Common Weakness Enumeration: [CWE-472](https://cwe.mitre.org/data/definitions/472.html).\n",
                  "markdown": "# Use of HTMLInputHidden\nData entered in hidden fields is cached in the same way as the rest of the page, and can be accessed or replaced by attackers that have access to the browser's cache. You should not trust the contents of hidden fields more than the contents of normal input fields.\n\n\n## Recommendation\nEnsure no sensitive information is stored in hidden fields.\n\n\n## References\n* Common Weakness Enumeration: [CWE-472](https://cwe.mitre.org/data/definitions/472.html).\n"
                },
                "properties": {
                  "tags": [
                    "security",
                    "maintainability",
                    "frameworks/asp.net",
                    "external/cwe/cwe-472"
                  ],
                  "description": "Finds uses of hidden fields on forms",
                  "id": "cs/web/html-hidden-input",
                  "kind": "problem",
                  "name": "Use of HTMLInputHidden",
                  "precision": "medium",
                  "problem.severity": "recommendation",
                  "security-severity": "7.5"
                }
              },
              {
                "id": "cs/thread-unsafe-icryptotransform-field-in-class",
                "name": "cs/thread-unsafe-icryptotransform-field-in-class",
                "shortDescription": {
                  "text": "Thread-unsafe use of a static ICryptoTransform field"
                },
                "fullDescription": {
                  "text": "The class has a field that directly or indirectly make use of a static System.Security.Cryptography.ICryptoTransform object. Using this an instance of this class in concurrent threads is dangerous as it may not only result in an error, but under some circumstances may also result in incorrect results."
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning"
                },
                "help": {
                  "text": "# Thread-unsafe use of a static ICryptoTransform field\nClasses that implement `System.Security.Cryptography.ICryptoTransform` are not thread safe.\n\nThis problem is caused by the way these classes are implemented using Microsoft CAPI/CNG patterns.\n\nFor example, when a hash class implements this interface, there would typically be an instance-specific hash object created (for example using `BCryptCreateHash` function). This object can be called multiple times to add data to the hash (for example `BCryptHashData`). Finally, a function is called that finishes the hash and returns the data (for example `BCryptFinishHash`).\n\nAllowing the same hash object to be called with data from multiple threads before calling the finish function could potentially lead to incorrect results.\n\nFor example, if you have multiple threads hashing `\"abc\"` on a static hash object, you may occasionally obtain the results (incorrectly) for hashing `\"abcabc\"`, or face other unexpected behavior.\n\nIt is very unlikely somebody outside Microsoft would write a class that implements `ICryptoTransform`, and even if they do, it is likely that they will follow the same common pattern as the existing classes implementing this interface.\n\nAny object that implements `System.Security.Cryptography.ICryptoTransform` should not be used in concurrent threads as the instance members of such object are also not thread safe.\n\nPotential problems may not be evident at first, but can range from explicit errors such as exceptions, to incorrect results when sharing an instance of such an object in multiple threads.\n\n\n## Recommendation\nIf the object is shared across instances, you should consider changing the code to use a non-static object of type `System.Security.Cryptography.ICryptoTransform` instead.\n\nAs an alternative, you could also look into using `ThreadStatic` attribute, but make sure you read the initialization remarks on the documentation.\n\n\n## Example\nThis example demonstrates the dangers of using a static `System.Security.Cryptography.ICryptoTransform` in a way that generates incorrect results.\n\n\n```csharp\ninternal class TokenCacheThreadUnsafeICryptoTransformDemo\n{\n    private static SHA256 _sha = SHA256.Create();\n\n    public string ComputeHash(string data)\n    {\n        byte[] passwordBytes = UTF8Encoding.UTF8.GetBytes(data);\n        return Convert.ToBase64String(_sha.ComputeHash(passwordBytes));\n    }\n}\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        int max = 1000;\n        Task[] tasks = new Task[max];\n\n        Action<object> action = (object obj) =>\n        {\n            var unsafeObj = new TokenCacheThreadUnsafeICryptoTransformDemo();\n            if (unsafeObj.ComputeHash((string)obj) != \"ungWv48Bz+pBQUDeXa4iI7ADYaOWF3qctBD/YfIAFa0=\")\n            {\n                Console.WriteLine(\"**** We got incorrect Results!!! ****\");\n            }\n        };\n\n        for (int i = 0; i < max; i++)\n        {\n            // hash calculated on all threads should be the same:\n            // ungWv48Bz+pBQUDeXa4iI7ADYaOWF3qctBD/YfIAFa0= (base64)\n            // \n            tasks[i] = Task.Factory.StartNew(action, \"abc\");\n        }\n\n        Task.WaitAll(tasks);\n    }\n}\n\n```\nA simple fix is to change the `_sha` field from being a static member to an instance one by removing the `static` keyword.\n\n\n```csharp\ninternal class TokenCacheThreadUnsafeICryptoTransformDemoFixed\n{\n    // We are replacing the static SHA256 field with an instance one\n    //\n    //private static SHA256 _sha = SHA256.Create();\n    private SHA256 _sha = SHA256.Create();\n\n    public string ComputeHash(string data)\n    {\n        byte[] passwordBytes = UTF8Encoding.UTF8.GetBytes(data);\n        return Convert.ToBase64String(_sha.ComputeHash(passwordBytes));\n    }\n}\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        int max = 1000;\n        Task[] tasks = new Task[max];\n\n        Action<object> action = (object obj) =>\n        {\n            var safeObj = new TokenCacheThreadUnsafeICryptoTransformDemoFixed();\n            if (safeObj.ComputeHash((string)obj) != \"ungWv48Bz+pBQUDeXa4iI7ADYaOWF3qctBD/YfIAFa0=\")\n            {\n                Console.WriteLine(\"**** We got incorrect Results!!! ****\");\n            }\n        };\n\n        for (int i = 0; i < max; i++)\n        {\n            // hash calculated on all threads should be the same:\n            // ungWv48Bz+pBQUDeXa4iI7ADYaOWF3qctBD/YfIAFa0= (base64)\n            // \n            tasks[i] = Task.Factory.StartNew(action, \"abc\");\n        }\n\n        Task.WaitAll(tasks);\n    }\n}\n\n```\n\n## References\n* Microsoft documentation, [ThreadStaticAttribute Class](https://docs.microsoft.com/en-us/dotnet/api/system.threadstaticattribute?view=netframework-4.7.2).\n* Stack Overflow, [Why does SHA1.ComputeHash fail under high load with many threads?](https://stackoverflow.com/questions/26592596/why-does-sha1-computehash-fail-under-high-load-with-many-threads).\n* Common Weakness Enumeration: [CWE-362](https://cwe.mitre.org/data/definitions/362.html).\n",
                  "markdown": "# Thread-unsafe use of a static ICryptoTransform field\nClasses that implement `System.Security.Cryptography.ICryptoTransform` are not thread safe.\n\nThis problem is caused by the way these classes are implemented using Microsoft CAPI/CNG patterns.\n\nFor example, when a hash class implements this interface, there would typically be an instance-specific hash object created (for example using `BCryptCreateHash` function). This object can be called multiple times to add data to the hash (for example `BCryptHashData`). Finally, a function is called that finishes the hash and returns the data (for example `BCryptFinishHash`).\n\nAllowing the same hash object to be called with data from multiple threads before calling the finish function could potentially lead to incorrect results.\n\nFor example, if you have multiple threads hashing `\"abc\"` on a static hash object, you may occasionally obtain the results (incorrectly) for hashing `\"abcabc\"`, or face other unexpected behavior.\n\nIt is very unlikely somebody outside Microsoft would write a class that implements `ICryptoTransform`, and even if they do, it is likely that they will follow the same common pattern as the existing classes implementing this interface.\n\nAny object that implements `System.Security.Cryptography.ICryptoTransform` should not be used in concurrent threads as the instance members of such object are also not thread safe.\n\nPotential problems may not be evident at first, but can range from explicit errors such as exceptions, to incorrect results when sharing an instance of such an object in multiple threads.\n\n\n## Recommendation\nIf the object is shared across instances, you should consider changing the code to use a non-static object of type `System.Security.Cryptography.ICryptoTransform` instead.\n\nAs an alternative, you could also look into using `ThreadStatic` attribute, but make sure you read the initialization remarks on the documentation.\n\n\n## Example\nThis example demonstrates the dangers of using a static `System.Security.Cryptography.ICryptoTransform` in a way that generates incorrect results.\n\n\n```csharp\ninternal class TokenCacheThreadUnsafeICryptoTransformDemo\n{\n    private static SHA256 _sha = SHA256.Create();\n\n    public string ComputeHash(string data)\n    {\n        byte[] passwordBytes = UTF8Encoding.UTF8.GetBytes(data);\n        return Convert.ToBase64String(_sha.ComputeHash(passwordBytes));\n    }\n}\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        int max = 1000;\n        Task[] tasks = new Task[max];\n\n        Action<object> action = (object obj) =>\n        {\n            var unsafeObj = new TokenCacheThreadUnsafeICryptoTransformDemo();\n            if (unsafeObj.ComputeHash((string)obj) != \"ungWv48Bz+pBQUDeXa4iI7ADYaOWF3qctBD/YfIAFa0=\")\n            {\n                Console.WriteLine(\"**** We got incorrect Results!!! ****\");\n            }\n        };\n\n        for (int i = 0; i < max; i++)\n        {\n            // hash calculated on all threads should be the same:\n            // ungWv48Bz+pBQUDeXa4iI7ADYaOWF3qctBD/YfIAFa0= (base64)\n            // \n            tasks[i] = Task.Factory.StartNew(action, \"abc\");\n        }\n\n        Task.WaitAll(tasks);\n    }\n}\n\n```\nA simple fix is to change the `_sha` field from being a static member to an instance one by removing the `static` keyword.\n\n\n```csharp\ninternal class TokenCacheThreadUnsafeICryptoTransformDemoFixed\n{\n    // We are replacing the static SHA256 field with an instance one\n    //\n    //private static SHA256 _sha = SHA256.Create();\n    private SHA256 _sha = SHA256.Create();\n\n    public string ComputeHash(string data)\n    {\n        byte[] passwordBytes = UTF8Encoding.UTF8.GetBytes(data);\n        return Convert.ToBase64String(_sha.ComputeHash(passwordBytes));\n    }\n}\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        int max = 1000;\n        Task[] tasks = new Task[max];\n\n        Action<object> action = (object obj) =>\n        {\n            var safeObj = new TokenCacheThreadUnsafeICryptoTransformDemoFixed();\n            if (safeObj.ComputeHash((string)obj) != \"ungWv48Bz+pBQUDeXa4iI7ADYaOWF3qctBD/YfIAFa0=\")\n            {\n                Console.WriteLine(\"**** We got incorrect Results!!! ****\");\n            }\n        };\n\n        for (int i = 0; i < max; i++)\n        {\n            // hash calculated on all threads should be the same:\n            // ungWv48Bz+pBQUDeXa4iI7ADYaOWF3qctBD/YfIAFa0= (base64)\n            // \n            tasks[i] = Task.Factory.StartNew(action, \"abc\");\n        }\n\n        Task.WaitAll(tasks);\n    }\n}\n\n```\n\n## References\n* Microsoft documentation, [ThreadStaticAttribute Class](https://docs.microsoft.com/en-us/dotnet/api/system.threadstaticattribute?view=netframework-4.7.2).\n* Stack Overflow, [Why does SHA1.ComputeHash fail under high load with many threads?](https://stackoverflow.com/questions/26592596/why-does-sha1-computehash-fail-under-high-load-with-many-threads).\n* Common Weakness Enumeration: [CWE-362](https://cwe.mitre.org/data/definitions/362.html).\n"
                },
                "properties": {
                  "tags": [
                    "concurrency",
                    "security",
                    "external/cwe/cwe-362"
                  ],
                  "description": "The class has a field that directly or indirectly make use of a static System.Security.Cryptography.ICryptoTransform object.\n              Using this an instance of this class in concurrent threads is dangerous as it may not only result in an error,\n              but under some circumstances may also result in incorrect results.",
                  "id": "cs/thread-unsafe-icryptotransform-field-in-class",
                  "kind": "problem",
                  "name": "Thread-unsafe use of a static ICryptoTransform field",
                  "precision": "medium",
                  "problem.severity": "warning",
                  "security-severity": "7.0"
                }
              },
              {
                "id": "cs/thread-unsafe-icryptotransform-captured-in-lambda",
                "name": "cs/thread-unsafe-icryptotransform-captured-in-lambda",
                "shortDescription": {
                  "text": "Thread-unsafe capturing of an ICryptoTransform object"
                },
                "fullDescription": {
                  "text": "An instance of a class that either implements or has a field of type System.Security.Cryptography.ICryptoTransform is being captured by a lambda, and used in what seems to be a thread initialization method. Using an instance of this class in concurrent threads is dangerous as it may not only result in an error, but under some circumstances may also result in incorrect results."
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning"
                },
                "help": {
                  "text": "# Thread-unsafe capturing of an ICryptoTransform object\nClasses that implement `System.Security.Cryptography.ICryptoTransform` are not thread safe.\n\nThis problem is caused by the way these classes are implemented using Microsoft CAPI/CNG patterns.\n\nFor example, when a hash class implements this interface, there would typically be an instance-specific hash object created (for example using `BCryptCreateHash` function). This object can be called multiple times to add data to the hash (for example `BCryptHashData`). Finally, a function is called that finishes the hash and returns the data (for example `BCryptFinishHash`).\n\nAllowing the same hash object to be called with data from multiple threads before calling the finish function could potentially lead to incorrect results.\n\nFor example, if you have multiple threads hashing `\"abc\"` on a static hash object, you may occasionally obtain the results (incorrectly) for hashing `\"abcabc\"`, or face other unexpected behavior.\n\nIt is very unlikely somebody outside Microsoft would write a class that implements `ICryptoTransform`, and even if they do, it is likely that they will follow the same common pattern as the existing classes implementing this interface.\n\nAny object that implements `System.Security.Cryptography.ICryptoTransform` should not be used in concurrent threads as the instance members of such object are also not thread safe.\n\nPotential problems may not be evident at first, but can range from explicit errors such as exceptions, to incorrect results when sharing an instance of such an object in multiple threads.\n\n\n## Recommendation\nCreate new instances of the object that implements or has a field of type `System.Security.Cryptography.ICryptoTransform` to avoid sharing it across multiple threads.\n\n\n## Example\nThis example demonstrates the dangers of using a shared `System.Security.Cryptography.ICryptoTransform` in a way that generates incorrect results or may raise an exception.\n\n\n```csharp\npublic static void RunThreadUnSafeICryptoTransformLambdaBad()\n{\n    const int threadCount = 4;\n    // This local variable for a hash object is going to be shared across multiple threads\n    var sha1 = SHA1.Create();\n    var b = new Barrier(threadCount);\n    Action start = () => {\n        b.SignalAndWait();\n        for (int i = 0; i < 1000; i++)\n        {\n            var pwd = Guid.NewGuid().ToString();\n            var bytes = Encoding.UTF8.GetBytes(pwd);\n            // This call may fail, or return incorrect results\n            sha1.ComputeHash(bytes);\n        }\n    };\n    var threads = Enumerable.Range(0, threadCount)\n                            .Select(_ => new ThreadStart(start))\n                            .Select(x => new Thread(x))\n                            .ToList();\n    foreach (var t in threads) t.Start();\n    foreach (var t in threads) t.Join();\n}\n\n```\nA simple fix is to change the local variable `sha1` being captured by the lambda to be a local variable within the lambda.\n\n\n```csharp\npublic static void RunThreadUnSafeICryptoTransformLambdaFixed()\n{\n    const int threadCount = 4;\n    var b = new Barrier(threadCount);\n    Action start = () => {\n        b.SignalAndWait();\n        // The hash object is no longer shared\n        for (int i = 0; i < 1000; i++)\n        {\n            var sha1 = SHA1.Create();\n            var pwd = Guid.NewGuid().ToString();\n            var bytes = Encoding.UTF8.GetBytes(pwd);\n            sha1.ComputeHash(bytes);\n        }\n    };\n    var threads = Enumerable.Range(0, threadCount)\n                            .Select(_ => new ThreadStart(start))\n                            .Select(x => new Thread(x))\n                            .ToList();\n    foreach (var t in threads) t.Start();\n    foreach (var t in threads) t.Join();\n}\n\n```\n\n## References\n* Microsoft documentation, [ThreadStaticAttribute Class](https://docs.microsoft.com/en-us/dotnet/api/system.threadstaticattribute?view=netframework-4.7.2).\n* Stack Overflow, [Why does SHA1.ComputeHash fail under high load with many threads?](https://stackoverflow.com/questions/26592596/why-does-sha1-computehash-fail-under-high-load-with-many-threads).\n* Common Weakness Enumeration: [CWE-362](https://cwe.mitre.org/data/definitions/362.html).\n",
                  "markdown": "# Thread-unsafe capturing of an ICryptoTransform object\nClasses that implement `System.Security.Cryptography.ICryptoTransform` are not thread safe.\n\nThis problem is caused by the way these classes are implemented using Microsoft CAPI/CNG patterns.\n\nFor example, when a hash class implements this interface, there would typically be an instance-specific hash object created (for example using `BCryptCreateHash` function). This object can be called multiple times to add data to the hash (for example `BCryptHashData`). Finally, a function is called that finishes the hash and returns the data (for example `BCryptFinishHash`).\n\nAllowing the same hash object to be called with data from multiple threads before calling the finish function could potentially lead to incorrect results.\n\nFor example, if you have multiple threads hashing `\"abc\"` on a static hash object, you may occasionally obtain the results (incorrectly) for hashing `\"abcabc\"`, or face other unexpected behavior.\n\nIt is very unlikely somebody outside Microsoft would write a class that implements `ICryptoTransform`, and even if they do, it is likely that they will follow the same common pattern as the existing classes implementing this interface.\n\nAny object that implements `System.Security.Cryptography.ICryptoTransform` should not be used in concurrent threads as the instance members of such object are also not thread safe.\n\nPotential problems may not be evident at first, but can range from explicit errors such as exceptions, to incorrect results when sharing an instance of such an object in multiple threads.\n\n\n## Recommendation\nCreate new instances of the object that implements or has a field of type `System.Security.Cryptography.ICryptoTransform` to avoid sharing it across multiple threads.\n\n\n## Example\nThis example demonstrates the dangers of using a shared `System.Security.Cryptography.ICryptoTransform` in a way that generates incorrect results or may raise an exception.\n\n\n```csharp\npublic static void RunThreadUnSafeICryptoTransformLambdaBad()\n{\n    const int threadCount = 4;\n    // This local variable for a hash object is going to be shared across multiple threads\n    var sha1 = SHA1.Create();\n    var b = new Barrier(threadCount);\n    Action start = () => {\n        b.SignalAndWait();\n        for (int i = 0; i < 1000; i++)\n        {\n            var pwd = Guid.NewGuid().ToString();\n            var bytes = Encoding.UTF8.GetBytes(pwd);\n            // This call may fail, or return incorrect results\n            sha1.ComputeHash(bytes);\n        }\n    };\n    var threads = Enumerable.Range(0, threadCount)\n                            .Select(_ => new ThreadStart(start))\n                            .Select(x => new Thread(x))\n                            .ToList();\n    foreach (var t in threads) t.Start();\n    foreach (var t in threads) t.Join();\n}\n\n```\nA simple fix is to change the local variable `sha1` being captured by the lambda to be a local variable within the lambda.\n\n\n```csharp\npublic static void RunThreadUnSafeICryptoTransformLambdaFixed()\n{\n    const int threadCount = 4;\n    var b = new Barrier(threadCount);\n    Action start = () => {\n        b.SignalAndWait();\n        // The hash object is no longer shared\n        for (int i = 0; i < 1000; i++)\n        {\n            var sha1 = SHA1.Create();\n            var pwd = Guid.NewGuid().ToString();\n            var bytes = Encoding.UTF8.GetBytes(pwd);\n            sha1.ComputeHash(bytes);\n        }\n    };\n    var threads = Enumerable.Range(0, threadCount)\n                            .Select(_ => new ThreadStart(start))\n                            .Select(x => new Thread(x))\n                            .ToList();\n    foreach (var t in threads) t.Start();\n    foreach (var t in threads) t.Join();\n}\n\n```\n\n## References\n* Microsoft documentation, [ThreadStaticAttribute Class](https://docs.microsoft.com/en-us/dotnet/api/system.threadstaticattribute?view=netframework-4.7.2).\n* Stack Overflow, [Why does SHA1.ComputeHash fail under high load with many threads?](https://stackoverflow.com/questions/26592596/why-does-sha1-computehash-fail-under-high-load-with-many-threads).\n* Common Weakness Enumeration: [CWE-362](https://cwe.mitre.org/data/definitions/362.html).\n"
                },
                "properties": {
                  "tags": [
                    "concurrency",
                    "security",
                    "external/cwe/cwe-362"
                  ],
                  "description": "An instance of a class that either implements or has a field of type System.Security.Cryptography.ICryptoTransform is being captured by a lambda,\n              and used in what seems to be a thread initialization method.\n              Using an instance of this class in concurrent threads is dangerous as it may not only result in an error,\n              but under some circumstances may also result in incorrect results.",
                  "id": "cs/thread-unsafe-icryptotransform-captured-in-lambda",
                  "kind": "problem",
                  "name": "Thread-unsafe capturing of an ICryptoTransform object",
                  "precision": "medium",
                  "problem.severity": "warning",
                  "security-severity": "7.0"
                }
              },
              {
                "id": "cs/empty-password-in-configuration",
                "name": "cs/empty-password-in-configuration",
                "shortDescription": {
                  "text": "Empty password in configuration file"
                },
                "fullDescription": {
                  "text": "Finds empty passwords in configuration files."
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning"
                },
                "help": {
                  "text": "# Empty password in configuration file\nThe use of an empty string as a password in a configuration file is not secure.\n\n\n## Recommendation\nChoose a proper password and encrypt it if you need to store it in the configuration file.\n\n\n## References\n* Common Weakness Enumeration: [CWE-258](https://cwe.mitre.org/data/definitions/258.html).\n* Common Weakness Enumeration: [CWE-862](https://cwe.mitre.org/data/definitions/862.html).\n",
                  "markdown": "# Empty password in configuration file\nThe use of an empty string as a password in a configuration file is not secure.\n\n\n## Recommendation\nChoose a proper password and encrypt it if you need to store it in the configuration file.\n\n\n## References\n* Common Weakness Enumeration: [CWE-258](https://cwe.mitre.org/data/definitions/258.html).\n* Common Weakness Enumeration: [CWE-862](https://cwe.mitre.org/data/definitions/862.html).\n"
                },
                "properties": {
                  "tags": [
                    "security",
                    "external/cwe/cwe-258",
                    "external/cwe/cwe-862"
                  ],
                  "description": "Finds empty passwords in configuration files.",
                  "id": "cs/empty-password-in-configuration",
                  "kind": "problem",
                  "name": "Empty password in configuration file",
                  "precision": "medium",
                  "problem.severity": "warning",
                  "security-severity": "7.8"
                }
              },
              {
                "id": "cs/password-in-configuration",
                "name": "cs/password-in-configuration",
                "shortDescription": {
                  "text": "Password in configuration file"
                },
                "fullDescription": {
                  "text": "Finds passwords in configuration files."
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning"
                },
                "help": {
                  "text": "# Password in configuration file\nStoring a plaintext password in a configuration file allows anyone who can read the file to access the password-protected resources. Therefore it is a common attack vector.\n\n\n## Recommendation\nPasswords stored in configuration files should be encrypted.\n\n\n## References\n* Common Weakness Enumeration: [CWE-13](https://cwe.mitre.org/data/definitions/13.html).\n* Common Weakness Enumeration: [CWE-256](https://cwe.mitre.org/data/definitions/256.html).\n* Common Weakness Enumeration: [CWE-313](https://cwe.mitre.org/data/definitions/313.html).\n",
                  "markdown": "# Password in configuration file\nStoring a plaintext password in a configuration file allows anyone who can read the file to access the password-protected resources. Therefore it is a common attack vector.\n\n\n## Recommendation\nPasswords stored in configuration files should be encrypted.\n\n\n## References\n* Common Weakness Enumeration: [CWE-13](https://cwe.mitre.org/data/definitions/13.html).\n* Common Weakness Enumeration: [CWE-256](https://cwe.mitre.org/data/definitions/256.html).\n* Common Weakness Enumeration: [CWE-313](https://cwe.mitre.org/data/definitions/313.html).\n"
                },
                "properties": {
                  "tags": [
                    "security",
                    "external/cwe/cwe-13",
                    "external/cwe/cwe-256",
                    "external/cwe/cwe-313"
                  ],
                  "description": "Finds passwords in configuration files.",
                  "id": "cs/password-in-configuration",
                  "kind": "problem",
                  "name": "Password in configuration file",
                  "precision": "medium",
                  "problem.severity": "warning",
                  "security-severity": "7.5"
                }
              },
              {
                "id": "cs/session-reuse",
                "name": "cs/session-reuse",
                "shortDescription": {
                  "text": "Failure to abandon session"
                },
                "fullDescription": {
                  "text": "Reusing an existing session as a different user could allow an attacker to access someone else's account by using their session."
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "error"
                },
                "help": {
                  "text": "# Failure to abandon session\nReusing a session could allow an attacker to gain unauthorized access to another account. Always ensure that, when a user logs in or out, the current session is abandoned so that a new session may be started.\n\n\n## Recommendation\nAlways call `HttpSessionState.Abandon()` to ensure that the previous session is not used by the new user.\n\n\n## Example\nThe following example shows the previous session being used after authentication. This would allow a previous user to use the new user's account.\n\n\n```csharp\npublic void Login(HttpContext ctx, string username, string password)\n{\n    if (FormsAuthentication.Authenticate(username, password)\n    {\n        // BAD: Reusing the previous session\n        ctx.Session[\"Mode\"] = GetModeForUser(username);\n    }\n}\n\n```\nThis code example solves the problem by not reusing the session, and instead calling `Abandon()` to ensure that the session is not reused.\n\n\n```csharp\npublic void Login(HttpContext ctx, string username, string password)\n{\n    if (FormsAuthentication.Authenticate(username, password)\n    {\n        // GOOD: Abandon the session first.\n        ctx.Session.Abandon();\n    }\n}\n\n```\n\n## References\n* MSDN: [ASP.NET Session State Overview](https://msdn.microsoft.com/en-us/library/ms178581.aspx), [HttpSessionState.Abandon Method ()](https://msdn.microsoft.com/en-us/library/system.web.sessionstate.httpsessionstate.abandon(v=vs.110).aspx).\n* Common Weakness Enumeration: [CWE-384](https://cwe.mitre.org/data/definitions/384.html).\n",
                  "markdown": "# Failure to abandon session\nReusing a session could allow an attacker to gain unauthorized access to another account. Always ensure that, when a user logs in or out, the current session is abandoned so that a new session may be started.\n\n\n## Recommendation\nAlways call `HttpSessionState.Abandon()` to ensure that the previous session is not used by the new user.\n\n\n## Example\nThe following example shows the previous session being used after authentication. This would allow a previous user to use the new user's account.\n\n\n```csharp\npublic void Login(HttpContext ctx, string username, string password)\n{\n    if (FormsAuthentication.Authenticate(username, password)\n    {\n        // BAD: Reusing the previous session\n        ctx.Session[\"Mode\"] = GetModeForUser(username);\n    }\n}\n\n```\nThis code example solves the problem by not reusing the session, and instead calling `Abandon()` to ensure that the session is not reused.\n\n\n```csharp\npublic void Login(HttpContext ctx, string username, string password)\n{\n    if (FormsAuthentication.Authenticate(username, password)\n    {\n        // GOOD: Abandon the session first.\n        ctx.Session.Abandon();\n    }\n}\n\n```\n\n## References\n* MSDN: [ASP.NET Session State Overview](https://msdn.microsoft.com/en-us/library/ms178581.aspx), [HttpSessionState.Abandon Method ()](https://msdn.microsoft.com/en-us/library/system.web.sessionstate.httpsessionstate.abandon(v=vs.110).aspx).\n* Common Weakness Enumeration: [CWE-384](https://cwe.mitre.org/data/definitions/384.html).\n"
                },
                "properties": {
                  "tags": [
                    "security",
                    "external/cwe/cwe-384"
                  ],
                  "description": "Reusing an existing session as a different user could allow\n              an attacker to access someone else's account by using\n              their session.",
                  "id": "cs/session-reuse",
                  "kind": "problem",
                  "name": "Failure to abandon session",
                  "precision": "high",
                  "problem.severity": "error",
                  "security-severity": "8.8"
                }
              },
              {
                "id": "cs/web/missing-global-error-handler",
                "name": "cs/web/missing-global-error-handler",
                "shortDescription": {
                  "text": "Missing global error handler"
                },
                "fullDescription": {
                  "text": "ASP.NET applications should not set the 'customError' mode to \"off\" without providing a global error handler, otherwise they may leak exception information."
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning"
                },
                "help": {
                  "text": "# Missing global error handler\n`Web.config` files that set the `customErrors` mode to `Off` and do not provide an `Application_Error` method in the `global.asax.cs` file rely on the default error pages, which leak information such as stack traces.\n\n\n## Recommendation\nSet the `customErrors` to `On` to prevent the default error page from being displayed, or to `RemoteOnly` to only show the default error page when the application is accessed locally. Alternatively, provide an implementation of the `Application_Error` method in the `global.asax.cs` page.\n\n\n## Example\nThe following example shows a `Web.config` file in which the custom errors mode has been set to `Off`.\n\n\n```none\n<?xml version=\"1.0\" encoding=\"utf-8\" ?>\n<configuration>\n  <system.web>\n    <customErrors mode=\"Off\">\n      ...\n    </customErrors>\n  </system.web>\n</configuration>\n\n```\nThis can be fixed either by specifying a different mode, such as `On`, in the `Web.config` file:\n\n\n```none\n<?xml version=\"1.0\" encoding=\"utf-8\" ?>\n<configuration>\n  <system.web>\n    <customErrors mode=\"On\">\n      ...\n    </customErrors>\n  </system.web>\n</configuration>\n\n```\nor by defining an `Application_Error` method in the `global.asax.cs` file:\n\n\n```csharp\nusing System;\nusing System.Web;\n\nnamespace WebApp\n{\n    public class Global : HttpApplication\n    {\n        void Application_Error(object sender, EventArgs e)\n        {\n            // Handle errors here\n        }\n    }\n}\n\n```\n\n## References\n* Common Weakness Enumeration: [CWE-12](https://cwe.mitre.org/data/definitions/12.html).\n* Common Weakness Enumeration: [CWE-248](https://cwe.mitre.org/data/definitions/248.html).\n",
                  "markdown": "# Missing global error handler\n`Web.config` files that set the `customErrors` mode to `Off` and do not provide an `Application_Error` method in the `global.asax.cs` file rely on the default error pages, which leak information such as stack traces.\n\n\n## Recommendation\nSet the `customErrors` to `On` to prevent the default error page from being displayed, or to `RemoteOnly` to only show the default error page when the application is accessed locally. Alternatively, provide an implementation of the `Application_Error` method in the `global.asax.cs` page.\n\n\n## Example\nThe following example shows a `Web.config` file in which the custom errors mode has been set to `Off`.\n\n\n```none\n<?xml version=\"1.0\" encoding=\"utf-8\" ?>\n<configuration>\n  <system.web>\n    <customErrors mode=\"Off\">\n      ...\n    </customErrors>\n  </system.web>\n</configuration>\n\n```\nThis can be fixed either by specifying a different mode, such as `On`, in the `Web.config` file:\n\n\n```none\n<?xml version=\"1.0\" encoding=\"utf-8\" ?>\n<configuration>\n  <system.web>\n    <customErrors mode=\"On\">\n      ...\n    </customErrors>\n  </system.web>\n</configuration>\n\n```\nor by defining an `Application_Error` method in the `global.asax.cs` file:\n\n\n```csharp\nusing System;\nusing System.Web;\n\nnamespace WebApp\n{\n    public class Global : HttpApplication\n    {\n        void Application_Error(object sender, EventArgs e)\n        {\n            // Handle errors here\n        }\n    }\n}\n\n```\n\n## References\n* Common Weakness Enumeration: [CWE-12](https://cwe.mitre.org/data/definitions/12.html).\n* Common Weakness Enumeration: [CWE-248](https://cwe.mitre.org/data/definitions/248.html).\n"
                },
                "properties": {
                  "tags": [
                    "security",
                    "external/cwe/cwe-12",
                    "external/cwe/cwe-248"
                  ],
                  "description": "ASP.NET applications should not set the 'customError' mode to \"off\" without providing\n              a global error handler, otherwise they may leak exception information.",
                  "id": "cs/web/missing-global-error-handler",
                  "kind": "problem",
                  "name": "Missing global error handler",
                  "precision": "high",
                  "problem.severity": "warning",
                  "security-severity": "7.5"
                }
              },
              {
                "id": "cs/cleartext-storage-of-sensitive-information",
                "name": "cs/cleartext-storage-of-sensitive-information",
                "shortDescription": {
                  "text": "Clear text storage of sensitive information"
                },
                "fullDescription": {
                  "text": "Sensitive information stored without encryption or hashing can expose it to an attacker."
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "error"
                },
                "help": {
                  "text": "# Clear text storage of sensitive information\nSensitive information that is stored unencrypted is accessible to an attacker who gains access to the storage. This is particularly important for cookies, which are stored on the machine of the end-user.\n\n\n## Recommendation\nEnsure that sensitive information is always encrypted before being stored. For ASP.NET applications, the `System.Web.Security.MachineKey` class may be used to encode sensitive information.\n\nIf possible, avoid placing sensitive information in cookies all together. Instead, prefer storing a key in the cookie that can be used to lookup the sensitive information.\n\nIn general, decrypt sensitive information only at the point where it is necessary for it to be used in cleartext.\n\n\n## Example\nThe following example shows two ways of storing user credentials in a cookie. In the 'BAD' case, the credentials are simply stored in cleartext. In the 'GOOD' case, the credentials are protected before storing them, using `MachineKey.Protect`, wrapped in a utility method.\n\n\n```csharp\nusing System.Text;\nusing System.Web;\nusing System.Web.Security;\n\npublic class CleartextStorageHandler : IHttpHandler\n{\n\n    public void ProcessRequest(HttpContext ctx)\n    {\n        string accountName = ctx.Request.QueryString[\"AccountName\"];\n        // BAD: Setting a cookie value with cleartext sensitive data.\n        ctx.Response.Cookies[\"AccountName\"].Value = accountName;\n        // GOOD: Encoding the value before setting it.\n        ctx.Response.Cookies[\"AccountName\"].Value = Protect(accountName, \"Account name\");\n    }\n\n    /// <summary>\n    /// Protect the cleartext value, using the given type.\n    /// </summary>\n    /// <value>\n    /// The protected value, which is no longer cleartext.\n    /// </value>\n    public string Protect(string value, string type)\n    {\n        return Encoding.UTF8.GetString(MachineKey.Protect(Encoding.UTF8.GetBytes(value), type));\n    }\n}\n\n```\n\n## References\n* M. Dowd, J. McDonald and J. Schuhm, *The Art of Software Security Assessment*, 1st Edition, Chapter 2 - 'Common Vulnerabilities of Encryption', p. 43. Addison Wesley, 2006.\n* M. Howard and D. LeBlanc, *Writing Secure Code*, 2nd Edition, Chapter 9 - 'Protecting Secret Data', p. 299. Microsoft, 2002.\n* Common Weakness Enumeration: [CWE-312](https://cwe.mitre.org/data/definitions/312.html).\n* Common Weakness Enumeration: [CWE-315](https://cwe.mitre.org/data/definitions/315.html).\n* Common Weakness Enumeration: [CWE-359](https://cwe.mitre.org/data/definitions/359.html).\n",
                  "markdown": "# Clear text storage of sensitive information\nSensitive information that is stored unencrypted is accessible to an attacker who gains access to the storage. This is particularly important for cookies, which are stored on the machine of the end-user.\n\n\n## Recommendation\nEnsure that sensitive information is always encrypted before being stored. For ASP.NET applications, the `System.Web.Security.MachineKey` class may be used to encode sensitive information.\n\nIf possible, avoid placing sensitive information in cookies all together. Instead, prefer storing a key in the cookie that can be used to lookup the sensitive information.\n\nIn general, decrypt sensitive information only at the point where it is necessary for it to be used in cleartext.\n\n\n## Example\nThe following example shows two ways of storing user credentials in a cookie. In the 'BAD' case, the credentials are simply stored in cleartext. In the 'GOOD' case, the credentials are protected before storing them, using `MachineKey.Protect`, wrapped in a utility method.\n\n\n```csharp\nusing System.Text;\nusing System.Web;\nusing System.Web.Security;\n\npublic class CleartextStorageHandler : IHttpHandler\n{\n\n    public void ProcessRequest(HttpContext ctx)\n    {\n        string accountName = ctx.Request.QueryString[\"AccountName\"];\n        // BAD: Setting a cookie value with cleartext sensitive data.\n        ctx.Response.Cookies[\"AccountName\"].Value = accountName;\n        // GOOD: Encoding the value before setting it.\n        ctx.Response.Cookies[\"AccountName\"].Value = Protect(accountName, \"Account name\");\n    }\n\n    /// <summary>\n    /// Protect the cleartext value, using the given type.\n    /// </summary>\n    /// <value>\n    /// The protected value, which is no longer cleartext.\n    /// </value>\n    public string Protect(string value, string type)\n    {\n        return Encoding.UTF8.GetString(MachineKey.Protect(Encoding.UTF8.GetBytes(value), type));\n    }\n}\n\n```\n\n## References\n* M. Dowd, J. McDonald and J. Schuhm, *The Art of Software Security Assessment*, 1st Edition, Chapter 2 - 'Common Vulnerabilities of Encryption', p. 43. Addison Wesley, 2006.\n* M. Howard and D. LeBlanc, *Writing Secure Code*, 2nd Edition, Chapter 9 - 'Protecting Secret Data', p. 299. Microsoft, 2002.\n* Common Weakness Enumeration: [CWE-312](https://cwe.mitre.org/data/definitions/312.html).\n* Common Weakness Enumeration: [CWE-315](https://cwe.mitre.org/data/definitions/315.html).\n* Common Weakness Enumeration: [CWE-359](https://cwe.mitre.org/data/definitions/359.html).\n"
                },
                "properties": {
                  "tags": [
                    "security",
                    "external/cwe/cwe-312",
                    "external/cwe/cwe-315",
                    "external/cwe/cwe-359"
                  ],
                  "description": "Sensitive information stored without encryption or hashing can expose it to an\n              attacker.",
                  "id": "cs/cleartext-storage-of-sensitive-information",
                  "kind": "path-problem",
                  "name": "Clear text storage of sensitive information",
                  "precision": "high",
                  "problem.severity": "error",
                  "security-severity": "7.5"
                }
              },
              {
                "id": "cs/insecure-randomness",
                "name": "cs/insecure-randomness",
                "shortDescription": {
                  "text": "Insecure randomness"
                },
                "fullDescription": {
                  "text": "Using a cryptographically weak pseudo-random number generator to generate a security sensitive value may allow an attacker to predict what sensitive value will be generated."
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning"
                },
                "help": {
                  "text": "# Insecure randomness\nUsing a cryptographically weak pseudo-random number generator to generate a security-sensitive value, such as a password, makes it easier for an attacker to predict the value.\n\nPseudo-random number generators generate a sequence of numbers that only approximates the properties of random numbers. The sequence is not truly random because it is completely determined by a relatively small set of initial values, the seed. If the random number generator is cryptographically weak, then this sequence may be easily predictable through outside observations.\n\n\n## Recommendation\nUse a cryptographically secure pseudo-random number generator if the output is to be used in a security sensitive context. As a rule of thumb, a value should be considered \"security sensitive\" if predicting it would allow the attacker to perform an action that they would otherwise be unable to perform. For example, if an attacker could predict the random password generated for a new user, they would be able to log in as that new user.\n\nFor C\\#, `RNGCryptoServiceProvider` provides a cryptographically secure pseudo-random number generator. `Random` is not cryptographically secure, and should be avoided in security contexts. For contexts which are not security sensitive, `Random` may be preferable as it has a more convenient interface, and is likely to be faster.\n\n\n## Example\nThe following examples show different ways of generating a password.\n\nIn the first case, we generate a fresh password by appending a random integer to the end of a static string. The random number generator used (`Random`) is not cryptographically secure, so it may be possible for an attacker to predict the generated password.\n\nIn the second example, a cryptographically secure random number generator is used for the same purpose. In this case, it is much harder to predict the generated integers.\n\nIn the final example, the password is generated using the `Membership.GeneratePassword` library method, which generates a password with a bias, therefore should be avoided.\n\n\n```csharp\nusing System.Security.Cryptography;\nusing System.Web.Security;\n\nstring GeneratePassword()\n{\n    // BAD: Password is generated using a cryptographically insecure RNG\n    Random gen = new Random();\n    string password = \"mypassword\" + gen.Next();\n\n    // GOOD: Password is generated using a cryptographically secure RNG\n    using (RNGCryptoServiceProvider crypto = new RNGCryptoServiceProvider())\n    {\n        byte[] randomBytes = new byte[sizeof(int)];\n        crypto.GetBytes(randomBytes);\n        password = \"mypassword\" + BitConverter.ToInt32(randomBytes);\n    }\n\n    // BAD: Membership.GeneratePassword generates a password with a bias\n    password = Membership.GeneratePassword(12, 3);\n\n    return password;\n}\n\n```\n\n## References\n* Wikipedia. [Pseudo-random number generator](http://en.wikipedia.org/wiki/Pseudorandom_number_generator).\n* MSDN. [RandomNumberGenerator](http://msdn.microsoft.com/en-us/library/system.security.cryptography.randomnumbergenerator.aspx).\n* MSDN. [Membership.GeneratePassword](https://msdn.microsoft.com/en-us/library/system.web.security.membership.generatepassword(v=vs.110).aspx).\n* Common Weakness Enumeration: [CWE-338](https://cwe.mitre.org/data/definitions/338.html).\n",
                  "markdown": "# Insecure randomness\nUsing a cryptographically weak pseudo-random number generator to generate a security-sensitive value, such as a password, makes it easier for an attacker to predict the value.\n\nPseudo-random number generators generate a sequence of numbers that only approximates the properties of random numbers. The sequence is not truly random because it is completely determined by a relatively small set of initial values, the seed. If the random number generator is cryptographically weak, then this sequence may be easily predictable through outside observations.\n\n\n## Recommendation\nUse a cryptographically secure pseudo-random number generator if the output is to be used in a security sensitive context. As a rule of thumb, a value should be considered \"security sensitive\" if predicting it would allow the attacker to perform an action that they would otherwise be unable to perform. For example, if an attacker could predict the random password generated for a new user, they would be able to log in as that new user.\n\nFor C\\#, `RNGCryptoServiceProvider` provides a cryptographically secure pseudo-random number generator. `Random` is not cryptographically secure, and should be avoided in security contexts. For contexts which are not security sensitive, `Random` may be preferable as it has a more convenient interface, and is likely to be faster.\n\n\n## Example\nThe following examples show different ways of generating a password.\n\nIn the first case, we generate a fresh password by appending a random integer to the end of a static string. The random number generator used (`Random`) is not cryptographically secure, so it may be possible for an attacker to predict the generated password.\n\nIn the second example, a cryptographically secure random number generator is used for the same purpose. In this case, it is much harder to predict the generated integers.\n\nIn the final example, the password is generated using the `Membership.GeneratePassword` library method, which generates a password with a bias, therefore should be avoided.\n\n\n```csharp\nusing System.Security.Cryptography;\nusing System.Web.Security;\n\nstring GeneratePassword()\n{\n    // BAD: Password is generated using a cryptographically insecure RNG\n    Random gen = new Random();\n    string password = \"mypassword\" + gen.Next();\n\n    // GOOD: Password is generated using a cryptographically secure RNG\n    using (RNGCryptoServiceProvider crypto = new RNGCryptoServiceProvider())\n    {\n        byte[] randomBytes = new byte[sizeof(int)];\n        crypto.GetBytes(randomBytes);\n        password = \"mypassword\" + BitConverter.ToInt32(randomBytes);\n    }\n\n    // BAD: Membership.GeneratePassword generates a password with a bias\n    password = Membership.GeneratePassword(12, 3);\n\n    return password;\n}\n\n```\n\n## References\n* Wikipedia. [Pseudo-random number generator](http://en.wikipedia.org/wiki/Pseudorandom_number_generator).\n* MSDN. [RandomNumberGenerator](http://msdn.microsoft.com/en-us/library/system.security.cryptography.randomnumbergenerator.aspx).\n* MSDN. [Membership.GeneratePassword](https://msdn.microsoft.com/en-us/library/system.web.security.membership.generatepassword(v=vs.110).aspx).\n* Common Weakness Enumeration: [CWE-338](https://cwe.mitre.org/data/definitions/338.html).\n"
                },
                "properties": {
                  "tags": [
                    "security",
                    "external/cwe/cwe-338"
                  ],
                  "description": "Using a cryptographically weak pseudo-random number generator to generate a\n              security sensitive value may allow an attacker to predict what sensitive value will\n              be generated.",
                  "id": "cs/insecure-randomness",
                  "kind": "path-problem",
                  "name": "Insecure randomness",
                  "precision": "high",
                  "problem.severity": "warning",
                  "security-severity": "7.8"
                }
              },
              {
                "id": "cs/web/unvalidated-url-redirection",
                "name": "cs/web/unvalidated-url-redirection",
                "shortDescription": {
                  "text": "URL redirection from remote source"
                },
                "fullDescription": {
                  "text": "URL redirection based on unvalidated user input may cause redirection to malicious web sites."
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "error"
                },
                "help": {
                  "text": "# URL redirection from remote source\nDirectly incorporating user input into a URL redirect request without validating the input can facilitate phishing attacks. In these attacks, unsuspecting users can be redirected to a malicious site that looks very similar to the real site they intend to visit, but which is controlled by the attacker.\n\n\n## Recommendation\nTo guard against untrusted URL redirection, it is advisable to avoid putting user input directly into a redirect URL. Instead, maintain a list of authorized redirects on the server; then choose from that list based on the user input provided.\n\nIf this is not possible, then the user input should be validated in some other way, for example, by verifying that the target URL is on the same host as the current page.\n\n\n## Example\nThe following example shows an HTTP request parameter being used directly in a URL redirect without validating the input, which facilitates phishing attacks:\n\n\n```csharp\nusing System;\nusing System.Web;\n\npublic class UnvalidatedUrlHandler : IHttpHandler\n{\n    public void ProcessRequest(HttpContext ctx)\n    {\n        // BAD: a request parameter is incorporated without validation into a URL redirect\n        ctx.Response.Redirect(ctx.Request.QueryString[\"page\"]);\n    }\n}\n\n```\nOne way to remedy the problem is to validate the user input against a known fixed string before doing the redirection:\n\n\n```csharp\nusing System;\nusing System.Web;\nusing System.Collections.Generic;\n\npublic class UnvalidatedUrlHandler : IHttpHandler\n{\n    private List<string> VALID_REDIRECTS = new List<string>{ \"http://cwe.mitre.org/data/definitions/601.html\", \"http://cwe.mitre.org/data/definitions/79.html\" };\n\n    public void ProcessRequest(HttpContext ctx)\n    {\n        if (VALID_REDIRECTS.Contains(ctx.Request.QueryString[\"page\"]))\n        {\n            // GOOD: the request parameter is validated against a known list of strings\n            ctx.Response.Redirect(ctx.Request.QueryString[\"page\"]);\n        }\n    }\n}\n```\nAlternatively, we can check that the target URL does not redirect to a different host by checking that the URL is either relative or on a known good host:\n\n\n```csharp\nusing System;\nusing System.Web;\n\npublic class UnvalidatedUrlHandler : IHttpHandler\n{\n    public void ProcessRequest(HttpContext ctx)\n    {\n        var urlString = ctx.Request.QueryString[\"page\"];\n        var url = new Uri(urlString, UriKind.RelativeOrAbsolute);\n\n        var url = new Uri(redirectUrl, UriKind.RelativeOrAbsolute);\n        if (!url.IsAbsoluteUri) {\n            // GOOD: The redirect is to a relative URL\n            ctx.Response.Redirect(url.ToString());\n        }\n\n        if (url.Host == \"example.org\") {\n            // GOOD: The redirect is to a known host\n            ctx.Response.Redirect(url.ToString());\n        }\n    }\n}\n```\nNote that as written, the above code will allow redirects to URLs on `example.com`, which is harmless but perhaps not intended. You can substitute your own domain (if known) for `example.com` to prevent this.\n\n\n## References\n* OWASP: [ Unvalidated Redirects and Forwards Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Unvalidated_Redirects_and_Forwards_Cheat_Sheet.html).\n* Microsoft Docs: [Preventing Open Redirection Attacks (C\\#)](https://docs.microsoft.com/en-us/aspnet/mvc/overview/security/preventing-open-redirection-attacks).\n* Common Weakness Enumeration: [CWE-601](https://cwe.mitre.org/data/definitions/601.html).\n",
                  "markdown": "# URL redirection from remote source\nDirectly incorporating user input into a URL redirect request without validating the input can facilitate phishing attacks. In these attacks, unsuspecting users can be redirected to a malicious site that looks very similar to the real site they intend to visit, but which is controlled by the attacker.\n\n\n## Recommendation\nTo guard against untrusted URL redirection, it is advisable to avoid putting user input directly into a redirect URL. Instead, maintain a list of authorized redirects on the server; then choose from that list based on the user input provided.\n\nIf this is not possible, then the user input should be validated in some other way, for example, by verifying that the target URL is on the same host as the current page.\n\n\n## Example\nThe following example shows an HTTP request parameter being used directly in a URL redirect without validating the input, which facilitates phishing attacks:\n\n\n```csharp\nusing System;\nusing System.Web;\n\npublic class UnvalidatedUrlHandler : IHttpHandler\n{\n    public void ProcessRequest(HttpContext ctx)\n    {\n        // BAD: a request parameter is incorporated without validation into a URL redirect\n        ctx.Response.Redirect(ctx.Request.QueryString[\"page\"]);\n    }\n}\n\n```\nOne way to remedy the problem is to validate the user input against a known fixed string before doing the redirection:\n\n\n```csharp\nusing System;\nusing System.Web;\nusing System.Collections.Generic;\n\npublic class UnvalidatedUrlHandler : IHttpHandler\n{\n    private List<string> VALID_REDIRECTS = new List<string>{ \"http://cwe.mitre.org/data/definitions/601.html\", \"http://cwe.mitre.org/data/definitions/79.html\" };\n\n    public void ProcessRequest(HttpContext ctx)\n    {\n        if (VALID_REDIRECTS.Contains(ctx.Request.QueryString[\"page\"]))\n        {\n            // GOOD: the request parameter is validated against a known list of strings\n            ctx.Response.Redirect(ctx.Request.QueryString[\"page\"]);\n        }\n    }\n}\n```\nAlternatively, we can check that the target URL does not redirect to a different host by checking that the URL is either relative or on a known good host:\n\n\n```csharp\nusing System;\nusing System.Web;\n\npublic class UnvalidatedUrlHandler : IHttpHandler\n{\n    public void ProcessRequest(HttpContext ctx)\n    {\n        var urlString = ctx.Request.QueryString[\"page\"];\n        var url = new Uri(urlString, UriKind.RelativeOrAbsolute);\n\n        var url = new Uri(redirectUrl, UriKind.RelativeOrAbsolute);\n        if (!url.IsAbsoluteUri) {\n            // GOOD: The redirect is to a relative URL\n            ctx.Response.Redirect(url.ToString());\n        }\n\n        if (url.Host == \"example.org\") {\n            // GOOD: The redirect is to a known host\n            ctx.Response.Redirect(url.ToString());\n        }\n    }\n}\n```\nNote that as written, the above code will allow redirects to URLs on `example.com`, which is harmless but perhaps not intended. You can substitute your own domain (if known) for `example.com` to prevent this.\n\n\n## References\n* OWASP: [ Unvalidated Redirects and Forwards Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Unvalidated_Redirects_and_Forwards_Cheat_Sheet.html).\n* Microsoft Docs: [Preventing Open Redirection Attacks (C\\#)](https://docs.microsoft.com/en-us/aspnet/mvc/overview/security/preventing-open-redirection-attacks).\n* Common Weakness Enumeration: [CWE-601](https://cwe.mitre.org/data/definitions/601.html).\n"
                },
                "properties": {
                  "tags": [
                    "security",
                    "external/cwe/cwe-601"
                  ],
                  "description": "URL redirection based on unvalidated user input\n              may cause redirection to malicious web sites.",
                  "id": "cs/web/unvalidated-url-redirection",
                  "kind": "path-problem",
                  "name": "URL redirection from remote source",
                  "precision": "high",
                  "problem.severity": "error",
                  "security-severity": "6.1"
                }
              },
              {
                "id": "cs/web/broad-cookie-path",
                "name": "cs/web/broad-cookie-path",
                "shortDescription": {
                  "text": "Cookie security: overly broad path"
                },
                "fullDescription": {
                  "text": "Finds cookies with an overly broad path."
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning"
                },
                "help": {
                  "text": "# Cookie security: overly broad path\nThis rule finds cookies with an overly broad path. Cookies with an overly broad path, such as the root context path (\"/\"), can be accessed by all web applications on the same domain name. A cookie with sensitive data, but with too broad a path, could hence be read and tampered by a less secure and untrusted application.\n\n\n## Recommendation\nPrecisely define the path of the web application for which this cookie is valid.\n\n\n## Example\nIn this example the cookie will be accessible to all applications regardless of their path. Most likely some of these applications are less secure than others and do not even need to access the same cookies.\n\n\n```csharp\nclass CookieWithOverlyBroadPath\n{\n    static public void AddCookie()\n    {\n        HttpCookie cookie = new HttpCookie(\"sessionID\");\n        cookie.Path = \"/\";\n    }\n}\n\n```\nIn the following example the cookie is only accessible to the web application at the \"/ebanking\" path.\n\n\n```csharp\nclass CookieWithOverlyBroadPathFix\n{\n    static public void AddCookie()\n    {\n        HttpCookie cookie = new HttpCookie(\"sessionID\");\n        cookie.Path = \"/ebanking\";\n    }\n}\n\n```\n\n## References\n* MSDN: [HttpCookie.Path Property](http://msdn.microsoft.com/en-us/library/system.web.httpcookie.path.aspx).\n* Common Weakness Enumeration: [CWE-287](https://cwe.mitre.org/data/definitions/287.html).\n",
                  "markdown": "# Cookie security: overly broad path\nThis rule finds cookies with an overly broad path. Cookies with an overly broad path, such as the root context path (\"/\"), can be accessed by all web applications on the same domain name. A cookie with sensitive data, but with too broad a path, could hence be read and tampered by a less secure and untrusted application.\n\n\n## Recommendation\nPrecisely define the path of the web application for which this cookie is valid.\n\n\n## Example\nIn this example the cookie will be accessible to all applications regardless of their path. Most likely some of these applications are less secure than others and do not even need to access the same cookies.\n\n\n```csharp\nclass CookieWithOverlyBroadPath\n{\n    static public void AddCookie()\n    {\n        HttpCookie cookie = new HttpCookie(\"sessionID\");\n        cookie.Path = \"/\";\n    }\n}\n\n```\nIn the following example the cookie is only accessible to the web application at the \"/ebanking\" path.\n\n\n```csharp\nclass CookieWithOverlyBroadPathFix\n{\n    static public void AddCookie()\n    {\n        HttpCookie cookie = new HttpCookie(\"sessionID\");\n        cookie.Path = \"/ebanking\";\n    }\n}\n\n```\n\n## References\n* MSDN: [HttpCookie.Path Property](http://msdn.microsoft.com/en-us/library/system.web.httpcookie.path.aspx).\n* Common Weakness Enumeration: [CWE-287](https://cwe.mitre.org/data/definitions/287.html).\n"
                },
                "properties": {
                  "tags": [
                    "security",
                    "external/cwe/cwe-287"
                  ],
                  "description": "Finds cookies with an overly broad path.",
                  "id": "cs/web/broad-cookie-path",
                  "kind": "problem",
                  "name": "Cookie security: overly broad path",
                  "precision": "high",
                  "problem.severity": "warning",
                  "security-severity": "9.3"
                }
              },
              {
                "id": "cs/web/disabled-header-checking",
                "name": "cs/web/disabled-header-checking",
                "shortDescription": {
                  "text": "Header checking disabled"
                },
                "fullDescription": {
                  "text": "Finds places where header checking is disabled."
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning"
                },
                "help": {
                  "text": "# Header checking disabled\nThis rule finds places in the code where header checking is disabled. When header checking is enabled, which is the default, the `\\r` or `\\n` characters found in a response header are encoded to `%0d` and `%0a`. This defeats header-injection attacks by making the injected material part of the same header line. If you disable header checking, you open potential attack vectors against your client code.\n\n\n## Recommendation\nDo not disable header checking.\n\n\n## References\n* MSDN. [HttpRuntimeSection.EnableHeaderChecking Property](http://msdn.microsoft.com/en-us/library/system.web.configuration.httpruntimesection.enableheaderchecking.aspx).\n* Common Weakness Enumeration: [CWE-113](https://cwe.mitre.org/data/definitions/113.html).\n",
                  "markdown": "# Header checking disabled\nThis rule finds places in the code where header checking is disabled. When header checking is enabled, which is the default, the `\\r` or `\\n` characters found in a response header are encoded to `%0d` and `%0a`. This defeats header-injection attacks by making the injected material part of the same header line. If you disable header checking, you open potential attack vectors against your client code.\n\n\n## Recommendation\nDo not disable header checking.\n\n\n## References\n* MSDN. [HttpRuntimeSection.EnableHeaderChecking Property](http://msdn.microsoft.com/en-us/library/system.web.configuration.httpruntimesection.enableheaderchecking.aspx).\n* Common Weakness Enumeration: [CWE-113](https://cwe.mitre.org/data/definitions/113.html).\n"
                },
                "properties": {
                  "tags": [
                    "security",
                    "external/cwe/cwe-113"
                  ],
                  "description": "Finds places where header checking is disabled.",
                  "id": "cs/web/disabled-header-checking",
                  "kind": "problem",
                  "name": "Header checking disabled",
                  "precision": "high",
                  "problem.severity": "warning",
                  "security-severity": "6.1"
                }
              },
              {
                "id": "cs/adding-cert-to-root-store",
                "name": "cs/adding-cert-to-root-store",
                "shortDescription": {
                  "text": "Do not add certificates to the system root store."
                },
                "fullDescription": {
                  "text": "Application- or user-specific certificates placed in the system root store could weaken security for other processing running on the same system."
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "error"
                },
                "properties": {
                  "tags": [
                    "security",
                    "external/cwe/cwe-327"
                  ],
                  "description": "Application- or user-specific certificates placed in the system root store could\n              weaken security for other processing running on the same system.",
                  "id": "cs/adding-cert-to-root-store",
                  "kind": "path-problem",
                  "name": "Do not add certificates to the system root store.",
                  "problem.severity": "error",
                  "security-severity": "7.5"
                }
              },
              {
                "id": "cs/insecure-sql-connection",
                "name": "cs/insecure-sql-connection",
                "shortDescription": {
                  "text": "Insecure SQL connection"
                },
                "fullDescription": {
                  "text": "Using an SQL Server connection without enforcing encryption is a security vulnerability."
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "error"
                },
                "help": {
                  "text": "# Insecure SQL connection\nSQL Server connections where the client is not enforcing the encryption in transit are susceptible to multiple attacks, including a man-in-the-middle, that would potentially compromise the user credentials and/or the TDS session.\n\n\n## Recommendation\nEnsure that the client code enforces the `Encrypt` option by setting it to `true` in the connection string.\n\n\n## Example\nThe following example shows a SQL connection string that is not explicitly enabling the `Encrypt` setting to force encryption.\n\n\n```csharp\nusing System.Data.SqlClient;\n\n// BAD, Encrypt not specified\nstring connectString =\n    \"Server=1.2.3.4;Database=Anything;Integrated Security=true;\";\nSqlConnectionStringBuilder builder = new SqlConnectionStringBuilder(connectString);\nvar conn = new SqlConnection(builder.ConnectionString);\n```\nThe following example shows a SQL connection string that is explicitly enabling the `Encrypt` setting to force encryption in transit.\n\n\n```csharp\nusing System.Data.SqlClient;\n\nstring connectString =\n    \"Server=1.2.3.4;Database=Anything;Integrated Security=true;;Encrypt=true;\";\nSqlConnectionStringBuilder builder = new SqlConnectionStringBuilder(connectString);\nvar conn = new SqlConnection(builder.ConnectionString);\n```\n\n## References\n* Microsoft, SQL Protocols blog: [Selectively using secure connection to SQL Server](https://blogs.msdn.microsoft.com/sql_protocols/2009/10/19/selectively-using-secure-connection-to-sql-server/).\n* Microsoft: [SqlConnection.ConnectionString Property](https://msdn.microsoft.com/en-us/library/system.data.sqlclient.sqlconnection.connectionstring(v=vs.110).aspx).\n* Microsoft: [Using Connection String Keywords with SQL Server Native Client](https://msdn.microsoft.com/en-us/library/ms130822.aspx).\n* Microsoft: [Setting the connection properties](https://msdn.microsoft.com/en-us/library/ms378988(v=sql.110).aspx).\n* Common Weakness Enumeration: [CWE-327](https://cwe.mitre.org/data/definitions/327.html).\n",
                  "markdown": "# Insecure SQL connection\nSQL Server connections where the client is not enforcing the encryption in transit are susceptible to multiple attacks, including a man-in-the-middle, that would potentially compromise the user credentials and/or the TDS session.\n\n\n## Recommendation\nEnsure that the client code enforces the `Encrypt` option by setting it to `true` in the connection string.\n\n\n## Example\nThe following example shows a SQL connection string that is not explicitly enabling the `Encrypt` setting to force encryption.\n\n\n```csharp\nusing System.Data.SqlClient;\n\n// BAD, Encrypt not specified\nstring connectString =\n    \"Server=1.2.3.4;Database=Anything;Integrated Security=true;\";\nSqlConnectionStringBuilder builder = new SqlConnectionStringBuilder(connectString);\nvar conn = new SqlConnection(builder.ConnectionString);\n```\nThe following example shows a SQL connection string that is explicitly enabling the `Encrypt` setting to force encryption in transit.\n\n\n```csharp\nusing System.Data.SqlClient;\n\nstring connectString =\n    \"Server=1.2.3.4;Database=Anything;Integrated Security=true;;Encrypt=true;\";\nSqlConnectionStringBuilder builder = new SqlConnectionStringBuilder(connectString);\nvar conn = new SqlConnection(builder.ConnectionString);\n```\n\n## References\n* Microsoft, SQL Protocols blog: [Selectively using secure connection to SQL Server](https://blogs.msdn.microsoft.com/sql_protocols/2009/10/19/selectively-using-secure-connection-to-sql-server/).\n* Microsoft: [SqlConnection.ConnectionString Property](https://msdn.microsoft.com/en-us/library/system.data.sqlclient.sqlconnection.connectionstring(v=vs.110).aspx).\n* Microsoft: [Using Connection String Keywords with SQL Server Native Client](https://msdn.microsoft.com/en-us/library/ms130822.aspx).\n* Microsoft: [Setting the connection properties](https://msdn.microsoft.com/en-us/library/ms378988(v=sql.110).aspx).\n* Common Weakness Enumeration: [CWE-327](https://cwe.mitre.org/data/definitions/327.html).\n"
                },
                "properties": {
                  "tags": [
                    "security",
                    "external/cwe/cwe-327"
                  ],
                  "description": "Using an SQL Server connection without enforcing encryption is a security vulnerability.",
                  "id": "cs/insecure-sql-connection",
                  "kind": "path-problem",
                  "name": "Insecure SQL connection",
                  "precision": "medium",
                  "problem.severity": "error",
                  "security-severity": "7.5"
                }
              },
              {
                "id": "cs/web/insecure-direct-object-reference",
                "name": "cs/web/insecure-direct-object-reference",
                "shortDescription": {
                  "text": "Insecure Direct Object Reference"
                },
                "fullDescription": {
                  "text": "Using user input to control which object is modified without proper authorization checks allows an attacker to modify arbitrary objects."
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning"
                },
                "help": {
                  "text": "# Insecure Direct Object Reference\nResources like comments or user profiles can be accessed and modified through an action method. To target a certain resource, the action method accepts an ID parameter pointing to that specific resource. If the methods do not check that the current user is authorized to access the specified resource, an attacker can access a resource by guessing or otherwise determining the linked ID parameter.\n\n\n## Recommendation\nEnsure that the current user is authorized to access the resource of the provided ID.\n\n\n## Example\nIn the following example, in the \"BAD\" case, there is no authorization check, so any user can edit any comment for which they guess or determine the ID parameter. The \"GOOD\" case includes a check that the current user matches the author of the comment, preventing unauthorized access.\n\n\n```csharp\n    // BAD - Any user can access this method.\n    protected void btn1_Click(object sender, EventArgs e) {\n        string commentId = Request.QueryString[\"Id\"];\n        Comment comment = getCommentById(commentId);\n        comment.Body = inputCommentBody.Text;\n    }\n\n    // GOOD - The user ID is verified.\n    protected void btn2_Click(object sender, EventArgs e) {\n        string commentId = Request.QueryString[\"Id\"];\n        Comment comment = getCommentById(commentId);\n        if (comment.AuthorName == User.Identity.Name){\n            comment.Body = inputCommentBody.Text;\n        }\n    }\n```\nThe following example shows a similar scenario for the ASP.NET Core framework. As above, the \"BAD\" case provides an example with no authorization check, and the first \"GOOD\" case provides an example with a check that the current user authored the specified comment. Additionally, in the second \"GOOD\" case, the \\`Authorize\\` attribute is used to restrict the method to administrators, who are expected to be able to access arbitrary resources.\n\n\n```csharp\npublic class CommentController : Controller {\n    private readonly IAuthorizationService _authorizationService;\n    private readonly IDocumentRepository _commentRepository;\n\n    public CommentController(IAuthorizationService authorizationService,\n                              ICommentRepository commentRepository)\n    {\n        _authorizationService = authorizationService;\n        _commentRepository = commentRepository;\n    }\n\n    // BAD: Any user can access this.\n    public async Task<IActionResult> Edit1(int commentId, string text) {\n        Comment comment = _commentRepository.Find(commentId);\n        \n        comment.Text = text;\n\n        return View();\n    }\n\n    // GOOD: An authorization check is made.\n    public async Task<IActionResult> Edit2(int commentId, string text) {\n        Comment comment = _commentRepository.Find(commentId);\n        \n        var authResult = await _authorizationService.AuthorizeAsync(User, Comment, \"EditPolicy\");\n\n        if (authResult.Succeeded) {\n            comment.Text = text;\n            return View();\n        }\n        else {\n            return ForbidResult();\n        }\n    }\n\n    // GOOD: Only users with the `admin` role can access this method.\n    [Authorize(Roles=\"admin\")]\n    public async Task<IActionResult> Edit3(int commentId, string text) {\n        Comment comment = _commentRepository.Find(commentId);\n        \n        comment.Text = text;\n\n        return View();\n    }\n}\n```\n\n## References\n* OWASP: [Insecure Direct Object Refrences](https://wiki.owasp.org/index.php/Top_10_2013-A4-Insecure_Direct_Object_References).\n* OWASP: [Testing for Insecure Direct Object References](https://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/05-Authorization_Testing/04-Testing_for_Insecure_Direct_Object_References).\n* Microsoft Learn: [Resource-based authorization in ASP.NET Core](https://learn.microsoft.com/en-us/aspnet/core/security/authorization/resourcebased?view=aspnetcore-7.0).\n* Common Weakness Enumeration: [CWE-639](https://cwe.mitre.org/data/definitions/639.html).\n",
                  "markdown": "# Insecure Direct Object Reference\nResources like comments or user profiles can be accessed and modified through an action method. To target a certain resource, the action method accepts an ID parameter pointing to that specific resource. If the methods do not check that the current user is authorized to access the specified resource, an attacker can access a resource by guessing or otherwise determining the linked ID parameter.\n\n\n## Recommendation\nEnsure that the current user is authorized to access the resource of the provided ID.\n\n\n## Example\nIn the following example, in the \"BAD\" case, there is no authorization check, so any user can edit any comment for which they guess or determine the ID parameter. The \"GOOD\" case includes a check that the current user matches the author of the comment, preventing unauthorized access.\n\n\n```csharp\n    // BAD - Any user can access this method.\n    protected void btn1_Click(object sender, EventArgs e) {\n        string commentId = Request.QueryString[\"Id\"];\n        Comment comment = getCommentById(commentId);\n        comment.Body = inputCommentBody.Text;\n    }\n\n    // GOOD - The user ID is verified.\n    protected void btn2_Click(object sender, EventArgs e) {\n        string commentId = Request.QueryString[\"Id\"];\n        Comment comment = getCommentById(commentId);\n        if (comment.AuthorName == User.Identity.Name){\n            comment.Body = inputCommentBody.Text;\n        }\n    }\n```\nThe following example shows a similar scenario for the ASP.NET Core framework. As above, the \"BAD\" case provides an example with no authorization check, and the first \"GOOD\" case provides an example with a check that the current user authored the specified comment. Additionally, in the second \"GOOD\" case, the \\`Authorize\\` attribute is used to restrict the method to administrators, who are expected to be able to access arbitrary resources.\n\n\n```csharp\npublic class CommentController : Controller {\n    private readonly IAuthorizationService _authorizationService;\n    private readonly IDocumentRepository _commentRepository;\n\n    public CommentController(IAuthorizationService authorizationService,\n                              ICommentRepository commentRepository)\n    {\n        _authorizationService = authorizationService;\n        _commentRepository = commentRepository;\n    }\n\n    // BAD: Any user can access this.\n    public async Task<IActionResult> Edit1(int commentId, string text) {\n        Comment comment = _commentRepository.Find(commentId);\n        \n        comment.Text = text;\n\n        return View();\n    }\n\n    // GOOD: An authorization check is made.\n    public async Task<IActionResult> Edit2(int commentId, string text) {\n        Comment comment = _commentRepository.Find(commentId);\n        \n        var authResult = await _authorizationService.AuthorizeAsync(User, Comment, \"EditPolicy\");\n\n        if (authResult.Succeeded) {\n            comment.Text = text;\n            return View();\n        }\n        else {\n            return ForbidResult();\n        }\n    }\n\n    // GOOD: Only users with the `admin` role can access this method.\n    [Authorize(Roles=\"admin\")]\n    public async Task<IActionResult> Edit3(int commentId, string text) {\n        Comment comment = _commentRepository.Find(commentId);\n        \n        comment.Text = text;\n\n        return View();\n    }\n}\n```\n\n## References\n* OWASP: [Insecure Direct Object Refrences](https://wiki.owasp.org/index.php/Top_10_2013-A4-Insecure_Direct_Object_References).\n* OWASP: [Testing for Insecure Direct Object References](https://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/05-Authorization_Testing/04-Testing_for_Insecure_Direct_Object_References).\n* Microsoft Learn: [Resource-based authorization in ASP.NET Core](https://learn.microsoft.com/en-us/aspnet/core/security/authorization/resourcebased?view=aspnetcore-7.0).\n* Common Weakness Enumeration: [CWE-639](https://cwe.mitre.org/data/definitions/639.html).\n"
                },
                "properties": {
                  "tags": [
                    "security",
                    "external/cwe/cwe-639"
                  ],
                  "description": "Using user input to control which object is modified without\n              proper authorization checks allows an attacker to modify arbitrary objects.",
                  "id": "cs/web/insecure-direct-object-reference",
                  "kind": "problem",
                  "name": "Insecure Direct Object Reference",
                  "precision": "medium",
                  "problem.severity": "warning",
                  "security-severity": "7.5"
                }
              },
              {
                "id": "cs/deserialized-delegate",
                "name": "cs/deserialized-delegate",
                "shortDescription": {
                  "text": "Deserialized delegate"
                },
                "fullDescription": {
                  "text": "Deserializing a delegate allows for remote code execution when an attacker can control the serialized data."
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning"
                },
                "help": {
                  "text": "# Deserialized delegate\nDeserializing a delegate object may result in remote code execution, when an attacker can control the serialized data.\n\n\n## Recommendation\nAvoid deserializing delegate objects, if possible, or make sure that the serialized data cannot be controlled by an attacker.\n\n\n## Example\nIn this example, a file stream is deserialized to a `Func<int>` object, using a `BinaryFormatter`. The file stream is a parameter of a public method, so depending on the calls to `InvokeSerialized`, this may or may not pose a security problem.\n\n\n```csharp\nusing System;\nusing System.IO;\nusing System.Runtime.Serialization.Formatters.Binary;\n\nclass Bad\n{\n    public static int InvokeSerialized(FileStream fs)\n    {\n        var formatter = new BinaryFormatter();\n        // BAD\n        var f = (Func<int>)formatter.Deserialize(fs);\n        return f();\n    }\n}\n\n```\n\n## References\n* Microsoft: [BinaryFormatter Class](https://docs.microsoft.com/en-us/dotnet/api/system.runtime.serialization.formatters.binary.binaryformatter).\n* Common Weakness Enumeration: [CWE-502](https://cwe.mitre.org/data/definitions/502.html).\n",
                  "markdown": "# Deserialized delegate\nDeserializing a delegate object may result in remote code execution, when an attacker can control the serialized data.\n\n\n## Recommendation\nAvoid deserializing delegate objects, if possible, or make sure that the serialized data cannot be controlled by an attacker.\n\n\n## Example\nIn this example, a file stream is deserialized to a `Func<int>` object, using a `BinaryFormatter`. The file stream is a parameter of a public method, so depending on the calls to `InvokeSerialized`, this may or may not pose a security problem.\n\n\n```csharp\nusing System;\nusing System.IO;\nusing System.Runtime.Serialization.Formatters.Binary;\n\nclass Bad\n{\n    public static int InvokeSerialized(FileStream fs)\n    {\n        var formatter = new BinaryFormatter();\n        // BAD\n        var f = (Func<int>)formatter.Deserialize(fs);\n        return f();\n    }\n}\n\n```\n\n## References\n* Microsoft: [BinaryFormatter Class](https://docs.microsoft.com/en-us/dotnet/api/system.runtime.serialization.formatters.binary.binaryformatter).\n* Common Weakness Enumeration: [CWE-502](https://cwe.mitre.org/data/definitions/502.html).\n"
                },
                "properties": {
                  "tags": [
                    "security",
                    "external/cwe/cwe-502"
                  ],
                  "description": "Deserializing a delegate allows for remote code execution when an\n              attacker can control the serialized data.",
                  "id": "cs/deserialized-delegate",
                  "kind": "problem",
                  "name": "Deserialized delegate",
                  "precision": "high",
                  "problem.severity": "warning",
                  "security-severity": "9.8"
                }
              },
              {
                "id": "cs/unsafe-deserialization",
                "name": "cs/unsafe-deserialization",
                "shortDescription": {
                  "text": "Unsafe deserializer"
                },
                "fullDescription": {
                  "text": "Calling an unsafe deserializer with data controlled by an attacker can lead to denial of service and other security problems."
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning"
                },
                "help": {
                  "text": "# Unsafe deserializer\nDeserializing an object from untrusted input may result in security problems, such as denial of service or remote code execution.\n\n\n## Recommendation\nAvoid using an unsafe deserialization framework.\n\n\n## Example\nIn this example, a string is deserialized using a `JavaScriptSerializer` with a simple type resolver. Using a type resolver means that arbitrary code may be executed.\n\n\n```csharp\nusing System.Web.Script.Serialization;\n\nclass Bad\n{\n    public static object Deserialize(string s)\n    {\n        JavaScriptSerializer sr = new JavaScriptSerializer(new SimpleTypeResolver());\n        // BAD\n        return sr.DeserializeObject(s);\n    }\n}\n\n```\nTo fix this specific vulnerability, we avoid using a type resolver. In other cases, it may be necessary to use a different deserialization framework.\n\n\n```csharp\nusing System.Web.Script.Serialization;\n\nclass Good\n{\n    public static object Deserialize(string s)\n    {\n        // GOOD\n        JavaScriptSerializer sr = new JavaScriptSerializer();\n        return sr.DeserializeObject(s);\n    }\n}\n\n```\n\n## References\n* Mu&ntilde;oz, Alvaro and Mirosh, Oleksandr: [JSON Attacks](https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-Json-Attacks.pdf).\n* Common Weakness Enumeration: [CWE-502](https://cwe.mitre.org/data/definitions/502.html).\n",
                  "markdown": "# Unsafe deserializer\nDeserializing an object from untrusted input may result in security problems, such as denial of service or remote code execution.\n\n\n## Recommendation\nAvoid using an unsafe deserialization framework.\n\n\n## Example\nIn this example, a string is deserialized using a `JavaScriptSerializer` with a simple type resolver. Using a type resolver means that arbitrary code may be executed.\n\n\n```csharp\nusing System.Web.Script.Serialization;\n\nclass Bad\n{\n    public static object Deserialize(string s)\n    {\n        JavaScriptSerializer sr = new JavaScriptSerializer(new SimpleTypeResolver());\n        // BAD\n        return sr.DeserializeObject(s);\n    }\n}\n\n```\nTo fix this specific vulnerability, we avoid using a type resolver. In other cases, it may be necessary to use a different deserialization framework.\n\n\n```csharp\nusing System.Web.Script.Serialization;\n\nclass Good\n{\n    public static object Deserialize(string s)\n    {\n        // GOOD\n        JavaScriptSerializer sr = new JavaScriptSerializer();\n        return sr.DeserializeObject(s);\n    }\n}\n\n```\n\n## References\n* Mu&ntilde;oz, Alvaro and Mirosh, Oleksandr: [JSON Attacks](https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-Json-Attacks.pdf).\n* Common Weakness Enumeration: [CWE-502](https://cwe.mitre.org/data/definitions/502.html).\n"
                },
                "properties": {
                  "tags": [
                    "security",
                    "external/cwe/cwe-502"
                  ],
                  "description": "Calling an unsafe deserializer with data controlled by an attacker\n              can lead to denial of service and other security problems.",
                  "id": "cs/unsafe-deserialization",
                  "kind": "problem",
                  "name": "Unsafe deserializer",
                  "precision": "low",
                  "problem.severity": "warning",
                  "security-severity": "9.8"
                }
              },
              {
                "id": "cs/unsafe-deserialization-untrusted-input",
                "name": "cs/unsafe-deserialization-untrusted-input",
                "shortDescription": {
                  "text": "Deserialization of untrusted data"
                },
                "fullDescription": {
                  "text": "Calling an unsafe deserializer with data controlled by an attacker can lead to denial of service and other security problems."
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "error"
                },
                "help": {
                  "text": "# Deserialization of untrusted data\nDeserializing an object from untrusted input may result in security problems, such as denial of service or remote code execution.\n\n\n## Recommendation\nAvoid deserializing objects from an untrusted source, and if not possible, make sure to use a safe deserialization framework.\n\n\n## Example\nIn this example, text from an HTML text box is deserialized using a `JavaScriptSerializer` with a simple type resolver. Using a type resolver means that arbitrary code may be executed.\n\n\n```csharp\nusing System.Web.UI.WebControls;\nusing System.Web.Script.Serialization;\n\nclass Bad\n{\n    public static object Deserialize(TextBox textBox)\n    {\n        JavaScriptSerializer sr = new JavaScriptSerializer(new SimpleTypeResolver());\n        // BAD\n        return sr.DeserializeObject(textBox.Text);\n    }\n}\n\n```\nTo fix this specific vulnerability, we avoid using a type resolver. In other cases, it may be necessary to use a different deserialization framework.\n\n\n```csharp\nusing System.Web.UI.WebControls;\nusing System.Web.Script.Serialization;\n\nclass Good\n{\n    public static object Deserialize(TextBox textBox)\n    {\n        JavaScriptSerializer sr = new JavaScriptSerializer();\n        // GOOD: no unsafe type resolver\n        return sr.DeserializeObject(textBox.Text);\n    }\n}\n\n```\nIn the following example potentially untrusted stream and type is deserialized using a `DataContractJsonSerializer` which is known to be vulnerable with user supplied types.\n\n\n```csharp\nusing System.Runtime.Serialization.Json;\nusing System.IO;\nusing System;\n\nclass BadDataContractJsonSerializer\n{\n    public static object Deserialize(string type, Stream s)\n    {\n        // BAD: stream and type are potentially untrusted\n        var ds = new DataContractJsonSerializer(Type.GetType(type));\n        return ds.ReadObject(s);\n    }\n}\n\n```\nTo fix this specific vulnerability, we are using hardcoded Plain Old CLR Object ([POCO](https://en.wikipedia.org/wiki/Plain_old_CLR_object)) type. In other cases, it may be necessary to use a different deserialization framework.\n\n\n```csharp\nusing System.Runtime.Serialization.Json;\nusing System.IO;\nusing System;\n\nclass Poco\n{\n    public int Count;\n\n    public string Comment;\n}\n\nclass GoodDataContractJsonSerializer\n{\n    public static Poco Deserialize(Stream s)\n    {\n        // GOOD: while stream is potentially untrusted, the instantiated type is hardcoded\n        var ds = new DataContractJsonSerializer(typeof(Poco));\n        return (Poco)ds.ReadObject(s);\n    }\n}\n\n```\n\n## References\n* Mu&ntilde;oz, Alvaro and Mirosh, Oleksandr: [JSON Attacks](https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-Json-Attacks.pdf).\n* Common Weakness Enumeration: [CWE-502](https://cwe.mitre.org/data/definitions/502.html).\n",
                  "markdown": "# Deserialization of untrusted data\nDeserializing an object from untrusted input may result in security problems, such as denial of service or remote code execution.\n\n\n## Recommendation\nAvoid deserializing objects from an untrusted source, and if not possible, make sure to use a safe deserialization framework.\n\n\n## Example\nIn this example, text from an HTML text box is deserialized using a `JavaScriptSerializer` with a simple type resolver. Using a type resolver means that arbitrary code may be executed.\n\n\n```csharp\nusing System.Web.UI.WebControls;\nusing System.Web.Script.Serialization;\n\nclass Bad\n{\n    public static object Deserialize(TextBox textBox)\n    {\n        JavaScriptSerializer sr = new JavaScriptSerializer(new SimpleTypeResolver());\n        // BAD\n        return sr.DeserializeObject(textBox.Text);\n    }\n}\n\n```\nTo fix this specific vulnerability, we avoid using a type resolver. In other cases, it may be necessary to use a different deserialization framework.\n\n\n```csharp\nusing System.Web.UI.WebControls;\nusing System.Web.Script.Serialization;\n\nclass Good\n{\n    public static object Deserialize(TextBox textBox)\n    {\n        JavaScriptSerializer sr = new JavaScriptSerializer();\n        // GOOD: no unsafe type resolver\n        return sr.DeserializeObject(textBox.Text);\n    }\n}\n\n```\nIn the following example potentially untrusted stream and type is deserialized using a `DataContractJsonSerializer` which is known to be vulnerable with user supplied types.\n\n\n```csharp\nusing System.Runtime.Serialization.Json;\nusing System.IO;\nusing System;\n\nclass BadDataContractJsonSerializer\n{\n    public static object Deserialize(string type, Stream s)\n    {\n        // BAD: stream and type are potentially untrusted\n        var ds = new DataContractJsonSerializer(Type.GetType(type));\n        return ds.ReadObject(s);\n    }\n}\n\n```\nTo fix this specific vulnerability, we are using hardcoded Plain Old CLR Object ([POCO](https://en.wikipedia.org/wiki/Plain_old_CLR_object)) type. In other cases, it may be necessary to use a different deserialization framework.\n\n\n```csharp\nusing System.Runtime.Serialization.Json;\nusing System.IO;\nusing System;\n\nclass Poco\n{\n    public int Count;\n\n    public string Comment;\n}\n\nclass GoodDataContractJsonSerializer\n{\n    public static Poco Deserialize(Stream s)\n    {\n        // GOOD: while stream is potentially untrusted, the instantiated type is hardcoded\n        var ds = new DataContractJsonSerializer(typeof(Poco));\n        return (Poco)ds.ReadObject(s);\n    }\n}\n\n```\n\n## References\n* Mu&ntilde;oz, Alvaro and Mirosh, Oleksandr: [JSON Attacks](https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-Json-Attacks.pdf).\n* Common Weakness Enumeration: [CWE-502](https://cwe.mitre.org/data/definitions/502.html).\n"
                },
                "properties": {
                  "tags": [
                    "security",
                    "external/cwe/cwe-502"
                  ],
                  "description": "Calling an unsafe deserializer with data controlled by an attacker\n              can lead to denial of service and other security problems.",
                  "id": "cs/unsafe-deserialization-untrusted-input",
                  "kind": "path-problem",
                  "name": "Deserialization of untrusted data",
                  "precision": "high",
                  "problem.severity": "error",
                  "security-severity": "9.8"
                }
              },
              {
                "id": "cs/web/missing-x-frame-options",
                "name": "cs/web/missing-x-frame-options",
                "shortDescription": {
                  "text": "Missing X-Frame-Options HTTP header"
                },
                "fullDescription": {
                  "text": "If the 'X-Frame-Options' setting is not provided, a malicious user may be able to overlay their own UI on top of the site by using an iframe."
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "error"
                },
                "help": {
                  "text": "# Missing X-Frame-Options HTTP header\nWeb sites that do not specify the `X-Frame-Options` HTTP header may be vulnerable to UI redress attacks (\"clickjacking\"). In these attacks, the vulnerable site is loaded in a frame on an attacker-controlled site which uses opaque or transparent layers to trick the user into unintentionally clicking a button or link on the vulnerable site.\n\n\n## Recommendation\nSet the `X-Frame-Options` HTTP header to `DENY`, to instruct web browsers to block attempts to load the site in a frame. Alternatively, if framing is needed in certain circumstances, specify `SAMEORIGIN` or `ALLOW FROM: ...` to limit the ability to frame the site to pages from the same origin, or from an allowed whitelist of trusted domains.\n\nFor ASP.NET web applications, the header may be specified either in the `Web.config` file, using the `<customHeaders>` tag, or within the source code of the application using the `HttpResponse.AddHeader` method. In general, prefer specifying the header in the `Web.config` file to ensure it is added to all requests. If adding it to the source code, ensure that it is added unconditionally to all requests. For example, add the header in the `Application_BeginRequest` method in the `global.asax` file.\n\n\n## Example\nThe following example shows how to specify the `X-Frame-Options` header within the `Web.config` file for ASP.NET:\n\n\n```none\n<?xml version=\"1.0\" encoding=\"utf-8\" ?>\n<configuration>\n  <system.web>\n  </system.web>\n  <system.webServer>\n    <httpProtocol>\n      <customHeaders>\n        <add name=\"X-Frame-Options\" value=\"SAMEORIGIN\" />\n      </customHeaders>\n    </httpProtocol>\n  </system.webServer>\n</configuration>\n\n```\nThis next example shows how to specify the `X-Frame-Options` header within the `global.asax` file for ASP.NET application:\n\n\n```csharp\nprotected void Application_BeginRequest(object sender, EventArgs e)\n{\n    HttpContext.Current.Response.AddHeader(\"X-Frame-Options\", \"DENY\");\n}\n\n```\n\n## References\n* OWASP: [Clickjacking Defense Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Clickjacking_Defense_Cheat_Sheet.html).\n* Mozilla: [X-Frame-Options](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Frame-Options)\n* Common Weakness Enumeration: [CWE-451](https://cwe.mitre.org/data/definitions/451.html).\n* Common Weakness Enumeration: [CWE-829](https://cwe.mitre.org/data/definitions/829.html).\n",
                  "markdown": "# Missing X-Frame-Options HTTP header\nWeb sites that do not specify the `X-Frame-Options` HTTP header may be vulnerable to UI redress attacks (\"clickjacking\"). In these attacks, the vulnerable site is loaded in a frame on an attacker-controlled site which uses opaque or transparent layers to trick the user into unintentionally clicking a button or link on the vulnerable site.\n\n\n## Recommendation\nSet the `X-Frame-Options` HTTP header to `DENY`, to instruct web browsers to block attempts to load the site in a frame. Alternatively, if framing is needed in certain circumstances, specify `SAMEORIGIN` or `ALLOW FROM: ...` to limit the ability to frame the site to pages from the same origin, or from an allowed whitelist of trusted domains.\n\nFor ASP.NET web applications, the header may be specified either in the `Web.config` file, using the `<customHeaders>` tag, or within the source code of the application using the `HttpResponse.AddHeader` method. In general, prefer specifying the header in the `Web.config` file to ensure it is added to all requests. If adding it to the source code, ensure that it is added unconditionally to all requests. For example, add the header in the `Application_BeginRequest` method in the `global.asax` file.\n\n\n## Example\nThe following example shows how to specify the `X-Frame-Options` header within the `Web.config` file for ASP.NET:\n\n\n```none\n<?xml version=\"1.0\" encoding=\"utf-8\" ?>\n<configuration>\n  <system.web>\n  </system.web>\n  <system.webServer>\n    <httpProtocol>\n      <customHeaders>\n        <add name=\"X-Frame-Options\" value=\"SAMEORIGIN\" />\n      </customHeaders>\n    </httpProtocol>\n  </system.webServer>\n</configuration>\n\n```\nThis next example shows how to specify the `X-Frame-Options` header within the `global.asax` file for ASP.NET application:\n\n\n```csharp\nprotected void Application_BeginRequest(object sender, EventArgs e)\n{\n    HttpContext.Current.Response.AddHeader(\"X-Frame-Options\", \"DENY\");\n}\n\n```\n\n## References\n* OWASP: [Clickjacking Defense Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Clickjacking_Defense_Cheat_Sheet.html).\n* Mozilla: [X-Frame-Options](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Frame-Options)\n* Common Weakness Enumeration: [CWE-451](https://cwe.mitre.org/data/definitions/451.html).\n* Common Weakness Enumeration: [CWE-829](https://cwe.mitre.org/data/definitions/829.html).\n"
                },
                "properties": {
                  "tags": [
                    "security",
                    "external/cwe/cwe-451",
                    "external/cwe/cwe-829"
                  ],
                  "description": "If the 'X-Frame-Options' setting is not provided, a malicious user may be able to\n              overlay their own UI on top of the site by using an iframe.",
                  "id": "cs/web/missing-x-frame-options",
                  "kind": "problem",
                  "name": "Missing X-Frame-Options HTTP header",
                  "precision": "high",
                  "problem.severity": "error",
                  "security-severity": "7.5"
                }
              },
              {
                "id": "cs/web/requiressl-not-set",
                "name": "cs/web/requiressl-not-set",
                "shortDescription": {
                  "text": "'requireSSL' attribute is not set to true"
                },
                "fullDescription": {
                  "text": "Omitting the 'requireSSL' attribute allows data to be transmitted insecurely using HTTP. Always set 'requireSSL' to 'true' to ensure that HTTPS is used at all times."
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "error"
                },
                "help": {
                  "text": "# 'requireSSL' attribute is not set to true\nSensitive data that is transmitted using HTTP is vulnerable to being read by a third party. By default, web forms and cookies are sent via HTTP, not HTTPS. This setting can be changed by setting the `requireSSL` attribute to `\"true\"` in `Web.config`.\n\n\n## Recommendation\nWhen using web forms, ensure that `Web.config` contains a `<forms>` element with the attribute `requireSSL=\"true\"`.\n\nWhen using cookies, ensure that SSL is used, either via the `<forms>` attribute above, or the `<httpCookies>` element, with the attribute `requireSSL=\"true\"`. It is also possible to require cookies to use SSL programmatically, by setting the property `System.Web.HttpCookie.Secure` to `true`.\n\n\n## Example\nThe following example shows where to specify `requireSSL=\"true\"` in a `Web.config` file.\n\n\n```none\n<?xml version=\"1.0\" encoding=\"utf-8\" ?>\n<configuration>\n  <system.web>\n    <authentication>\n      <forms\n        requireSSL=\"true\"\n        ... />\n    </authentication>\n    <httpCookies\n        requireSSL=\"true\"\n        ... />\n  </system.web>\n</configuration>\n\n```\n\n## References\n* MSDN: [HttpCookie.Secure Property](https://msdn.microsoft.com/en-us/library/system.web.httpcookie.secure(v=vs.110).aspx), [FormsAuthentication.RequireSSL Property](https://msdn.microsoft.com/en-us/library/system.web.security.formsauthentication.requiressl(v=vs.110).aspx), [forms Element for authentication](https://msdn.microsoft.com/en-us/library/1d3t3c61(v=vs.100).aspx), [httpCookies Element](https://msdn.microsoft.com/library/ms228262%28v=vs.100%29.aspx).\n* Common Weakness Enumeration: [CWE-319](https://cwe.mitre.org/data/definitions/319.html).\n* Common Weakness Enumeration: [CWE-614](https://cwe.mitre.org/data/definitions/614.html).\n",
                  "markdown": "# 'requireSSL' attribute is not set to true\nSensitive data that is transmitted using HTTP is vulnerable to being read by a third party. By default, web forms and cookies are sent via HTTP, not HTTPS. This setting can be changed by setting the `requireSSL` attribute to `\"true\"` in `Web.config`.\n\n\n## Recommendation\nWhen using web forms, ensure that `Web.config` contains a `<forms>` element with the attribute `requireSSL=\"true\"`.\n\nWhen using cookies, ensure that SSL is used, either via the `<forms>` attribute above, or the `<httpCookies>` element, with the attribute `requireSSL=\"true\"`. It is also possible to require cookies to use SSL programmatically, by setting the property `System.Web.HttpCookie.Secure` to `true`.\n\n\n## Example\nThe following example shows where to specify `requireSSL=\"true\"` in a `Web.config` file.\n\n\n```none\n<?xml version=\"1.0\" encoding=\"utf-8\" ?>\n<configuration>\n  <system.web>\n    <authentication>\n      <forms\n        requireSSL=\"true\"\n        ... />\n    </authentication>\n    <httpCookies\n        requireSSL=\"true\"\n        ... />\n  </system.web>\n</configuration>\n\n```\n\n## References\n* MSDN: [HttpCookie.Secure Property](https://msdn.microsoft.com/en-us/library/system.web.httpcookie.secure(v=vs.110).aspx), [FormsAuthentication.RequireSSL Property](https://msdn.microsoft.com/en-us/library/system.web.security.formsauthentication.requiressl(v=vs.110).aspx), [forms Element for authentication](https://msdn.microsoft.com/en-us/library/1d3t3c61(v=vs.100).aspx), [httpCookies Element](https://msdn.microsoft.com/library/ms228262%28v=vs.100%29.aspx).\n* Common Weakness Enumeration: [CWE-319](https://cwe.mitre.org/data/definitions/319.html).\n* Common Weakness Enumeration: [CWE-614](https://cwe.mitre.org/data/definitions/614.html).\n"
                },
                "properties": {
                  "tags": [
                    "security",
                    "external/cwe/cwe-319",
                    "external/cwe/cwe-614"
                  ],
                  "description": "Omitting the 'requireSSL' attribute allows data to be transmitted insecurely\n              using HTTP. Always set 'requireSSL' to 'true' to ensure that HTTPS\n              is used at all times.",
                  "id": "cs/web/requiressl-not-set",
                  "kind": "problem",
                  "name": "'requireSSL' attribute is not set to true",
                  "precision": "high",
                  "problem.severity": "error",
                  "security-severity": "7.5"
                }
              },
              {
                "id": "cs/assembly-path-injection",
                "name": "cs/assembly-path-injection",
                "shortDescription": {
                  "text": "Assembly path injection"
                },
                "fullDescription": {
                  "text": "Loading a .NET assembly based on a path constructed from user-controlled sources may allow a malicious user to load code which modifies the program in unintended ways."
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "error"
                },
                "help": {
                  "text": "# Assembly path injection\nC\\# supports runtime loading of assemblies by path through the use of the `System.Reflection.Assembly` API. If an external user can influence the path used to load an assembly, then the application can potentially be tricked into loading an assembly which was not intended to be loaded, and executing arbitrary code.\n\n\n## Recommendation\nAvoid loading assemblies based on user provided input. If this is not possible, ensure that the path is validated before being used with `Assembly`. For example, compare the provided input against a whitelist of known safe assemblies, or confirm that the path is restricted to a single directory which only contains safe assemblies.\n\n\n## Example\nIn this example, user input is provided describing the path to an assembly, which is loaded without validation. This is problematic because it allows the user to load any assembly installed on the system, and is particularly problematic if an attacker can upload a custom DLL elsewhere on the system.\n\n\n```csharp\nusing System;\nusing System.Web;\nusing System.Reflection;\n\npublic class AssemblyPathInjectionHandler : IHttpHandler {\n  public void ProcessRequest(HttpContext ctx) {\n    string assemblyPath = ctx.Request.QueryString[\"assemblyPath\"];\n\n    // BAD: Load assembly based on user input\n    var badAssembly = Assembly.LoadFile(assemblyPath);\n\n    // Method called on loaded assembly. If the user can control the loaded assembly, then this\n    // could result in a remote code execution vulnerability\n    MethodInfo m = badAssembly.GetType(\"Config\").GetMethod(\"GetCustomPath\");\n    Object customPath = m.Invoke(null, null);\n    // ...\n  }\n}\n```\nIn the corrected version, user input is validated against one of two options, and the assembly is only loaded if the user input matches one of those options.\n\n\n```csharp\nusing System;\nusing System.Web;\nusing System.Reflection;\n\npublic class AssemblyPathInjectionHandler : IHttpHandler {\n  public void ProcessRequest(HttpContext ctx) {\n    string configType = ctx.Request.QueryString[\"configType\"];\n\n    if (configType.equals(\"configType1\") || configType.equals(\"configType2\")) {\n      // GOOD: Loaded assembly is one of the two known safe options\n      var safeAssembly = Assembly.LoadFile(@\"C:\\SafeLibraries\\\" + configType + \".dll\");\n\n      // Code execution is limited to one of two known and vetted assemblies\n      MethodInfo m = safeAssembly.GetType(\"Config\").GetMethod(\"GetCustomPath\");\n      Object customPath = m.Invoke(null, null);\n      // ...\n    }\n  }\n}\n```\n\n## References\n* Microsoft: [System.Reflection.Assembly](https://docs.microsoft.com/en-us/dotnet/api/system.reflection.assembly?view=netframework-4.8).\n* Common Weakness Enumeration: [CWE-114](https://cwe.mitre.org/data/definitions/114.html).\n",
                  "markdown": "# Assembly path injection\nC\\# supports runtime loading of assemblies by path through the use of the `System.Reflection.Assembly` API. If an external user can influence the path used to load an assembly, then the application can potentially be tricked into loading an assembly which was not intended to be loaded, and executing arbitrary code.\n\n\n## Recommendation\nAvoid loading assemblies based on user provided input. If this is not possible, ensure that the path is validated before being used with `Assembly`. For example, compare the provided input against a whitelist of known safe assemblies, or confirm that the path is restricted to a single directory which only contains safe assemblies.\n\n\n## Example\nIn this example, user input is provided describing the path to an assembly, which is loaded without validation. This is problematic because it allows the user to load any assembly installed on the system, and is particularly problematic if an attacker can upload a custom DLL elsewhere on the system.\n\n\n```csharp\nusing System;\nusing System.Web;\nusing System.Reflection;\n\npublic class AssemblyPathInjectionHandler : IHttpHandler {\n  public void ProcessRequest(HttpContext ctx) {\n    string assemblyPath = ctx.Request.QueryString[\"assemblyPath\"];\n\n    // BAD: Load assembly based on user input\n    var badAssembly = Assembly.LoadFile(assemblyPath);\n\n    // Method called on loaded assembly. If the user can control the loaded assembly, then this\n    // could result in a remote code execution vulnerability\n    MethodInfo m = badAssembly.GetType(\"Config\").GetMethod(\"GetCustomPath\");\n    Object customPath = m.Invoke(null, null);\n    // ...\n  }\n}\n```\nIn the corrected version, user input is validated against one of two options, and the assembly is only loaded if the user input matches one of those options.\n\n\n```csharp\nusing System;\nusing System.Web;\nusing System.Reflection;\n\npublic class AssemblyPathInjectionHandler : IHttpHandler {\n  public void ProcessRequest(HttpContext ctx) {\n    string configType = ctx.Request.QueryString[\"configType\"];\n\n    if (configType.equals(\"configType1\") || configType.equals(\"configType2\")) {\n      // GOOD: Loaded assembly is one of the two known safe options\n      var safeAssembly = Assembly.LoadFile(@\"C:\\SafeLibraries\\\" + configType + \".dll\");\n\n      // Code execution is limited to one of two known and vetted assemblies\n      MethodInfo m = safeAssembly.GetType(\"Config\").GetMethod(\"GetCustomPath\");\n      Object customPath = m.Invoke(null, null);\n      // ...\n    }\n  }\n}\n```\n\n## References\n* Microsoft: [System.Reflection.Assembly](https://docs.microsoft.com/en-us/dotnet/api/system.reflection.assembly?view=netframework-4.8).\n* Common Weakness Enumeration: [CWE-114](https://cwe.mitre.org/data/definitions/114.html).\n"
                },
                "properties": {
                  "tags": [
                    "security",
                    "external/cwe/cwe-114"
                  ],
                  "description": "Loading a .NET assembly based on a path constructed from user-controlled sources\n              may allow a malicious user to load code which modifies the program in unintended\n              ways.",
                  "id": "cs/assembly-path-injection",
                  "kind": "path-problem",
                  "name": "Assembly path injection",
                  "precision": "high",
                  "problem.severity": "error",
                  "security-severity": "8.2"
                }
              },
              {
                "id": "cs/command-line-injection",
                "name": "cs/command-line-injection",
                "shortDescription": {
                  "text": "Uncontrolled command line"
                },
                "fullDescription": {
                  "text": "Using externally controlled strings in a command line may allow a malicious user to change the meaning of the command."
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "error"
                },
                "help": {
                  "text": "# Uncontrolled command line\nCode that passes user input directly to `System.Diagnostic.Process.Start`, or some other library routine that executes a command, allows the user to execute malicious code.\n\n\n## Recommendation\nIf possible, use hard-coded string literals to specify the command to run or library to load. Instead of passing the user input directly to the process or library function, examine the user input and then choose among hard-coded string literals.\n\nIf the applicable libraries or commands cannot be determined at compile time, then add code to verify that the user input string is safe before using it.\n\n\n## Example\nThe following example shows code that takes a shell script that can be changed maliciously by a user, and passes it straight to `System.Diagnostic.Process.Start` without examining it first.\n\n\n```csharp\nusing System;\nusing System.Web;\nusing System.Diagnostics;\n\npublic class CommandInjectionHandler : IHttpHandler\n{\n    public void ProcessRequest(HttpContext ctx)\n    {\n        string param = ctx.Request.QueryString[\"param\"];\n        Process.Start(\"process.exe\", \"/c \" + param);\n    }\n}\n\n```\n\n## References\n* OWASP: [Command Injection](https://www.owasp.org/index.php/Command_Injection).\n* Common Weakness Enumeration: [CWE-78](https://cwe.mitre.org/data/definitions/78.html).\n* Common Weakness Enumeration: [CWE-88](https://cwe.mitre.org/data/definitions/88.html).\n",
                  "markdown": "# Uncontrolled command line\nCode that passes user input directly to `System.Diagnostic.Process.Start`, or some other library routine that executes a command, allows the user to execute malicious code.\n\n\n## Recommendation\nIf possible, use hard-coded string literals to specify the command to run or library to load. Instead of passing the user input directly to the process or library function, examine the user input and then choose among hard-coded string literals.\n\nIf the applicable libraries or commands cannot be determined at compile time, then add code to verify that the user input string is safe before using it.\n\n\n## Example\nThe following example shows code that takes a shell script that can be changed maliciously by a user, and passes it straight to `System.Diagnostic.Process.Start` without examining it first.\n\n\n```csharp\nusing System;\nusing System.Web;\nusing System.Diagnostics;\n\npublic class CommandInjectionHandler : IHttpHandler\n{\n    public void ProcessRequest(HttpContext ctx)\n    {\n        string param = ctx.Request.QueryString[\"param\"];\n        Process.Start(\"process.exe\", \"/c \" + param);\n    }\n}\n\n```\n\n## References\n* OWASP: [Command Injection](https://www.owasp.org/index.php/Command_Injection).\n* Common Weakness Enumeration: [CWE-78](https://cwe.mitre.org/data/definitions/78.html).\n* Common Weakness Enumeration: [CWE-88](https://cwe.mitre.org/data/definitions/88.html).\n"
                },
                "properties": {
                  "tags": [
                    "correctness",
                    "security",
                    "external/cwe/cwe-078",
                    "external/cwe/cwe-088"
                  ],
                  "description": "Using externally controlled strings in a command line may allow a malicious\n              user to change the meaning of the command.",
                  "id": "cs/command-line-injection",
                  "kind": "path-problem",
                  "name": "Uncontrolled command line",
                  "precision": "high",
                  "problem.severity": "error",
                  "security-severity": "9.8"
                }
              },
              {
                "id": "cs/sensitive-data-transmission",
                "name": "cs/sensitive-data-transmission",
                "shortDescription": {
                  "text": "Information exposure through transmitted data"
                },
                "fullDescription": {
                  "text": "Transmitting sensitive information to the user is a potential security risk."
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "error"
                },
                "help": {
                  "text": "# Information exposure through transmitted data\nTransmitting sensitive data to the user is a potential security risk. Always ensure that transmitted data is intended for the user. For example, passwords and the contents of database exceptions are generally not appropriate to send to the user, as they reveal information that could be abused or exploited.\n\n\n## Recommendation\nAvoid transmitting passwords or exceptions to the user. Instead, create a more user-friendly message that does not contain potentially sensitive information. Technical errors should be written to a log file.\n\n\n## Example\nThe following example shows the user password being sent back to the user.\n\n\n```csharp\npublic class Handler : IHttpHandler\n{\n\n    public void ProcessRequest(HttpContext ctx)\n    {\n        try\n        {\n       ...\n    }\n        catch (AuthenticationFailure ex)\n        {\n            ctx.Response.Write(\"Invalid password: \" + password);\n        }\n    }\n}\n\n```\nThe following example shows a database exception being sent to the user. Exceptions can often contain unnecessary technical or sensitive information that should not be seen by the user.\n\n\n```csharp\npublic class Handler : IHttpHandler\n{\n\n    public void ProcessRequest(HttpContext ctx)\n    {\n        try\n        {\n       ...\n    }\n        catch (DbException ex)\n        {\n            ctx.Response.Write(\"Database error: \" + ex.Message);\n        }\n    }\n}\n\n```\n\n## References\n* OWASP: [Sensitive Data Exposure](https://www.owasp.org/index.php/Top_10_2013-A6-Sensitive_Data_Exposure).\n* Common Weakness Enumeration: [CWE-201](https://cwe.mitre.org/data/definitions/201.html).\n",
                  "markdown": "# Information exposure through transmitted data\nTransmitting sensitive data to the user is a potential security risk. Always ensure that transmitted data is intended for the user. For example, passwords and the contents of database exceptions are generally not appropriate to send to the user, as they reveal information that could be abused or exploited.\n\n\n## Recommendation\nAvoid transmitting passwords or exceptions to the user. Instead, create a more user-friendly message that does not contain potentially sensitive information. Technical errors should be written to a log file.\n\n\n## Example\nThe following example shows the user password being sent back to the user.\n\n\n```csharp\npublic class Handler : IHttpHandler\n{\n\n    public void ProcessRequest(HttpContext ctx)\n    {\n        try\n        {\n       ...\n    }\n        catch (AuthenticationFailure ex)\n        {\n            ctx.Response.Write(\"Invalid password: \" + password);\n        }\n    }\n}\n\n```\nThe following example shows a database exception being sent to the user. Exceptions can often contain unnecessary technical or sensitive information that should not be seen by the user.\n\n\n```csharp\npublic class Handler : IHttpHandler\n{\n\n    public void ProcessRequest(HttpContext ctx)\n    {\n        try\n        {\n       ...\n    }\n        catch (DbException ex)\n        {\n            ctx.Response.Write(\"Database error: \" + ex.Message);\n        }\n    }\n}\n\n```\n\n## References\n* OWASP: [Sensitive Data Exposure](https://www.owasp.org/index.php/Top_10_2013-A6-Sensitive_Data_Exposure).\n* Common Weakness Enumeration: [CWE-201](https://cwe.mitre.org/data/definitions/201.html).\n"
                },
                "properties": {
                  "tags": [
                    "security",
                    "external/cwe/cwe-201"
                  ],
                  "description": "Transmitting sensitive information to the user is a potential security risk.",
                  "id": "cs/sensitive-data-transmission",
                  "kind": "path-problem",
                  "name": "Information exposure through transmitted data",
                  "precision": "high",
                  "problem.severity": "error",
                  "security-severity": "4.3"
                }
              },
              {
                "id": "cs/serialization-check-bypass",
                "name": "cs/serialization-check-bypass",
                "shortDescription": {
                  "text": "Serialization check bypass"
                },
                "fullDescription": {
                  "text": "A write that looks like it may be bypassing runtime checks."
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning"
                },
                "help": {
                  "text": "# Serialization check bypass\nFields that are deserialized should be validated, otherwise the deserialized object could contain invalid data.\n\nThis query finds cases where a field is validated in a constructor, but not in a deserialization method. This is an indication that the deserialization method is missing a validation step.\n\n\n## Recommendation\nIf a field needs to be validated, then ensure that validation is also performed during deserialization.\n\n\n## Example\nThe following example has the validation of the `Age` field in the constructor but not in the deserialization method:\n\n\n```csharp\nusing System;\nusing System.Runtime.Serialization;\n\n[Serializable]\npublic class PersonBad : ISerializable\n{\n    public int Age;\n\n    public PersonBad(int age)\n    {\n        if (age < 0)\n            throw new ArgumentException(nameof(age));\n        Age = age;\n    }\n\n    [OnDeserializing]\n    void ISerializable.GetObjectData(SerializationInfo info, StreamingContext context)\n    {\n        Age = info.GetInt32(\"age\");  // BAD - write is unsafe\n    }\n}\n\n```\nThe problem is fixed by adding validation to the deserialization method as follows:\n\n\n```csharp\nusing System;\nusing System.Runtime.Serialization;\n\n[Serializable]\npublic class PersonGood : ISerializable\n{\n    public int Age;\n\n    public PersonGood(int age)\n    {\n        if (age < 0)\n            throw new ArgumentException(nameof(age));\n        Age = age;\n    }\n\n    [OnDeserializing]\n    void ISerializable.GetObjectData(SerializationInfo info, StreamingContext context)\n    {\n        int age = info.GetInt32(\"age\");\n        if (age < 0)\n            throw new SerializationException(nameof(Age));\n        Age = age;  // GOOD - write is safe\n    }\n}\n\n```\n\n## References\n* OWASP: [Data Validation](https://www.owasp.org/index.php/Data_Validation).\n* Common Weakness Enumeration: [CWE-20](https://cwe.mitre.org/data/definitions/20.html).\n",
                  "markdown": "# Serialization check bypass\nFields that are deserialized should be validated, otherwise the deserialized object could contain invalid data.\n\nThis query finds cases where a field is validated in a constructor, but not in a deserialization method. This is an indication that the deserialization method is missing a validation step.\n\n\n## Recommendation\nIf a field needs to be validated, then ensure that validation is also performed during deserialization.\n\n\n## Example\nThe following example has the validation of the `Age` field in the constructor but not in the deserialization method:\n\n\n```csharp\nusing System;\nusing System.Runtime.Serialization;\n\n[Serializable]\npublic class PersonBad : ISerializable\n{\n    public int Age;\n\n    public PersonBad(int age)\n    {\n        if (age < 0)\n            throw new ArgumentException(nameof(age));\n        Age = age;\n    }\n\n    [OnDeserializing]\n    void ISerializable.GetObjectData(SerializationInfo info, StreamingContext context)\n    {\n        Age = info.GetInt32(\"age\");  // BAD - write is unsafe\n    }\n}\n\n```\nThe problem is fixed by adding validation to the deserialization method as follows:\n\n\n```csharp\nusing System;\nusing System.Runtime.Serialization;\n\n[Serializable]\npublic class PersonGood : ISerializable\n{\n    public int Age;\n\n    public PersonGood(int age)\n    {\n        if (age < 0)\n            throw new ArgumentException(nameof(age));\n        Age = age;\n    }\n\n    [OnDeserializing]\n    void ISerializable.GetObjectData(SerializationInfo info, StreamingContext context)\n    {\n        int age = info.GetInt32(\"age\");\n        if (age < 0)\n            throw new SerializationException(nameof(Age));\n        Age = age;  // GOOD - write is safe\n    }\n}\n\n```\n\n## References\n* OWASP: [Data Validation](https://www.owasp.org/index.php/Data_Validation).\n* Common Weakness Enumeration: [CWE-20](https://cwe.mitre.org/data/definitions/20.html).\n"
                },
                "properties": {
                  "tags": [
                    "security",
                    "external/cwe/cwe-20"
                  ],
                  "description": "A write that looks like it may be bypassing runtime checks.",
                  "id": "cs/serialization-check-bypass",
                  "kind": "problem",
                  "name": "Serialization check bypass",
                  "precision": "medium",
                  "problem.severity": "warning",
                  "security-severity": "7.8"
                }
              },
              {
                "id": "cs/weak-encryption",
                "name": "cs/weak-encryption",
                "shortDescription": {
                  "text": "Weak encryption"
                },
                "fullDescription": {
                  "text": "Finds uses of encryption algorithms that are weak and obsolete"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning"
                },
                "help": {
                  "text": "# Weak encryption\nWeak encryption algorithms provide very little security. For example DES encryption uses keys of 56 bits only, and no longer provides sufficient protection for sensitive data. TripleDES should also be deprecated for very sensitive data: Although it improves on DES by using 168-bit long keys, it provides in fact at most 112 bits of security.\n\n\n## Recommendation\nYou should switch to a more secure encryption algorithm, such as AES (Advanced Encryption Standard) and use a key length which is reasonable for the application for which it is being used. Do not use the ECB encryption mode since it is vulnerable to replay and other attacks.\n\n\n## Example\nThis example uses DES, which is limited to a 56-bit key. The key provided is actually 64 bits but the last bit of each byte is turned into a parity bit. For example the bytes 01010101 and 01010100 can be used in place of each other when encrypting and decrypting.\n\n\n```csharp\nclass WeakEncryption\n{\n    public static byte[] encryptString()\n    {\n        SymmetricAlgorithm serviceProvider = new DESCryptoServiceProvider();\n        byte[] key = { 16, 22, 240, 11, 18, 150, 192, 21 };\n        serviceProvider.Key = key;\n        ICryptoTransform encryptor = serviceProvider.CreateEncryptor();\n\n        String message = \"Hello World\";\n        byte[] messageB = System.Text.Encoding.ASCII.GetBytes(message);\n        return encryptor.TransformFinalBlock(messageB, 0, messageB.Length);\n    }\n}\n\n```\n\n## References\n* Wikipedia: [Key Size](http://en.wikipedia.org/wiki/Key_size)\n* Wikipedia: [DES](http://en.wikipedia.org/wiki/Data_Encryption_Standard)\n* Common Weakness Enumeration: [CWE-327](https://cwe.mitre.org/data/definitions/327.html).\n",
                  "markdown": "# Weak encryption\nWeak encryption algorithms provide very little security. For example DES encryption uses keys of 56 bits only, and no longer provides sufficient protection for sensitive data. TripleDES should also be deprecated for very sensitive data: Although it improves on DES by using 168-bit long keys, it provides in fact at most 112 bits of security.\n\n\n## Recommendation\nYou should switch to a more secure encryption algorithm, such as AES (Advanced Encryption Standard) and use a key length which is reasonable for the application for which it is being used. Do not use the ECB encryption mode since it is vulnerable to replay and other attacks.\n\n\n## Example\nThis example uses DES, which is limited to a 56-bit key. The key provided is actually 64 bits but the last bit of each byte is turned into a parity bit. For example the bytes 01010101 and 01010100 can be used in place of each other when encrypting and decrypting.\n\n\n```csharp\nclass WeakEncryption\n{\n    public static byte[] encryptString()\n    {\n        SymmetricAlgorithm serviceProvider = new DESCryptoServiceProvider();\n        byte[] key = { 16, 22, 240, 11, 18, 150, 192, 21 };\n        serviceProvider.Key = key;\n        ICryptoTransform encryptor = serviceProvider.CreateEncryptor();\n\n        String message = \"Hello World\";\n        byte[] messageB = System.Text.Encoding.ASCII.GetBytes(message);\n        return encryptor.TransformFinalBlock(messageB, 0, messageB.Length);\n    }\n}\n\n```\n\n## References\n* Wikipedia: [Key Size](http://en.wikipedia.org/wiki/Key_size)\n* Wikipedia: [DES](http://en.wikipedia.org/wiki/Data_Encryption_Standard)\n* Common Weakness Enumeration: [CWE-327](https://cwe.mitre.org/data/definitions/327.html).\n"
                },
                "properties": {
                  "tags": [
                    "security",
                    "external/cwe/cwe-327"
                  ],
                  "description": "Finds uses of encryption algorithms that are weak and obsolete",
                  "id": "cs/weak-encryption",
                  "kind": "problem",
                  "name": "Weak encryption",
                  "precision": "high",
                  "problem.severity": "warning",
                  "security-severity": "7.5"
                }
              },
              {
                "id": "cs/web/xss",
                "name": "cs/web/xss",
                "shortDescription": {
                  "text": "Cross-site scripting"
                },
                "fullDescription": {
                  "text": "Writing user input directly to a web page allows for a cross-site scripting vulnerability."
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "error"
                },
                "help": {
                  "text": "# Cross-site scripting\nDirectly writing user input (for example, an HTTP request parameter) to a webpage, without properly sanitizing the input first, allows for a cross-site scripting vulnerability.\n\n\n## Recommendation\nTo guard against cross-site scripting, consider using a library that provides suitable encoding functionality, such as the `System.Net.WebUtility` class, to sanitize the untrusted input before writing it to the page. For other possible solutions, see the references.\n\n\n## Example\nThe following example shows the page parameter being written directly to the server error page, leaving the website vulnerable to cross-site scripting.\n\n\n```csharp\nusing System;\nusing System.Web;\n\npublic class XSSHandler : IHttpHandler\n{\n    public void ProcessRequest(HttpContext ctx)\n    {\n        ctx.Response.Write(\n            \"The page \\\"\" + ctx.Request.QueryString[\"page\"] + \"\\\" was not found.\");\n    }\n}\n\n```\nSanitizing the user-controlled data using the `WebUtility.HtmlEncode` method prevents the vulnerability:\n\n\n```csharp\nusing System;\nusing System.Web;\nusing System.Net;\n\npublic class XSSHandler : IHttpHandler\n{\n    public void ProcessRequest(HttpContext ctx)\n    {\n        string page = WebUtility.HtmlEncode(ctx.Request.QueryString[\"page\"]);\n        ctx.Response.Write(\n            \"The page \\\"\" + page + \"\\\" was not found.\");\n    }\n}\n\n```\n\n## References\n* OWASP: [XSS (Cross Site Scripting) Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html).\n* Wikipedia: [Cross-site scripting](http://en.wikipedia.org/wiki/Cross-site_scripting).\n* Common Weakness Enumeration: [CWE-79](https://cwe.mitre.org/data/definitions/79.html).\n* Common Weakness Enumeration: [CWE-116](https://cwe.mitre.org/data/definitions/116.html).\n",
                  "markdown": "# Cross-site scripting\nDirectly writing user input (for example, an HTTP request parameter) to a webpage, without properly sanitizing the input first, allows for a cross-site scripting vulnerability.\n\n\n## Recommendation\nTo guard against cross-site scripting, consider using a library that provides suitable encoding functionality, such as the `System.Net.WebUtility` class, to sanitize the untrusted input before writing it to the page. For other possible solutions, see the references.\n\n\n## Example\nThe following example shows the page parameter being written directly to the server error page, leaving the website vulnerable to cross-site scripting.\n\n\n```csharp\nusing System;\nusing System.Web;\n\npublic class XSSHandler : IHttpHandler\n{\n    public void ProcessRequest(HttpContext ctx)\n    {\n        ctx.Response.Write(\n            \"The page \\\"\" + ctx.Request.QueryString[\"page\"] + \"\\\" was not found.\");\n    }\n}\n\n```\nSanitizing the user-controlled data using the `WebUtility.HtmlEncode` method prevents the vulnerability:\n\n\n```csharp\nusing System;\nusing System.Web;\nusing System.Net;\n\npublic class XSSHandler : IHttpHandler\n{\n    public void ProcessRequest(HttpContext ctx)\n    {\n        string page = WebUtility.HtmlEncode(ctx.Request.QueryString[\"page\"]);\n        ctx.Response.Write(\n            \"The page \\\"\" + page + \"\\\" was not found.\");\n    }\n}\n\n```\n\n## References\n* OWASP: [XSS (Cross Site Scripting) Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html).\n* Wikipedia: [Cross-site scripting](http://en.wikipedia.org/wiki/Cross-site_scripting).\n* Common Weakness Enumeration: [CWE-79](https://cwe.mitre.org/data/definitions/79.html).\n* Common Weakness Enumeration: [CWE-116](https://cwe.mitre.org/data/definitions/116.html).\n"
                },
                "properties": {
                  "tags": [
                    "security",
                    "external/cwe/cwe-079",
                    "external/cwe/cwe-116"
                  ],
                  "description": "Writing user input directly to a web page\n              allows for a cross-site scripting vulnerability.",
                  "id": "cs/web/xss",
                  "kind": "path-problem",
                  "name": "Cross-site scripting",
                  "precision": "high",
                  "problem.severity": "error",
                  "security-severity": "6.1"
                }
              },
              {
                "id": "cs/uncontrolled-format-string",
                "name": "cs/uncontrolled-format-string",
                "shortDescription": {
                  "text": "Uncontrolled format string"
                },
                "fullDescription": {
                  "text": "Passing untrusted format strings from remote data sources can throw exceptions and cause a denial of service."
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "error"
                },
                "help": {
                  "text": "# Uncontrolled format string\nPassing untrusted format strings to `String.Format` can throw exceptions and cause a denial of service. For example, if the format string references a missing argument, or an argument of the wrong type, then `System.FormatException` is thrown.\n\n\n## Recommendation\nUse a string literal for the format string to prevent the possibility of data flow from an untrusted source. This also helps to prevent errors where the arguments to `String.Format` do not match the format string.\n\nIf the format string cannot be constant, ensure that it comes from a secure data source or is compiled into the source code.\n\n\n## Example\nIn this example, the format string is read from an HTTP request, which could cause the application to crash.\n\n\n```csharp\nusing System.Web;\n\npublic class HttpHandler : IHttpHandler\n{\n    string Surname, Forenames, FormattedName;\n\n    public void ProcessRequest(HttpContext ctx)\n    {\n        string format = ctx.Request.QueryString[\"nameformat\"];\n\n        // BAD: Uncontrolled format string.\n        FormattedName = string.Format(format, Surname, Forenames);\n    }\n}\n\n```\n\n## References\n* OWASP: [Format string attack](https://www.owasp.org/index.php/Format_string_attack).\n* Microsoft docs: [String.Format Method](https://docs.microsoft.com/en-us/dotnet/api/system.string.format)\n* Common Weakness Enumeration: [CWE-134](https://cwe.mitre.org/data/definitions/134.html).\n",
                  "markdown": "# Uncontrolled format string\nPassing untrusted format strings to `String.Format` can throw exceptions and cause a denial of service. For example, if the format string references a missing argument, or an argument of the wrong type, then `System.FormatException` is thrown.\n\n\n## Recommendation\nUse a string literal for the format string to prevent the possibility of data flow from an untrusted source. This also helps to prevent errors where the arguments to `String.Format` do not match the format string.\n\nIf the format string cannot be constant, ensure that it comes from a secure data source or is compiled into the source code.\n\n\n## Example\nIn this example, the format string is read from an HTTP request, which could cause the application to crash.\n\n\n```csharp\nusing System.Web;\n\npublic class HttpHandler : IHttpHandler\n{\n    string Surname, Forenames, FormattedName;\n\n    public void ProcessRequest(HttpContext ctx)\n    {\n        string format = ctx.Request.QueryString[\"nameformat\"];\n\n        // BAD: Uncontrolled format string.\n        FormattedName = string.Format(format, Surname, Forenames);\n    }\n}\n\n```\n\n## References\n* OWASP: [Format string attack](https://www.owasp.org/index.php/Format_string_attack).\n* Microsoft docs: [String.Format Method](https://docs.microsoft.com/en-us/dotnet/api/system.string.format)\n* Common Weakness Enumeration: [CWE-134](https://cwe.mitre.org/data/definitions/134.html).\n"
                },
                "properties": {
                  "tags": [
                    "security",
                    "external/cwe/cwe-134"
                  ],
                  "description": "Passing untrusted format strings from remote data sources can throw exceptions\n              and cause a denial of service.",
                  "id": "cs/uncontrolled-format-string",
                  "kind": "path-problem",
                  "name": "Uncontrolled format string",
                  "precision": "high",
                  "problem.severity": "error",
                  "security-severity": "9.3"
                }
              },
              {
                "id": "cs/code-injection",
                "name": "cs/code-injection",
                "shortDescription": {
                  "text": "Improper control of generation of code"
                },
                "fullDescription": {
                  "text": "Treating externally controlled strings as code can allow an attacker to execute malicious code."
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "error"
                },
                "help": {
                  "text": "# Improper control of generation of code\nIf the application dynamically compiles and runs source code constructed from user input, a malicious user may be able to run arbitrary code.\n\n\n## Recommendation\nIt is good practice not to generate, compile and run source code constructed from untrusted user input. If code must be dynamically generated using user input, the user input should be validated to prevent arbitrary code from appearing in the input. For example, a whitelist may be used to ensure that the input is limited to an acceptable range of values.\n\n\n## Example\nIn the following example, the HttpHandler accepts remote user input which is C\\# source code for calculating tax. It compiles and runs this code, returning the output. However, the user provided source code is entirely unvalidated, and therefore allows arbitrary code execution.\n\nIf possible, the dynamic compilation should be removed all together, and replaced with a fixed set of tax calculation algorithms. If this is not sufficiently powerful, an interpreter could be provided for a safe, restricted language.\n\n\n```csharp\nusing Microsoft.CSharp;\nusing System;\nusing System.CodeDom.Compiler;\nusing System.Reflection;\nusing System.Web;\n\npublic class CodeInjectionHandler : IHttpHandler\n{\n    public void ProcessRequest(HttpContext ctx)\n    {\n        // Code for calculating tax is provided as unvalidated user input\n        string taxFormula = ctx.Request.QueryString[\"tax_formula\"];\n        // Used to create C#\n        StringBuilder sourceCode = new StringBuilder(\"\");\n        sourceCode.Append(\"public class TaxCalc {\\n\");\n        sourceCode.Append(\"\\tpublic int CalculateTax(int value){\\n\");\n        sourceCode.Append(\"\\t\\treturn \" + taxFormula + \"; \\n\");\n        sourceCode.Append(\"\\t}\\n\");\n        sourceCode.Append(\"}\\n\");\n\n        // BAD: This compiles the sourceCode, containing unvalidated user input\n        CSharpCodeProvider c = new CSharpCodeProvider();\n        ICodeCompiler icc = c.CreateCompiler();\n        CompilerParameters cp = new CompilerParameters();\n        CompilerResults cr = icc.CompileAssemblyFromSource(cp, sourceCode.ToString());\n\n        // Compiled input is loaded, and an instance of the class is constructed\n        System.Reflection.Assembly a = cr.CompiledAssembly;\n        object taxCalc = a.CreateInstance(\"TaxCalc\");\n\n        // Unsafe code is executed\n        Type taxCalcType = o.GetType();\n        MethodInfo mi = type.GetMethod(\"CalculateTax\");\n        int value = int.Parse(ctx.Request.QueryString[\"value\"]);\n        int s = (int)mi.Invoke(o, new object[] { value });\n\n        // Result is returned to the user\n        ctx.Response.Write(\"Tax value is: \" + s);\n    }\n}\n\n```\n\n## References\n* Wikipedia: [Code Injection](https://en.wikipedia.org/wiki/Code_injection).\n* OWASP: [Code Injection](https://www.owasp.org/index.php/Code_Injection).\n* Common Weakness Enumeration: [CWE-94](https://cwe.mitre.org/data/definitions/94.html).\n* Common Weakness Enumeration: [CWE-95](https://cwe.mitre.org/data/definitions/95.html).\n* Common Weakness Enumeration: [CWE-96](https://cwe.mitre.org/data/definitions/96.html).\n",
                  "markdown": "# Improper control of generation of code\nIf the application dynamically compiles and runs source code constructed from user input, a malicious user may be able to run arbitrary code.\n\n\n## Recommendation\nIt is good practice not to generate, compile and run source code constructed from untrusted user input. If code must be dynamically generated using user input, the user input should be validated to prevent arbitrary code from appearing in the input. For example, a whitelist may be used to ensure that the input is limited to an acceptable range of values.\n\n\n## Example\nIn the following example, the HttpHandler accepts remote user input which is C\\# source code for calculating tax. It compiles and runs this code, returning the output. However, the user provided source code is entirely unvalidated, and therefore allows arbitrary code execution.\n\nIf possible, the dynamic compilation should be removed all together, and replaced with a fixed set of tax calculation algorithms. If this is not sufficiently powerful, an interpreter could be provided for a safe, restricted language.\n\n\n```csharp\nusing Microsoft.CSharp;\nusing System;\nusing System.CodeDom.Compiler;\nusing System.Reflection;\nusing System.Web;\n\npublic class CodeInjectionHandler : IHttpHandler\n{\n    public void ProcessRequest(HttpContext ctx)\n    {\n        // Code for calculating tax is provided as unvalidated user input\n        string taxFormula = ctx.Request.QueryString[\"tax_formula\"];\n        // Used to create C#\n        StringBuilder sourceCode = new StringBuilder(\"\");\n        sourceCode.Append(\"public class TaxCalc {\\n\");\n        sourceCode.Append(\"\\tpublic int CalculateTax(int value){\\n\");\n        sourceCode.Append(\"\\t\\treturn \" + taxFormula + \"; \\n\");\n        sourceCode.Append(\"\\t}\\n\");\n        sourceCode.Append(\"}\\n\");\n\n        // BAD: This compiles the sourceCode, containing unvalidated user input\n        CSharpCodeProvider c = new CSharpCodeProvider();\n        ICodeCompiler icc = c.CreateCompiler();\n        CompilerParameters cp = new CompilerParameters();\n        CompilerResults cr = icc.CompileAssemblyFromSource(cp, sourceCode.ToString());\n\n        // Compiled input is loaded, and an instance of the class is constructed\n        System.Reflection.Assembly a = cr.CompiledAssembly;\n        object taxCalc = a.CreateInstance(\"TaxCalc\");\n\n        // Unsafe code is executed\n        Type taxCalcType = o.GetType();\n        MethodInfo mi = type.GetMethod(\"CalculateTax\");\n        int value = int.Parse(ctx.Request.QueryString[\"value\"]);\n        int s = (int)mi.Invoke(o, new object[] { value });\n\n        // Result is returned to the user\n        ctx.Response.Write(\"Tax value is: \" + s);\n    }\n}\n\n```\n\n## References\n* Wikipedia: [Code Injection](https://en.wikipedia.org/wiki/Code_injection).\n* OWASP: [Code Injection](https://www.owasp.org/index.php/Code_Injection).\n* Common Weakness Enumeration: [CWE-94](https://cwe.mitre.org/data/definitions/94.html).\n* Common Weakness Enumeration: [CWE-95](https://cwe.mitre.org/data/definitions/95.html).\n* Common Weakness Enumeration: [CWE-96](https://cwe.mitre.org/data/definitions/96.html).\n"
                },
                "properties": {
                  "tags": [
                    "security",
                    "external/cwe/cwe-094",
                    "external/cwe/cwe-095",
                    "external/cwe/cwe-096"
                  ],
                  "description": "Treating externally controlled strings as code can allow an attacker to execute\n              malicious code.",
                  "id": "cs/code-injection",
                  "kind": "path-problem",
                  "name": "Improper control of generation of code",
                  "precision": "high",
                  "problem.severity": "error",
                  "security-severity": "9.3"
                }
              },
              {
                "id": "cs/unvalidated-local-pointer-arithmetic",
                "name": "cs/unvalidated-local-pointer-arithmetic",
                "shortDescription": {
                  "text": "Unvalidated local pointer arithmetic"
                },
                "fullDescription": {
                  "text": "Using the result of a virtual method call in pointer arithmetic without validation is dangerous because the method may be overridden by a subtype to return any value."
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning"
                },
                "help": {
                  "text": "# Unvalidated local pointer arithmetic\nIt is dangerous to use the result of a virtual method call in pointer arithmetic without validation if external users can provide their own implementation of the virtual method. For example, if the analyzed project is distributed as a library or framework, then the end-user could provide a new implementation that returns any value.\n\n\n## Recommendation\nAlways validate the result of virtual methods calls before performing pointer arithmetic to avoid reading or writing outside the bounds of an allocated buffer.\n\n\n## Example\nIn this example, we write to a given element of an array, using an instance of the `PossiblyOverridableClass` to determine which element to write to.\n\nIn the first case, the `GetElementNumber` method is called, and the result is used in pointer arithmetic without any validation. If the user can define a subtype of `PossiblyOverridableClass`, they can create an implementation of `GetElementNumber` that returns an invalid element number. This would lead to a write occurring outside the bounds of the `charArray`.\n\nIn the second case, the result of `GetElementNumber` is stored, and confirmed to be within the bounds of the array. Note that it is not sufficient to check that it is smaller than the length. We must also ensure that it's greater than zero, to prevent writes to locations before the buffer as well as afterwards.\n\n\n```csharp\npublic class PossiblyOverridable\n{\n    public virtual int GetElementNumber()\n    {\n        // By default returns 0, which is safe\n        return 0;\n    }\n}\n\npublic class PointerArithmetic\n{\n    public unsafe void WriteToOffset(PossiblyOverridable possiblyOverridable,\n                                     char[] charArray)\n    {\n        fixed (char* charPointer = charArray)\n        {\n            // BAD: Unvalidated use of virtual method call result in pointer arithmetic\n            char* newCharPointer = charPointer + possiblyOverridable.GetElementNumber();\n            *newCharPointer = 'A';\n            // GOOD: Check that the number is viable\n            int number = possiblyOverridable.GetElementNumber();\n            if (number >= 0 && number < charArray.Length)\n            {\n                char* newCharPointer2 = charPointer + number;\n                *newCharPointer = 'A';\n            }\n        }\n    }\n}\n\n```\n\n## References\n* Microsoft: [Unsafe Code and Pointers](https://msdn.microsoft.com/en-us/library/t2yzs44b.aspx).\n* Common Weakness Enumeration: [CWE-119](https://cwe.mitre.org/data/definitions/119.html).\n* Common Weakness Enumeration: [CWE-120](https://cwe.mitre.org/data/definitions/120.html).\n* Common Weakness Enumeration: [CWE-122](https://cwe.mitre.org/data/definitions/122.html).\n* Common Weakness Enumeration: [CWE-788](https://cwe.mitre.org/data/definitions/788.html).\n",
                  "markdown": "# Unvalidated local pointer arithmetic\nIt is dangerous to use the result of a virtual method call in pointer arithmetic without validation if external users can provide their own implementation of the virtual method. For example, if the analyzed project is distributed as a library or framework, then the end-user could provide a new implementation that returns any value.\n\n\n## Recommendation\nAlways validate the result of virtual methods calls before performing pointer arithmetic to avoid reading or writing outside the bounds of an allocated buffer.\n\n\n## Example\nIn this example, we write to a given element of an array, using an instance of the `PossiblyOverridableClass` to determine which element to write to.\n\nIn the first case, the `GetElementNumber` method is called, and the result is used in pointer arithmetic without any validation. If the user can define a subtype of `PossiblyOverridableClass`, they can create an implementation of `GetElementNumber` that returns an invalid element number. This would lead to a write occurring outside the bounds of the `charArray`.\n\nIn the second case, the result of `GetElementNumber` is stored, and confirmed to be within the bounds of the array. Note that it is not sufficient to check that it is smaller than the length. We must also ensure that it's greater than zero, to prevent writes to locations before the buffer as well as afterwards.\n\n\n```csharp\npublic class PossiblyOverridable\n{\n    public virtual int GetElementNumber()\n    {\n        // By default returns 0, which is safe\n        return 0;\n    }\n}\n\npublic class PointerArithmetic\n{\n    public unsafe void WriteToOffset(PossiblyOverridable possiblyOverridable,\n                                     char[] charArray)\n    {\n        fixed (char* charPointer = charArray)\n        {\n            // BAD: Unvalidated use of virtual method call result in pointer arithmetic\n            char* newCharPointer = charPointer + possiblyOverridable.GetElementNumber();\n            *newCharPointer = 'A';\n            // GOOD: Check that the number is viable\n            int number = possiblyOverridable.GetElementNumber();\n            if (number >= 0 && number < charArray.Length)\n            {\n                char* newCharPointer2 = charPointer + number;\n                *newCharPointer = 'A';\n            }\n        }\n    }\n}\n\n```\n\n## References\n* Microsoft: [Unsafe Code and Pointers](https://msdn.microsoft.com/en-us/library/t2yzs44b.aspx).\n* Common Weakness Enumeration: [CWE-119](https://cwe.mitre.org/data/definitions/119.html).\n* Common Weakness Enumeration: [CWE-120](https://cwe.mitre.org/data/definitions/120.html).\n* Common Weakness Enumeration: [CWE-122](https://cwe.mitre.org/data/definitions/122.html).\n* Common Weakness Enumeration: [CWE-788](https://cwe.mitre.org/data/definitions/788.html).\n"
                },
                "properties": {
                  "tags": [
                    "security",
                    "external/cwe/cwe-119",
                    "external/cwe/cwe-120",
                    "external/cwe/cwe-122",
                    "external/cwe/cwe-788"
                  ],
                  "description": "Using the result of a virtual method call in pointer arithmetic without\n              validation is dangerous because the method may be overridden by a subtype\n              to return any value.",
                  "id": "cs/unvalidated-local-pointer-arithmetic",
                  "kind": "problem",
                  "name": "Unvalidated local pointer arithmetic",
                  "precision": "high",
                  "problem.severity": "warning",
                  "security-severity": "9.3"
                }
              },
              {
                "id": "cs/path-injection",
                "name": "cs/path-injection",
                "shortDescription": {
                  "text": "Uncontrolled data used in path expression"
                },
                "fullDescription": {
                  "text": "Accessing paths influenced by users can allow an attacker to access unexpected resources."
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "error"
                },
                "help": {
                  "text": "# Uncontrolled data used in path expression\nAccessing paths controlled by users can allow an attacker to access unexpected resources. This can result in sensitive information being revealed or deleted, or an attacker being able to influence behavior by modifying unexpected files.\n\nPaths that are naively constructed from data controlled by a user may be absolute paths, or may contain unexpected special characters such as \"..\". Such a path could point anywhere on the file system.\n\n\n## Recommendation\nValidate user input before using it to construct a file path.\n\nCommon validation methods include checking that the normalized path is relative and does not contain any \"..\" components, or checking that the path is contained within a safe folder. The method you should use depends on how the path is used in the application, and whether the path should be a single path component.\n\nIf the path should be a single path component (such as a file name), you can check for the existence of any path separators (\"/\" or \"\\\\\"), or \"..\" sequences in the input, and reject the input if any are found.\n\nNote that removing \"../\" sequences is *not* sufficient, since the input could still contain a path separator followed by \"..\". For example, the input \".../...//\" would still result in the string \"../\" if only \"../\" sequences are removed.\n\nFinally, the simplest (but most restrictive) option is to use an allow list of safe patterns and make sure that the user input matches one of these patterns.\n\n\n## Example\nIn this example, a user-provided file name is read from a HTTP request and then used to access a file and send it back to the user. However, a malicious user could enter a file name anywhere on the file system, such as \"/etc/passwd\" or \"../../../etc/passwd\".\n\n\n```csharp\nusing System;\nusing System.IO;\nusing System.Web;\n\npublic class TaintedPathHandler : IHttpHandler\n{\n    public void ProcessRequest(HttpContext ctx)\n    {\n        string filename = ctx.Request.QueryString[\"path\"];\n        // BAD: This could read any file on the filesystem.\n        ctx.Response.Write(File.ReadAllText(filename));\n    }\n}\n\n```\nIf the input should only be a file name, you can check that it doesn't contain any path separators or \"..\" sequences.\n\n\n```csharp\nusing System;\nusing System.IO;\nusing System.Web;\n\npublic class TaintedPathHandler : IHttpHandler\n{\n    public void ProcessRequest(HttpContext ctx)\n    {\n        string filename = ctx.Request.QueryString[\"path\"];\n        // GOOD: ensure that the filename has no path separators or parent directory references\n        if (filename.Contains(\"..\") || filename.Contains(\"/\") || filename.Contains(\"\\\\\"))\n        {\n            ctx.Response.StatusCode = 400;\n            ctx.Response.StatusDescription = \"Bad Request\";\n            ctx.Response.Write(\"Invalid path\");\n            return;\n        }\n        ctx.Response.Write(File.ReadAllText(filename));\n    }\n}\n\n```\nIf the input should be within a specific directory, you can check that the resolved path is still contained within that directory.\n\n\n```csharp\nusing System;\nusing System.IO;\nusing System.Web;\n\npublic class TaintedPathHandler : IHttpHandler\n{\n    public void ProcessRequest(HttpContext ctx)\n    {\n        string filename = ctx.Request.QueryString[\"path\"];\n        \n        string user = ctx.User.Identity.Name;\n        string publicFolder = Path.GetFullPath(\"/home/\" + user + \"/public\");\n        string filePath = Path.GetFullPath(Path.Combine(publicFolder, filename));\n\n        // GOOD: ensure that the path stays within the public folder\n        if (!filePath.StartsWith(publicFolder + Path.DirectorySeparatorChar))\n        {\n            ctx.Response.StatusCode = 400;\n            ctx.Response.StatusDescription = \"Bad Request\";\n            ctx.Response.Write(\"Invalid path\");\n            return;\n        }\n        ctx.Response.Write(File.ReadAllText(filename));\n    }\n}\n\n```\n\n## References\n* OWASP: [Path Traversal](https://owasp.org/www-community/attacks/Path_Traversal).\n* Common Weakness Enumeration: [CWE-22](https://cwe.mitre.org/data/definitions/22.html).\n* Common Weakness Enumeration: [CWE-23](https://cwe.mitre.org/data/definitions/23.html).\n* Common Weakness Enumeration: [CWE-36](https://cwe.mitre.org/data/definitions/36.html).\n* Common Weakness Enumeration: [CWE-73](https://cwe.mitre.org/data/definitions/73.html).\n* Common Weakness Enumeration: [CWE-99](https://cwe.mitre.org/data/definitions/99.html).\n",
                  "markdown": "# Uncontrolled data used in path expression\nAccessing paths controlled by users can allow an attacker to access unexpected resources. This can result in sensitive information being revealed or deleted, or an attacker being able to influence behavior by modifying unexpected files.\n\nPaths that are naively constructed from data controlled by a user may be absolute paths, or may contain unexpected special characters such as \"..\". Such a path could point anywhere on the file system.\n\n\n## Recommendation\nValidate user input before using it to construct a file path.\n\nCommon validation methods include checking that the normalized path is relative and does not contain any \"..\" components, or checking that the path is contained within a safe folder. The method you should use depends on how the path is used in the application, and whether the path should be a single path component.\n\nIf the path should be a single path component (such as a file name), you can check for the existence of any path separators (\"/\" or \"\\\\\"), or \"..\" sequences in the input, and reject the input if any are found.\n\nNote that removing \"../\" sequences is *not* sufficient, since the input could still contain a path separator followed by \"..\". For example, the input \".../...//\" would still result in the string \"../\" if only \"../\" sequences are removed.\n\nFinally, the simplest (but most restrictive) option is to use an allow list of safe patterns and make sure that the user input matches one of these patterns.\n\n\n## Example\nIn this example, a user-provided file name is read from a HTTP request and then used to access a file and send it back to the user. However, a malicious user could enter a file name anywhere on the file system, such as \"/etc/passwd\" or \"../../../etc/passwd\".\n\n\n```csharp\nusing System;\nusing System.IO;\nusing System.Web;\n\npublic class TaintedPathHandler : IHttpHandler\n{\n    public void ProcessRequest(HttpContext ctx)\n    {\n        string filename = ctx.Request.QueryString[\"path\"];\n        // BAD: This could read any file on the filesystem.\n        ctx.Response.Write(File.ReadAllText(filename));\n    }\n}\n\n```\nIf the input should only be a file name, you can check that it doesn't contain any path separators or \"..\" sequences.\n\n\n```csharp\nusing System;\nusing System.IO;\nusing System.Web;\n\npublic class TaintedPathHandler : IHttpHandler\n{\n    public void ProcessRequest(HttpContext ctx)\n    {\n        string filename = ctx.Request.QueryString[\"path\"];\n        // GOOD: ensure that the filename has no path separators or parent directory references\n        if (filename.Contains(\"..\") || filename.Contains(\"/\") || filename.Contains(\"\\\\\"))\n        {\n            ctx.Response.StatusCode = 400;\n            ctx.Response.StatusDescription = \"Bad Request\";\n            ctx.Response.Write(\"Invalid path\");\n            return;\n        }\n        ctx.Response.Write(File.ReadAllText(filename));\n    }\n}\n\n```\nIf the input should be within a specific directory, you can check that the resolved path is still contained within that directory.\n\n\n```csharp\nusing System;\nusing System.IO;\nusing System.Web;\n\npublic class TaintedPathHandler : IHttpHandler\n{\n    public void ProcessRequest(HttpContext ctx)\n    {\n        string filename = ctx.Request.QueryString[\"path\"];\n        \n        string user = ctx.User.Identity.Name;\n        string publicFolder = Path.GetFullPath(\"/home/\" + user + \"/public\");\n        string filePath = Path.GetFullPath(Path.Combine(publicFolder, filename));\n\n        // GOOD: ensure that the path stays within the public folder\n        if (!filePath.StartsWith(publicFolder + Path.DirectorySeparatorChar))\n        {\n            ctx.Response.StatusCode = 400;\n            ctx.Response.StatusDescription = \"Bad Request\";\n            ctx.Response.Write(\"Invalid path\");\n            return;\n        }\n        ctx.Response.Write(File.ReadAllText(filename));\n    }\n}\n\n```\n\n## References\n* OWASP: [Path Traversal](https://owasp.org/www-community/attacks/Path_Traversal).\n* Common Weakness Enumeration: [CWE-22](https://cwe.mitre.org/data/definitions/22.html).\n* Common Weakness Enumeration: [CWE-23](https://cwe.mitre.org/data/definitions/23.html).\n* Common Weakness Enumeration: [CWE-36](https://cwe.mitre.org/data/definitions/36.html).\n* Common Weakness Enumeration: [CWE-73](https://cwe.mitre.org/data/definitions/73.html).\n* Common Weakness Enumeration: [CWE-99](https://cwe.mitre.org/data/definitions/99.html).\n"
                },
                "properties": {
                  "tags": [
                    "security",
                    "external/cwe/cwe-022",
                    "external/cwe/cwe-023",
                    "external/cwe/cwe-036",
                    "external/cwe/cwe-073",
                    "external/cwe/cwe-099"
                  ],
                  "description": "Accessing paths influenced by users can allow an attacker to access unexpected resources.",
                  "id": "cs/path-injection",
                  "kind": "path-problem",
                  "name": "Uncontrolled data used in path expression",
                  "precision": "high",
                  "problem.severity": "error",
                  "security-severity": "7.5"
                }
              },
              {
                "id": "cs/zipslip",
                "name": "cs/zipslip",
                "shortDescription": {
                  "text": "Arbitrary file access during archive extraction (\"Zip Slip\")"
                },
                "fullDescription": {
                  "text": "Extracting files from a malicious ZIP file, or similar type of archive, without validating that the destination file path is within the destination directory can allow an attacker to unexpectedly gain access to resources."
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "error"
                },
                "help": {
                  "text": "# Arbitrary file access during archive extraction (\"Zip Slip\")\nExtracting files from a malicious zip file, or similar type of archive, is at risk of directory traversal attacks if filenames from the archive are not properly validated.\n\nZip archives contain archive entries representing each file in the archive. These entries include a file path for the entry, but these file paths are not restricted and may contain unexpected special elements such as the directory traversal element (`..`). If these file paths are used to create a filesystem path, then a file operation may happen in an unexpected location. This can result in sensitive information being revealed or deleted, or an attacker being able to influence behavior by modifying unexpected files.\n\nFor example, if a zip file contains a file entry `..\\sneaky-file`, and the zip file is extracted to the directory `c:\\output`, then naively combining the paths would result in an output file path of `c:\\output\\..\\sneaky-file`, which would cause the file to be written to `c:\\sneaky-file`.\n\n\n## Recommendation\nEnsure that output paths constructed from zip archive entries are validated to prevent writing files to unexpected locations.\n\nThe recommended way of writing an output file from a zip archive entry is to:\n\n1. Use `Path.Combine(destinationDirectory, archiveEntry.FullName)` to determine the raw output path.\n1. Use `Path.GetFullPath(..)` on the raw output path to resolve any directory traversal elements.\n1. Use `Path.GetFullPath(destinationDirectory + Path.DirectorySeparatorChar)` to determine the fully resolved path of the destination directory.\n1. Validate that the resolved output path `StartsWith` the resolved destination directory, aborting if this is not true.\nAnother alternative is to validate archive entries against a whitelist of expected files.\n\n\n## Example\nIn this example, a file path taken from a zip archive item entry is combined with a destination directory. The result is used as the destination file path without verifying that the result is within the destination directory. If provided with a zip file containing an archive path like `..\\sneaky-file`, then this file would be written outside the destination directory.\n\n\n```csharp\nusing System.IO;\nusing System.IO.Compression;\n\nclass Bad\n{\n    public static void WriteToDirectory(ZipArchiveEntry entry,\n                                        string destDirectory)\n    {\n        string destFileName = Path.Combine(destDirectory, entry.FullName);\n        entry.ExtractToFile(destFileName);\n    }\n}\n\n```\nTo fix this vulnerability, we need to make three changes. Firstly, we need to resolve any directory traversal or other special characters in the path by using `Path.GetFullPath`. Secondly, we need to identify the destination output directory, again using `Path.GetFullPath`, this time on the output directory. Finally, we need to ensure that the resolved output starts with the resolved destination directory, and throw an exception if this is not the case.\n\n\n```csharp\nusing System.IO;\nusing System.IO.Compression;\n\nclass Good\n{\n    public static void WriteToDirectory(ZipArchiveEntry entry,\n                                        string destDirectory)\n    {\n        string destFileName = Path.GetFullPath(Path.Combine(destDirectory, entry.FullName));\n        string fullDestDirPath = Path.GetFullPath(destDirectory + Path.DirectorySeparatorChar);\n        if (!destFileName.StartsWith(fullDestDirPath)) {\n            throw new System.InvalidOperationException(\"Entry is outside the target dir: \" +\n                                                                                 destFileName);\n        }\n        entry.ExtractToFile(destFileName);\n    }\n}\n\n```\n\n## References\n* Snyk: [Zip Slip Vulnerability](https://snyk.io/research/zip-slip-vulnerability).\n* OWASP: [Path Traversal](https://owasp.org/www-community/attacks/Path_Traversal).\n* Common Weakness Enumeration: [CWE-22](https://cwe.mitre.org/data/definitions/22.html).\n",
                  "markdown": "# Arbitrary file access during archive extraction (\"Zip Slip\")\nExtracting files from a malicious zip file, or similar type of archive, is at risk of directory traversal attacks if filenames from the archive are not properly validated.\n\nZip archives contain archive entries representing each file in the archive. These entries include a file path for the entry, but these file paths are not restricted and may contain unexpected special elements such as the directory traversal element (`..`). If these file paths are used to create a filesystem path, then a file operation may happen in an unexpected location. This can result in sensitive information being revealed or deleted, or an attacker being able to influence behavior by modifying unexpected files.\n\nFor example, if a zip file contains a file entry `..\\sneaky-file`, and the zip file is extracted to the directory `c:\\output`, then naively combining the paths would result in an output file path of `c:\\output\\..\\sneaky-file`, which would cause the file to be written to `c:\\sneaky-file`.\n\n\n## Recommendation\nEnsure that output paths constructed from zip archive entries are validated to prevent writing files to unexpected locations.\n\nThe recommended way of writing an output file from a zip archive entry is to:\n\n1. Use `Path.Combine(destinationDirectory, archiveEntry.FullName)` to determine the raw output path.\n1. Use `Path.GetFullPath(..)` on the raw output path to resolve any directory traversal elements.\n1. Use `Path.GetFullPath(destinationDirectory + Path.DirectorySeparatorChar)` to determine the fully resolved path of the destination directory.\n1. Validate that the resolved output path `StartsWith` the resolved destination directory, aborting if this is not true.\nAnother alternative is to validate archive entries against a whitelist of expected files.\n\n\n## Example\nIn this example, a file path taken from a zip archive item entry is combined with a destination directory. The result is used as the destination file path without verifying that the result is within the destination directory. If provided with a zip file containing an archive path like `..\\sneaky-file`, then this file would be written outside the destination directory.\n\n\n```csharp\nusing System.IO;\nusing System.IO.Compression;\n\nclass Bad\n{\n    public static void WriteToDirectory(ZipArchiveEntry entry,\n                                        string destDirectory)\n    {\n        string destFileName = Path.Combine(destDirectory, entry.FullName);\n        entry.ExtractToFile(destFileName);\n    }\n}\n\n```\nTo fix this vulnerability, we need to make three changes. Firstly, we need to resolve any directory traversal or other special characters in the path by using `Path.GetFullPath`. Secondly, we need to identify the destination output directory, again using `Path.GetFullPath`, this time on the output directory. Finally, we need to ensure that the resolved output starts with the resolved destination directory, and throw an exception if this is not the case.\n\n\n```csharp\nusing System.IO;\nusing System.IO.Compression;\n\nclass Good\n{\n    public static void WriteToDirectory(ZipArchiveEntry entry,\n                                        string destDirectory)\n    {\n        string destFileName = Path.GetFullPath(Path.Combine(destDirectory, entry.FullName));\n        string fullDestDirPath = Path.GetFullPath(destDirectory + Path.DirectorySeparatorChar);\n        if (!destFileName.StartsWith(fullDestDirPath)) {\n            throw new System.InvalidOperationException(\"Entry is outside the target dir: \" +\n                                                                                 destFileName);\n        }\n        entry.ExtractToFile(destFileName);\n    }\n}\n\n```\n\n## References\n* Snyk: [Zip Slip Vulnerability](https://snyk.io/research/zip-slip-vulnerability).\n* OWASP: [Path Traversal](https://owasp.org/www-community/attacks/Path_Traversal).\n* Common Weakness Enumeration: [CWE-22](https://cwe.mitre.org/data/definitions/22.html).\n"
                },
                "properties": {
                  "tags": [
                    "security",
                    "external/cwe/cwe-022"
                  ],
                  "description": "Extracting files from a malicious ZIP file, or similar type of archive, without\n              validating that the destination file path is within the destination directory\n              can allow an attacker to unexpectedly gain access to resources.",
                  "id": "cs/zipslip",
                  "kind": "path-problem",
                  "name": "Arbitrary file access during archive extraction (\"Zip Slip\")",
                  "precision": "high",
                  "problem.severity": "error",
                  "security-severity": "7.5"
                }
              },
              {
                "id": "cs/inadequate-rsa-padding",
                "name": "cs/inadequate-rsa-padding",
                "shortDescription": {
                  "text": "Weak encryption: inadequate RSA padding"
                },
                "fullDescription": {
                  "text": "Finds uses of RSA encryption with inadequate padding."
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning"
                },
                "help": {
                  "text": "# Weak encryption: inadequate RSA padding\nThis query finds uses of RSA encryption without secure padding. Using PKCS\\#1 v1.5 padding can open up your application to several different attacks resulting in the exposure of the encryption key or the ability to determine plaintext from encrypted messages.\n\n\n## Recommendation\nUse the more secure PKCS\\#1 v2 (OAEP) padding.\n\n\n## References\n* Wikipedia. [RSA. Padding Schemes](http://en.wikipedia.org/wiki/RSA_(algorithm)#Padding_schemes).\n* Common Weakness Enumeration: [CWE-327](https://cwe.mitre.org/data/definitions/327.html).\n* Common Weakness Enumeration: [CWE-780](https://cwe.mitre.org/data/definitions/780.html).\n",
                  "markdown": "# Weak encryption: inadequate RSA padding\nThis query finds uses of RSA encryption without secure padding. Using PKCS\\#1 v1.5 padding can open up your application to several different attacks resulting in the exposure of the encryption key or the ability to determine plaintext from encrypted messages.\n\n\n## Recommendation\nUse the more secure PKCS\\#1 v2 (OAEP) padding.\n\n\n## References\n* Wikipedia. [RSA. Padding Schemes](http://en.wikipedia.org/wiki/RSA_(algorithm)#Padding_schemes).\n* Common Weakness Enumeration: [CWE-327](https://cwe.mitre.org/data/definitions/327.html).\n* Common Weakness Enumeration: [CWE-780](https://cwe.mitre.org/data/definitions/780.html).\n"
                },
                "properties": {
                  "tags": [
                    "security",
                    "external/cwe/cwe-327",
                    "external/cwe/cwe-780"
                  ],
                  "description": "Finds uses of RSA encryption with inadequate padding.",
                  "id": "cs/inadequate-rsa-padding",
                  "kind": "problem",
                  "name": "Weak encryption: inadequate RSA padding",
                  "precision": "high",
                  "problem.severity": "warning",
                  "security-severity": "7.5"
                }
              },
              {
                "id": "cs/xml/insecure-dtd-handling",
                "name": "cs/xml/insecure-dtd-handling",
                "shortDescription": {
                  "text": "Untrusted XML is read insecurely"
                },
                "fullDescription": {
                  "text": "Untrusted XML is read with an insecure resolver and DTD processing enabled."
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "error"
                },
                "help": {
                  "text": "# Untrusted XML is read insecurely\nXML documents can contain Document Type Definitions (DTDs), which may define new XML entities. These can be used to perform Denial of Service (DoS) attacks, or resolve to resources outside the intended sphere of control.\n\n\n## Recommendation\nWhen processing XML documents, ensure that DTD processing is disabled unless absolutely necessary, and if it is necessary, ensure that a secure resolver is used.\n\n\n## Example\nThe following example shows an HTTP request parameter being read directly into an `XmlTextReader`. In the current version of the .NET Framework, `XmlTextReader` has DTD processing enabled by default.\n\n\n```csharp\npublic class XMLHandler : IHttpHandler\n{\n    public void ProcessRequest(HttpContext ctx)\n    {\n        // BAD: XmlTextReader is insecure by default, and the payload is user-provided data\n        XmlTextReader reader = new XmlTextReader(ctx.Request.QueryString[\"document\"]);\n    ...\n  }\n}\n\n\n```\nThe solution is to set the `DtdProcessing` property to `DtdProcessing.Prohibit`.\n\n\n## References\n* OWASP: [XML External Entity (XXE) Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html).\n* Microsoft Docs: [System.XML: Security considerations](https://msdn.microsoft.com/en-us/library/system.xml.xmlreadersettings(v=vs.110).aspx#Anchor_6).\n* Common Weakness Enumeration: [CWE-611](https://cwe.mitre.org/data/definitions/611.html).\n* Common Weakness Enumeration: [CWE-827](https://cwe.mitre.org/data/definitions/827.html).\n* Common Weakness Enumeration: [CWE-776](https://cwe.mitre.org/data/definitions/776.html).\n",
                  "markdown": "# Untrusted XML is read insecurely\nXML documents can contain Document Type Definitions (DTDs), which may define new XML entities. These can be used to perform Denial of Service (DoS) attacks, or resolve to resources outside the intended sphere of control.\n\n\n## Recommendation\nWhen processing XML documents, ensure that DTD processing is disabled unless absolutely necessary, and if it is necessary, ensure that a secure resolver is used.\n\n\n## Example\nThe following example shows an HTTP request parameter being read directly into an `XmlTextReader`. In the current version of the .NET Framework, `XmlTextReader` has DTD processing enabled by default.\n\n\n```csharp\npublic class XMLHandler : IHttpHandler\n{\n    public void ProcessRequest(HttpContext ctx)\n    {\n        // BAD: XmlTextReader is insecure by default, and the payload is user-provided data\n        XmlTextReader reader = new XmlTextReader(ctx.Request.QueryString[\"document\"]);\n    ...\n  }\n}\n\n\n```\nThe solution is to set the `DtdProcessing` property to `DtdProcessing.Prohibit`.\n\n\n## References\n* OWASP: [XML External Entity (XXE) Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html).\n* Microsoft Docs: [System.XML: Security considerations](https://msdn.microsoft.com/en-us/library/system.xml.xmlreadersettings(v=vs.110).aspx#Anchor_6).\n* Common Weakness Enumeration: [CWE-611](https://cwe.mitre.org/data/definitions/611.html).\n* Common Weakness Enumeration: [CWE-827](https://cwe.mitre.org/data/definitions/827.html).\n* Common Weakness Enumeration: [CWE-776](https://cwe.mitre.org/data/definitions/776.html).\n"
                },
                "properties": {
                  "tags": [
                    "security",
                    "external/cwe/cwe-611",
                    "external/cwe/cwe-827",
                    "external/cwe/cwe-776"
                  ],
                  "description": "Untrusted XML is read with an insecure resolver and DTD processing enabled.",
                  "id": "cs/xml/insecure-dtd-handling",
                  "kind": "path-problem",
                  "name": "Untrusted XML is read insecurely",
                  "precision": "high",
                  "problem.severity": "error",
                  "security-severity": "9.1"
                }
              },
              {
                "id": "cs/insecure-xml-read",
                "name": "cs/insecure-xml-read",
                "shortDescription": {
                  "text": "XML is read insecurely"
                },
                "fullDescription": {
                  "text": "XML may include dangerous external references, which should be restricted using a secure resolver or disabling DTD processing."
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning"
                },
                "help": {
                  "text": "# XML is read insecurely\nXML documents can contain Document Type Definitions (DTDs), which may define new XML entities. These can be used to perform Denial of Service (DoS) attacks, or resolve to resources outside the intended sphere of control.\n\n\n## Recommendation\nWhen processing XML documents, ensure that DTD processing is disabled unless absolutely necessary, and if it is necessary, ensure that a secure resolver is used.\n\n\n## Example\nThe following example shows an HTTP request parameter being read directly into an `XmlTextReader`. In the current version of the .NET Framework, `XmlTextReader` has DTD processing enabled by default.\n\n\n```csharp\npublic class XMLHandler : IHttpHandler\n{\n    public void ProcessRequest(HttpContext ctx)\n    {\n        // BAD: XmlTextReader is insecure by default, and the payload is user-provided data\n        XmlTextReader reader = new XmlTextReader(ctx.Request.QueryString[\"document\"]);\n    ...\n  }\n}\n\n\n```\nThe solution is to set the `DtdProcessing` property to `DtdProcessing.Prohibit`.\n\n\n## References\n* OWASP: [XML External Entity (XXE) Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html).\n* Microsoft Docs: [System.XML: Security considerations](https://msdn.microsoft.com/en-us/library/system.xml.xmlreadersettings(v=vs.110).aspx#Anchor_6).\n* Common Weakness Enumeration: [CWE-611](https://cwe.mitre.org/data/definitions/611.html).\n* Common Weakness Enumeration: [CWE-827](https://cwe.mitre.org/data/definitions/827.html).\n* Common Weakness Enumeration: [CWE-776](https://cwe.mitre.org/data/definitions/776.html).\n",
                  "markdown": "# XML is read insecurely\nXML documents can contain Document Type Definitions (DTDs), which may define new XML entities. These can be used to perform Denial of Service (DoS) attacks, or resolve to resources outside the intended sphere of control.\n\n\n## Recommendation\nWhen processing XML documents, ensure that DTD processing is disabled unless absolutely necessary, and if it is necessary, ensure that a secure resolver is used.\n\n\n## Example\nThe following example shows an HTTP request parameter being read directly into an `XmlTextReader`. In the current version of the .NET Framework, `XmlTextReader` has DTD processing enabled by default.\n\n\n```csharp\npublic class XMLHandler : IHttpHandler\n{\n    public void ProcessRequest(HttpContext ctx)\n    {\n        // BAD: XmlTextReader is insecure by default, and the payload is user-provided data\n        XmlTextReader reader = new XmlTextReader(ctx.Request.QueryString[\"document\"]);\n    ...\n  }\n}\n\n\n```\nThe solution is to set the `DtdProcessing` property to `DtdProcessing.Prohibit`.\n\n\n## References\n* OWASP: [XML External Entity (XXE) Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html).\n* Microsoft Docs: [System.XML: Security considerations](https://msdn.microsoft.com/en-us/library/system.xml.xmlreadersettings(v=vs.110).aspx#Anchor_6).\n* Common Weakness Enumeration: [CWE-611](https://cwe.mitre.org/data/definitions/611.html).\n* Common Weakness Enumeration: [CWE-827](https://cwe.mitre.org/data/definitions/827.html).\n* Common Weakness Enumeration: [CWE-776](https://cwe.mitre.org/data/definitions/776.html).\n"
                },
                "properties": {
                  "tags": [
                    "security",
                    "external/cwe/cwe-611",
                    "external/cwe/cwe-827",
                    "external/cwe/cwe-776"
                  ],
                  "description": "XML may include dangerous external references, which should\n              be restricted using a secure resolver or disabling DTD processing.",
                  "id": "cs/insecure-xml-read",
                  "kind": "problem",
                  "name": "XML is read insecurely",
                  "precision": "low",
                  "problem.severity": "warning",
                  "security-severity": "9.1"
                }
              },
              {
                "id": "cs/web/missing-function-level-access-control",
                "name": "cs/web/missing-function-level-access-control",
                "shortDescription": {
                  "text": "Missing function level access control"
                },
                "fullDescription": {
                  "text": "Sensitive actions should have authorization checks to prevent them from being used by malicious actors."
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning"
                },
                "help": {
                  "text": "# Missing function level access control\nSensitive actions, such as editing or deleting content, or accessing admin pages, should have authorization checks to ensure that they cannot be used by malicious actors.\n\n\n## Recommendation\nEnsure that proper authorization checks are made for sensitive actions. For WebForms applications, the `authorization` tag in `Web.config` XML files can be used to implement access control. The `System.Web.UI.Page.User` property can also be used to verify a user's role. For MVC applications, the `Authorize` attribute can be used to require authorization on specific action methods.\n\n\n## Example\nIn the following WebForms example, the case marked BAD has no authorization checks whereas the case marked GOOD uses `User.IsInRole` to check for the user's role.\n\n\n```csharp\nclass ProfilePage : System.Web.UI.Page {\n    // BAD: No authorization is used\n    protected void btn1_Edit_Click(object sender, EventArgs e) {\n        ...\n    }\n\n    // GOOD: `User.IsInRole` checks the current user's role.\n    protected void btn2_Delete_Click(object sender, EventArgs e) {\n        if (!User.IsInRole(\"admin\")) {\n            return;\n        }\n        ...\n    }\n} \n```\nThe following `Web.config` file uses the `authorization` tag to deny access to anonymous users, in a `location` tag to have that configuration apply to a specific path.\n\n\n```none\n<?xml version=\"1.0\"?>\n\n<configuration xmlns:xdt=\"http://schemas.microsoft.com/XML-Document-Transform\">\n  <location path=\"User/Profile\">\n    <system.web>\n      <authorization>\n        <deny users=\"?\" />\n      </authorization>\n    </system.web>\n  </location>\n</configuration>\n```\nIn the following MVC example, the case marked BAD has no authorization checks whereas the case marked GOOD uses the `Authorize` attribute.\n\n\n```csharp\npublic class ProfileController : Controller {\n\n    // BAD: No authorization is used.\n    public ActionResult Edit(int id) {\n        ...\n    }\n\n    // GOOD: The `Authorize` attribute is used.\n    [Authorize]\n    public ActionResult Delete(int id) {\n        ...\n    }\n}\n```\n\n## References\n* `Page.User` Property - [Microsoft Learn](https://learn.microsoft.com/en-us/dotnet/api/system.web.ui.page.user?view=netframework-4.8.1#system-web-ui-page-user).\n* Control authorization permissions in an ASP.NET application - [Microsoft Learn](https://learn.microsoft.com/en-us/troubleshoot/developer/webapps/aspnet/www-authentication-authorization/authorization-permissions).\n* Simple authorization in ASP.NET Core - [Microsoft Learn](https://learn.microsoft.com/en-us/aspnet/core/security/authorization/simple?view=aspnetcore-7.0).\n* Common Weakness Enumeration: [CWE-285](https://cwe.mitre.org/data/definitions/285.html).\n* Common Weakness Enumeration: [CWE-284](https://cwe.mitre.org/data/definitions/284.html).\n* Common Weakness Enumeration: [CWE-862](https://cwe.mitre.org/data/definitions/862.html).\n",
                  "markdown": "# Missing function level access control\nSensitive actions, such as editing or deleting content, or accessing admin pages, should have authorization checks to ensure that they cannot be used by malicious actors.\n\n\n## Recommendation\nEnsure that proper authorization checks are made for sensitive actions. For WebForms applications, the `authorization` tag in `Web.config` XML files can be used to implement access control. The `System.Web.UI.Page.User` property can also be used to verify a user's role. For MVC applications, the `Authorize` attribute can be used to require authorization on specific action methods.\n\n\n## Example\nIn the following WebForms example, the case marked BAD has no authorization checks whereas the case marked GOOD uses `User.IsInRole` to check for the user's role.\n\n\n```csharp\nclass ProfilePage : System.Web.UI.Page {\n    // BAD: No authorization is used\n    protected void btn1_Edit_Click(object sender, EventArgs e) {\n        ...\n    }\n\n    // GOOD: `User.IsInRole` checks the current user's role.\n    protected void btn2_Delete_Click(object sender, EventArgs e) {\n        if (!User.IsInRole(\"admin\")) {\n            return;\n        }\n        ...\n    }\n} \n```\nThe following `Web.config` file uses the `authorization` tag to deny access to anonymous users, in a `location` tag to have that configuration apply to a specific path.\n\n\n```none\n<?xml version=\"1.0\"?>\n\n<configuration xmlns:xdt=\"http://schemas.microsoft.com/XML-Document-Transform\">\n  <location path=\"User/Profile\">\n    <system.web>\n      <authorization>\n        <deny users=\"?\" />\n      </authorization>\n    </system.web>\n  </location>\n</configuration>\n```\nIn the following MVC example, the case marked BAD has no authorization checks whereas the case marked GOOD uses the `Authorize` attribute.\n\n\n```csharp\npublic class ProfileController : Controller {\n\n    // BAD: No authorization is used.\n    public ActionResult Edit(int id) {\n        ...\n    }\n\n    // GOOD: The `Authorize` attribute is used.\n    [Authorize]\n    public ActionResult Delete(int id) {\n        ...\n    }\n}\n```\n\n## References\n* `Page.User` Property - [Microsoft Learn](https://learn.microsoft.com/en-us/dotnet/api/system.web.ui.page.user?view=netframework-4.8.1#system-web-ui-page-user).\n* Control authorization permissions in an ASP.NET application - [Microsoft Learn](https://learn.microsoft.com/en-us/troubleshoot/developer/webapps/aspnet/www-authentication-authorization/authorization-permissions).\n* Simple authorization in ASP.NET Core - [Microsoft Learn](https://learn.microsoft.com/en-us/aspnet/core/security/authorization/simple?view=aspnetcore-7.0).\n* Common Weakness Enumeration: [CWE-285](https://cwe.mitre.org/data/definitions/285.html).\n* Common Weakness Enumeration: [CWE-284](https://cwe.mitre.org/data/definitions/284.html).\n* Common Weakness Enumeration: [CWE-862](https://cwe.mitre.org/data/definitions/862.html).\n"
                },
                "properties": {
                  "tags": [
                    "security",
                    "external/cwe/cwe-285",
                    "external/cwe/cwe-284",
                    "external/cwe/cwe-862"
                  ],
                  "description": "Sensitive actions should have authorization checks to prevent them from being used by malicious actors.",
                  "id": "cs/web/missing-function-level-access-control",
                  "kind": "problem",
                  "name": "Missing function level access control",
                  "precision": "medium",
                  "problem.severity": "warning",
                  "security-severity": "7.5"
                }
              },
              {
                "id": "cs/web/persistent-cookie",
                "name": "cs/web/persistent-cookie",
                "shortDescription": {
                  "text": "Cookie security: persistent cookie"
                },
                "fullDescription": {
                  "text": "Persistent cookies are vulnerable to attacks."
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning"
                },
                "help": {
                  "text": "# Cookie security: persistent cookie\nThis rule finds cookies that are made to expire in more than 5 minutes from now. Cookies are usually non-persistent, in which case they reside in the browser's memory only. However, by setting an expiration date in the future, cookies can be made persistent and are then written to disk to survive the browser restarts. If a persistent cookie is set to expire in a fairly distant future, it is easier for an attacker to steal its data.\n\n\n## Recommendation\nDo not put sensitive information in persistent cookies.\n\n\n## References\n* Common Weakness Enumeration: [CWE-539](https://cwe.mitre.org/data/definitions/539.html).\n",
                  "markdown": "# Cookie security: persistent cookie\nThis rule finds cookies that are made to expire in more than 5 minutes from now. Cookies are usually non-persistent, in which case they reside in the browser's memory only. However, by setting an expiration date in the future, cookies can be made persistent and are then written to disk to survive the browser restarts. If a persistent cookie is set to expire in a fairly distant future, it is easier for an attacker to steal its data.\n\n\n## Recommendation\nDo not put sensitive information in persistent cookies.\n\n\n## References\n* Common Weakness Enumeration: [CWE-539](https://cwe.mitre.org/data/definitions/539.html).\n"
                },
                "properties": {
                  "tags": [
                    "security",
                    "external/cwe/cwe-539"
                  ],
                  "description": "Persistent cookies are vulnerable to attacks.",
                  "id": "cs/web/persistent-cookie",
                  "kind": "problem",
                  "name": "Cookie security: persistent cookie",
                  "precision": "high",
                  "problem.severity": "warning",
                  "security-severity": "8.2"
                }
              },
              {
                "id": "cs/log-forging",
                "name": "cs/log-forging",
                "shortDescription": {
                  "text": "Log entries created from user input"
                },
                "fullDescription": {
                  "text": "Building log entries from user-controlled sources is vulnerable to insertion of forged log entries by a malicious user."
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "error"
                },
                "help": {
                  "text": "# Log entries created from user input\nIf unsanitized user input is written to a log entry, a malicious user may be able to forge new log entries.\n\nForgery can occur if a user provides some input with characters that are interpreted when the log output is displayed. If the log is displayed as a plain text file, then new line characters can be used by a malicious user. If the log is displayed as HTML, then arbitrary HTML may be include to spoof log entries.\n\n\n## Recommendation\nUser input should be suitably encoded before it is logged.\n\nIf the log entries are plain text then line breaks should be removed from user input, using `String.Replace` or similar. Care should also be taken that user input is clearly marked in log entries, and that a malicious user cannot cause confusion in other ways.\n\nFor log entries that will be displayed in HTML, user input should be HTML encoded using `HttpServerUtility.HtmlEncode` or similar before being logged, to prevent forgery and other forms of HTML injection.\n\n\n## Example\nIn the following example, a user name, provided by the user, is logged using a logging framework. In the first case, it is logged without any sanitization. In the second case, `String.Replace` is used to ensure no line endings are present in the user input.\n\n\n```csharp\nusing Microsoft.Extensions.Logging;\nusing System;\nusing System.IO;\nusing System.Web;\n\npublic class LogForgingHandler : IHttpHandler\n{\n    private ILogger logger;\n\n    public void ProcessRequest(HttpContext ctx)\n    {\n        String username = ctx.Request.QueryString[\"username\"];\n        // BAD: User input logged as-is\n        logger.Warn(username + \" log in requested.\");\n        // GOOD: User input logged with new-lines removed\n        logger.Warn(username.Replace(Environment.NewLine, \"\") + \" log in requested\");\n    }\n}\n\n```\n\n## References\n* OWASP: [Log Injection](https://www.owasp.org/index.php/Log_Injection).\n* Common Weakness Enumeration: [CWE-117](https://cwe.mitre.org/data/definitions/117.html).\n",
                  "markdown": "# Log entries created from user input\nIf unsanitized user input is written to a log entry, a malicious user may be able to forge new log entries.\n\nForgery can occur if a user provides some input with characters that are interpreted when the log output is displayed. If the log is displayed as a plain text file, then new line characters can be used by a malicious user. If the log is displayed as HTML, then arbitrary HTML may be include to spoof log entries.\n\n\n## Recommendation\nUser input should be suitably encoded before it is logged.\n\nIf the log entries are plain text then line breaks should be removed from user input, using `String.Replace` or similar. Care should also be taken that user input is clearly marked in log entries, and that a malicious user cannot cause confusion in other ways.\n\nFor log entries that will be displayed in HTML, user input should be HTML encoded using `HttpServerUtility.HtmlEncode` or similar before being logged, to prevent forgery and other forms of HTML injection.\n\n\n## Example\nIn the following example, a user name, provided by the user, is logged using a logging framework. In the first case, it is logged without any sanitization. In the second case, `String.Replace` is used to ensure no line endings are present in the user input.\n\n\n```csharp\nusing Microsoft.Extensions.Logging;\nusing System;\nusing System.IO;\nusing System.Web;\n\npublic class LogForgingHandler : IHttpHandler\n{\n    private ILogger logger;\n\n    public void ProcessRequest(HttpContext ctx)\n    {\n        String username = ctx.Request.QueryString[\"username\"];\n        // BAD: User input logged as-is\n        logger.Warn(username + \" log in requested.\");\n        // GOOD: User input logged with new-lines removed\n        logger.Warn(username.Replace(Environment.NewLine, \"\") + \" log in requested\");\n    }\n}\n\n```\n\n## References\n* OWASP: [Log Injection](https://www.owasp.org/index.php/Log_Injection).\n* Common Weakness Enumeration: [CWE-117](https://cwe.mitre.org/data/definitions/117.html).\n"
                },
                "properties": {
                  "tags": [
                    "security",
                    "external/cwe/cwe-117"
                  ],
                  "description": "Building log entries from user-controlled sources is vulnerable to\n              insertion of forged log entries by a malicious user.",
                  "id": "cs/log-forging",
                  "kind": "path-problem",
                  "name": "Log entries created from user input",
                  "precision": "high",
                  "problem.severity": "error",
                  "security-severity": "7.8"
                }
              },
              {
                "id": "cs/regex-injection",
                "name": "cs/regex-injection",
                "shortDescription": {
                  "text": "Regular expression injection"
                },
                "fullDescription": {
                  "text": "User input should not be used in regular expressions without first being escaped, otherwise a malicious user may be able to provide a regex that could require exponential time on certain inputs."
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "error"
                },
                "help": {
                  "text": "# Regular expression injection\nConstructing a regular expression with unsanitized user input is dangerous as a malicious user may be able to modify the meaning of the expression. In particular, such a user may be able to provide a regular expression fragment that takes exponential time in the worst case, and use that to perform a Denial of Service attack.\n\n\n## Recommendation\nFor user input that is intended to be referenced as a string literal in a regular expression, use the `Regex.Escape` method to escape any special characters. If the regular expression is intended to be configurable by the user, then a timeout should be used to avoid Denial of Service attacks. For C\\# applications, a timeout can be provided to the `Regex` constructor. Alternatively, apply a global timeout by setting the `REGEX_DEFAULT_MATCH_TIMEOUT` application domain property, using the `AppDomain.SetData` method.\n\n\n## Example\nThe following example shows a HTTP request parameter that is used as a regular expression, and matched against another request parameter.\n\nIn the first case, the regular expression is used without a timeout, and the user-provided regex is not escaped. If a malicious user provides a regex that has exponential worst case performance, then this could lead to a Denial of Service.\n\nIn the second case, the user input is escaped using `Regex.Escape` before being included in the regular expression. This ensures that the user cannot insert characters which have a special meaning in regular expressions.\n\n\n```csharp\nusing System;\nusing System.Web;\nusing System.Text.RegularExpressions;\n\npublic class RegexInjectionHandler : IHttpHandler\n{\n\n    public void ProcessRequest(HttpContext ctx)\n    {\n        string name = ctx.Request.QueryString[\"name\"];\n        string userInput = ctx.Request.QueryString[\"userInput\"];\n\n        // BAD: Unsanitized user input is used to construct a regular expression\n        new Regex(\"^\" + name + \"=.*$\").Match(userInput);\n\n        // GOOD: User input is sanitized before constructing the regex\n        string safeName = Regex.Escape(name);\n        new Regex(\"^\" + safeName + \"=.*$\").Match(userInput);\n    }\n}\n\n```\n\n## References\n* OWASP: [Regular expression Denial of Service - ReDoS](https://www.owasp.org/index.php/Regular_expression_Denial_of_Service_-_ReDoS).\n* Wikipedia: [ReDoS](https://en.wikipedia.org/wiki/ReDoS).\n* Common Weakness Enumeration: [CWE-730](https://cwe.mitre.org/data/definitions/730.html).\n* Common Weakness Enumeration: [CWE-400](https://cwe.mitre.org/data/definitions/400.html).\n",
                  "markdown": "# Regular expression injection\nConstructing a regular expression with unsanitized user input is dangerous as a malicious user may be able to modify the meaning of the expression. In particular, such a user may be able to provide a regular expression fragment that takes exponential time in the worst case, and use that to perform a Denial of Service attack.\n\n\n## Recommendation\nFor user input that is intended to be referenced as a string literal in a regular expression, use the `Regex.Escape` method to escape any special characters. If the regular expression is intended to be configurable by the user, then a timeout should be used to avoid Denial of Service attacks. For C\\# applications, a timeout can be provided to the `Regex` constructor. Alternatively, apply a global timeout by setting the `REGEX_DEFAULT_MATCH_TIMEOUT` application domain property, using the `AppDomain.SetData` method.\n\n\n## Example\nThe following example shows a HTTP request parameter that is used as a regular expression, and matched against another request parameter.\n\nIn the first case, the regular expression is used without a timeout, and the user-provided regex is not escaped. If a malicious user provides a regex that has exponential worst case performance, then this could lead to a Denial of Service.\n\nIn the second case, the user input is escaped using `Regex.Escape` before being included in the regular expression. This ensures that the user cannot insert characters which have a special meaning in regular expressions.\n\n\n```csharp\nusing System;\nusing System.Web;\nusing System.Text.RegularExpressions;\n\npublic class RegexInjectionHandler : IHttpHandler\n{\n\n    public void ProcessRequest(HttpContext ctx)\n    {\n        string name = ctx.Request.QueryString[\"name\"];\n        string userInput = ctx.Request.QueryString[\"userInput\"];\n\n        // BAD: Unsanitized user input is used to construct a regular expression\n        new Regex(\"^\" + name + \"=.*$\").Match(userInput);\n\n        // GOOD: User input is sanitized before constructing the regex\n        string safeName = Regex.Escape(name);\n        new Regex(\"^\" + safeName + \"=.*$\").Match(userInput);\n    }\n}\n\n```\n\n## References\n* OWASP: [Regular expression Denial of Service - ReDoS](https://www.owasp.org/index.php/Regular_expression_Denial_of_Service_-_ReDoS).\n* Wikipedia: [ReDoS](https://en.wikipedia.org/wiki/ReDoS).\n* Common Weakness Enumeration: [CWE-730](https://cwe.mitre.org/data/definitions/730.html).\n* Common Weakness Enumeration: [CWE-400](https://cwe.mitre.org/data/definitions/400.html).\n"
                },
                "properties": {
                  "tags": [
                    "security",
                    "external/cwe/cwe-730",
                    "external/cwe/cwe-400"
                  ],
                  "description": "User input should not be used in regular expressions without first being escaped,\n              otherwise a malicious user may be able to provide a regex that could require\n              exponential time on certain inputs.",
                  "id": "cs/regex-injection",
                  "kind": "path-problem",
                  "name": "Regular expression injection",
                  "precision": "high",
                  "problem.severity": "error",
                  "security-severity": "7.5"
                }
              },
              {
                "id": "cs/redos",
                "name": "cs/redos",
                "shortDescription": {
                  "text": "Denial of Service from comparison of user input against expensive regex"
                },
                "fullDescription": {
                  "text": "User input should not be matched against a regular expression that could require exponential time on certain input."
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "error"
                },
                "help": {
                  "text": "# Denial of Service from comparison of user input against expensive regex\nMatching user input against a regular expression which takes exponential time in the worst case can allow a malicious user to perform a Denial of Service (\"DoS\") attack by crafting input that takes a long time to execute.\n\nMost regular expression engines, including the C\\# standard library implementation, are designed to work with an extended regular expression syntax. Although this provides flexibility for the user, it can prevent the engine from constructing an efficient implementation of the matcher in all circumstances. In particular, the \"worst case time complexity\" (see the references) of certain regular expressions may be \"exponential\". This would allow a malicious user to provide some input which causes the regular expression to take a very long time to execute.\n\nTypically, a regular expression is vulnerable to this attack if it applies repetition to a sub-expression which itself is repeated, or contains overlapping options. For example, `(a+)+` is vulnerable to a string such as `aaaaaaaaaaaaaaaaaaaaaaaaaaab`. More information about the precise circumstances can be found in the references.\n\n\n## Recommendation\nModify the regular expression to avoid the exponential worst case time. If this is not possible, then a timeout should be used to avoid a denial of service. For C\\# applications, a timeout can be provided to the `Regex` constructor. Alternatively, apply a global timeout by setting the `REGEX_DEFAULT_MATCH_TIMEOUT` application domain property, using the `AppDomain.SetData` method.\n\n\n## Example\nThe following example shows a HTTP request parameter that is matched against a regular expression which has exponential worst case performance. In the first case, it is matched without a timeout, which can lead to a denial of service. In the second case, a timeout is used to cancel the evaluation of the regular expression after 1 second.\n\n\n```csharp\nusing System;\nusing System.Web;\nusing System.Text.RegularExpressions;\n\npublic class ReDoSHandler : IHttpHandler\n{\n\n    public void ProcessRequest(HttpContext ctx)\n    {\n        string userInput = ctx.Request.QueryString[\"userInput\"];\n\n        // BAD: User input is matched against a regex with exponential worst case behavior\n        new Regex(\"^([a-z]*)*$\").Match(userInput);\n\n        // GOOD: Regex is given a timeout to avoid DoS\n        new Regex(\"^([a-z]*)*$\",\n                  RegexOptions.IgnoreCase,\n                  TimeSpan.FromSeconds(1)).Match(userInput);\n    }\n}\n\n```\n\n## References\n* OWASP: [Regular expression Denial of Service - ReDoS](https://www.owasp.org/index.php/Regular_expression_Denial_of_Service_-_ReDoS).\n* Wikipedia: [ReDoS](https://en.wikipedia.org/wiki/ReDoS).\n* Wikipedia: [Time complexity](https://en.wikipedia.org/wiki/Time_complexity).\n* Common Weakness Enumeration: [CWE-1333](https://cwe.mitre.org/data/definitions/1333.html).\n* Common Weakness Enumeration: [CWE-730](https://cwe.mitre.org/data/definitions/730.html).\n* Common Weakness Enumeration: [CWE-400](https://cwe.mitre.org/data/definitions/400.html).\n",
                  "markdown": "# Denial of Service from comparison of user input against expensive regex\nMatching user input against a regular expression which takes exponential time in the worst case can allow a malicious user to perform a Denial of Service (\"DoS\") attack by crafting input that takes a long time to execute.\n\nMost regular expression engines, including the C\\# standard library implementation, are designed to work with an extended regular expression syntax. Although this provides flexibility for the user, it can prevent the engine from constructing an efficient implementation of the matcher in all circumstances. In particular, the \"worst case time complexity\" (see the references) of certain regular expressions may be \"exponential\". This would allow a malicious user to provide some input which causes the regular expression to take a very long time to execute.\n\nTypically, a regular expression is vulnerable to this attack if it applies repetition to a sub-expression which itself is repeated, or contains overlapping options. For example, `(a+)+` is vulnerable to a string such as `aaaaaaaaaaaaaaaaaaaaaaaaaaab`. More information about the precise circumstances can be found in the references.\n\n\n## Recommendation\nModify the regular expression to avoid the exponential worst case time. If this is not possible, then a timeout should be used to avoid a denial of service. For C\\# applications, a timeout can be provided to the `Regex` constructor. Alternatively, apply a global timeout by setting the `REGEX_DEFAULT_MATCH_TIMEOUT` application domain property, using the `AppDomain.SetData` method.\n\n\n## Example\nThe following example shows a HTTP request parameter that is matched against a regular expression which has exponential worst case performance. In the first case, it is matched without a timeout, which can lead to a denial of service. In the second case, a timeout is used to cancel the evaluation of the regular expression after 1 second.\n\n\n```csharp\nusing System;\nusing System.Web;\nusing System.Text.RegularExpressions;\n\npublic class ReDoSHandler : IHttpHandler\n{\n\n    public void ProcessRequest(HttpContext ctx)\n    {\n        string userInput = ctx.Request.QueryString[\"userInput\"];\n\n        // BAD: User input is matched against a regex with exponential worst case behavior\n        new Regex(\"^([a-z]*)*$\").Match(userInput);\n\n        // GOOD: Regex is given a timeout to avoid DoS\n        new Regex(\"^([a-z]*)*$\",\n                  RegexOptions.IgnoreCase,\n                  TimeSpan.FromSeconds(1)).Match(userInput);\n    }\n}\n\n```\n\n## References\n* OWASP: [Regular expression Denial of Service - ReDoS](https://www.owasp.org/index.php/Regular_expression_Denial_of_Service_-_ReDoS).\n* Wikipedia: [ReDoS](https://en.wikipedia.org/wiki/ReDoS).\n* Wikipedia: [Time complexity](https://en.wikipedia.org/wiki/Time_complexity).\n* Common Weakness Enumeration: [CWE-1333](https://cwe.mitre.org/data/definitions/1333.html).\n* Common Weakness Enumeration: [CWE-730](https://cwe.mitre.org/data/definitions/730.html).\n* Common Weakness Enumeration: [CWE-400](https://cwe.mitre.org/data/definitions/400.html).\n"
                },
                "properties": {
                  "tags": [
                    "security",
                    "external/cwe/cwe-1333",
                    "external/cwe/cwe-730",
                    "external/cwe/cwe-400"
                  ],
                  "description": "User input should not be matched against a regular expression that could require\n              exponential time on certain input.",
                  "id": "cs/redos",
                  "kind": "path-problem",
                  "name": "Denial of Service from comparison of user input against expensive regex",
                  "precision": "high",
                  "problem.severity": "error",
                  "security-severity": "7.5"
                }
              },
              {
                "id": "cs/insufficient-key-size",
                "name": "cs/insufficient-key-size",
                "shortDescription": {
                  "text": "Weak encryption: Insufficient key size"
                },
                "fullDescription": {
                  "text": "Finds uses of encryption algorithms with too small a key size"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning"
                },
                "help": {
                  "text": "# Weak encryption: Insufficient key size\nThis rule finds uses of encryption algorithms with too small a key size. Encryption algorithms are vulnerable to brute force attack when too small a key size is used.\n\n\n## Recommendation\nThe key should be at least 2048-bit long when using RSA encryption, and 128-bit long when using symmetric encryption.\n\n\n## References\n* Wikipedia. [Key size](http://en.wikipedia.org/wiki/Key_size).\n* Common Weakness Enumeration: [CWE-326](https://cwe.mitre.org/data/definitions/326.html).\n",
                  "markdown": "# Weak encryption: Insufficient key size\nThis rule finds uses of encryption algorithms with too small a key size. Encryption algorithms are vulnerable to brute force attack when too small a key size is used.\n\n\n## Recommendation\nThe key should be at least 2048-bit long when using RSA encryption, and 128-bit long when using symmetric encryption.\n\n\n## References\n* Wikipedia. [Key size](http://en.wikipedia.org/wiki/Key_size).\n* Common Weakness Enumeration: [CWE-326](https://cwe.mitre.org/data/definitions/326.html).\n"
                },
                "properties": {
                  "tags": [
                    "security",
                    "external/cwe/cwe-326"
                  ],
                  "description": "Finds uses of encryption algorithms with too small a key size",
                  "id": "cs/insufficient-key-size",
                  "kind": "problem",
                  "name": "Weak encryption: Insufficient key size",
                  "precision": "high",
                  "problem.severity": "warning",
                  "security-severity": "7.5"
                }
              },
              {
                "id": "cs/hardcoded-key",
                "name": "cs/hardcoded-key",
                "shortDescription": {
                  "text": "Hard-coded encryption key"
                },
                "fullDescription": {
                  "text": "The .Key property or rgbKey parameter of a SymmetricAlgorithm should never be a hard-coded value."
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "error"
                },
                "properties": {
                  "tags": [
                    "security",
                    "external/cwe/cwe-320"
                  ],
                  "description": "The .Key property or rgbKey parameter of a SymmetricAlgorithm should never be a hard-coded value.",
                  "id": "cs/hardcoded-key",
                  "kind": "path-problem",
                  "name": "Hard-coded encryption key",
                  "problem.severity": "error",
                  "security-severity": "8.1"
                }
              },
              {
                "id": "cs/hard-coded-symmetric-encryption-key",
                "name": "cs/hard-coded-symmetric-encryption-key",
                "shortDescription": {
                  "text": "Hard-coded symmetric encryption key"
                },
                "fullDescription": {
                  "text": "The .Key property or rgbKey parameter of a SymmetricAlgorithm should never be a hardcoded value."
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "error"
                },
                "properties": {
                  "tags": [
                    "security",
                    "external/cwe/cwe-321"
                  ],
                  "description": "The .Key property or rgbKey parameter of a SymmetricAlgorithm should never be a hardcoded value.",
                  "id": "cs/hard-coded-symmetric-encryption-key",
                  "kind": "path-problem",
                  "name": "Hard-coded symmetric encryption key",
                  "problem.severity": "error",
                  "security-severity": "7.5"
                }
              },
              {
                "id": "cs/xml/missing-validation",
                "name": "cs/xml/missing-validation",
                "shortDescription": {
                  "text": "Missing XML validation"
                },
                "fullDescription": {
                  "text": "User input should not be processed as XML without validating it against a known schema."
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note"
                },
                "help": {
                  "text": "# Missing XML validation\nIf unsanitized user input is processed as XML, it should be validated against a known schema. If no validation occurs, or if the validation relies on the schema or DTD specified in the document itself, then the XML document may contain any data in any form, which may invalidate assumptions the program later makes.\n\n\n## Recommendation\nAll XML provided by a user should be validated against a known schema when it is processed.\n\nIf using `XmlReader.Create`, you should always pass an instance of `XmlReaderSettings`, with the following properties:\n\n* `ValidationType` must be set to `Schema`. If this property is unset, no validation occurs. If it is set to `DTD`, the document is only validated against the DTD specified in the user-provided document itself - which could be specified as anything by a malicious user.\n* `ValidationFlags` must not include `ProcessInlineSchema` or `ProcessSchemaLocation`. These flags allow a user to provide their own inline schema or schema location for validation, allowing a malicious user to bypass the known schema validation.\n\n## Example\nIn the following example, text provided by a user is loaded using `XmlReader.Create`. In the first three examples, insufficient validation occurs, because either no validation is specified, or validation is only specified against a DTD provided by the user, or the validation permits a user to provide an inline schema. In the final example, a known schema is provided, and validation is set, using an instance of `XmlReaderSettings`. This ensures that the user input is properly validated against the known schema.\n\n\n```csharp\nusing System;\nusing System.IO;\nusing System.Web;\nusing System.Xml;\nusing System.Xml.Schema;\n\npublic class MissingXmlValidationHandler : IHttpHandler\n{\n\n    public void ProcessRequest(HttpContext ctx)\n    {\n        String userProvidedXml = ctx.Request.QueryString[\"userProvidedXml\"];\n\n        // BAD: User provided XML is processed without any validation,\n        //      because there is no settings instance configured.\n        XmlReader.Create(new StringReader(userProvidedXml));\n\n        // BAD: User provided XML is processed without any validation,\n        //      because the settings instance specifies DTD as the ValidationType\n        XmlReaderSettings badSettings = new XmlReaderSettings();\n        badSettings.ValidationType = ValidationType.DTD;\n        XmlReader.Create(new StringReader(userProvidedXml), badSettings);\n\n        // BAD: User provided XML is processed with validation, but the ProcessInlineSchema\n        //      option is specified, so an attacker can provide their own schema to validate\n        //      against.\n        XmlReaderSettings badInlineSettings = new XmlReaderSettings();\n        badInlineSettings.ValidationType = ValidationType.Schema;\n        badInlineSettings.ValidationFlags |= XmlSchemaValidationFlags.ProcessInlineSchema;\n        XmlReader.Create(new StringReader(userProvidedXml), badInlineSettings);\n\n        // GOOD: User provided XML is processed with validation\n        XmlReaderSettings goodSettings = new XmlReaderSettings();\n        goodSettings.ValidationType = ValidationType.Schema;\n        goodSettings.Schemas = new XmlSchemaSet() { { \"urn:my-schema\", \"my.xsd\" } };\n        XmlReader.Create(new StringReader(userProvidedXml), goodSettings);\n    }\n}\n\n```\n\n## References\n* Microsoft: [XML Schema (XSD) Validation with XmlSchemaSet](https://msdn.microsoft.com/en-us/library/3740e0b5(v=vs.110).aspx).\n* Common Weakness Enumeration: [CWE-112](https://cwe.mitre.org/data/definitions/112.html).\n",
                  "markdown": "# Missing XML validation\nIf unsanitized user input is processed as XML, it should be validated against a known schema. If no validation occurs, or if the validation relies on the schema or DTD specified in the document itself, then the XML document may contain any data in any form, which may invalidate assumptions the program later makes.\n\n\n## Recommendation\nAll XML provided by a user should be validated against a known schema when it is processed.\n\nIf using `XmlReader.Create`, you should always pass an instance of `XmlReaderSettings`, with the following properties:\n\n* `ValidationType` must be set to `Schema`. If this property is unset, no validation occurs. If it is set to `DTD`, the document is only validated against the DTD specified in the user-provided document itself - which could be specified as anything by a malicious user.\n* `ValidationFlags` must not include `ProcessInlineSchema` or `ProcessSchemaLocation`. These flags allow a user to provide their own inline schema or schema location for validation, allowing a malicious user to bypass the known schema validation.\n\n## Example\nIn the following example, text provided by a user is loaded using `XmlReader.Create`. In the first three examples, insufficient validation occurs, because either no validation is specified, or validation is only specified against a DTD provided by the user, or the validation permits a user to provide an inline schema. In the final example, a known schema is provided, and validation is set, using an instance of `XmlReaderSettings`. This ensures that the user input is properly validated against the known schema.\n\n\n```csharp\nusing System;\nusing System.IO;\nusing System.Web;\nusing System.Xml;\nusing System.Xml.Schema;\n\npublic class MissingXmlValidationHandler : IHttpHandler\n{\n\n    public void ProcessRequest(HttpContext ctx)\n    {\n        String userProvidedXml = ctx.Request.QueryString[\"userProvidedXml\"];\n\n        // BAD: User provided XML is processed without any validation,\n        //      because there is no settings instance configured.\n        XmlReader.Create(new StringReader(userProvidedXml));\n\n        // BAD: User provided XML is processed without any validation,\n        //      because the settings instance specifies DTD as the ValidationType\n        XmlReaderSettings badSettings = new XmlReaderSettings();\n        badSettings.ValidationType = ValidationType.DTD;\n        XmlReader.Create(new StringReader(userProvidedXml), badSettings);\n\n        // BAD: User provided XML is processed with validation, but the ProcessInlineSchema\n        //      option is specified, so an attacker can provide their own schema to validate\n        //      against.\n        XmlReaderSettings badInlineSettings = new XmlReaderSettings();\n        badInlineSettings.ValidationType = ValidationType.Schema;\n        badInlineSettings.ValidationFlags |= XmlSchemaValidationFlags.ProcessInlineSchema;\n        XmlReader.Create(new StringReader(userProvidedXml), badInlineSettings);\n\n        // GOOD: User provided XML is processed with validation\n        XmlReaderSettings goodSettings = new XmlReaderSettings();\n        goodSettings.ValidationType = ValidationType.Schema;\n        goodSettings.Schemas = new XmlSchemaSet() { { \"urn:my-schema\", \"my.xsd\" } };\n        XmlReader.Create(new StringReader(userProvidedXml), goodSettings);\n    }\n}\n\n```\n\n## References\n* Microsoft: [XML Schema (XSD) Validation with XmlSchemaSet](https://msdn.microsoft.com/en-us/library/3740e0b5(v=vs.110).aspx).\n* Common Weakness Enumeration: [CWE-112](https://cwe.mitre.org/data/definitions/112.html).\n"
                },
                "properties": {
                  "tags": [
                    "security",
                    "external/cwe/cwe-112"
                  ],
                  "description": "User input should not be processed as XML without validating it against a known\n              schema.",
                  "id": "cs/xml/missing-validation",
                  "kind": "path-problem",
                  "name": "Missing XML validation",
                  "precision": "high",
                  "problem.severity": "recommendation",
                  "security-severity": "4.3"
                }
              },
              {
                "id": "cs/user-controlled-bypass",
                "name": "cs/user-controlled-bypass",
                "shortDescription": {
                  "text": "User-controlled bypass of sensitive method"
                },
                "fullDescription": {
                  "text": "User-controlled bypassing of sensitive methods may allow attackers to avoid passing through authentication systems."
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "error"
                },
                "help": {
                  "text": "# User-controlled bypass of sensitive method\nMany C\\# constructs enable code statements to be executed conditionally, for example, `if` statements and `for` statements. If the statements contain important authentication or login code, and user-controlled data determines whether or not the code is executed, an attacker may be able to bypass security systems.\n\n\n## Recommendation\nNever decide whether to authenticate a user based on data that may be controlled by that user. If necessary, ensure that the data is validated extensively when it is input before any authentication checks are performed.\n\nIt is still possible to have a system that \"remembers\" users, thus not requiring the user to login on every interaction. For example, personalization settings can be applied without authentication because this is not sensitive information. However, users should be allowed to take sensitive actions only when they have been fully authenticated.\n\n\n## Example\nThis example shows two ways of deciding whether to authenticate a user. The first way shows a decision that is based on the value of a cookie. Cookies can be easily controlled by the user, and so this allows a user to become authenticated without providing valid credentials. The second, more secure way shows a decision that is based on looking up the user in a security database.\n\n\n```csharp\npublic boolean doLogin(HttpCookie adminCookie, String user, String password)\n{\n\n    // BAD: login is executed only if the value of 'adminCookie' is 'false',\n    // but 'adminCookie' is controlled by the user\n    if (adminCookie.Value == \"false\")\n        return login(user, password);\n\n    return true;\n}\n\npublic boolean doLogin(HttpCookie adminCookie, String user, String password)\n{\n    // GOOD: use server-side information based on the credentials to decide\n    // whether user has privileges\n    bool isAdmin = queryDbForAdminStatus(user, password);\n    if (!isAdmin)\n        return login(user, password);\n\n    return true;\n}\n\n```\n\n## References\n* Common Weakness Enumeration: [CWE-807](https://cwe.mitre.org/data/definitions/807.html).\n* Common Weakness Enumeration: [CWE-247](https://cwe.mitre.org/data/definitions/247.html).\n* Common Weakness Enumeration: [CWE-350](https://cwe.mitre.org/data/definitions/350.html).\n",
                  "markdown": "# User-controlled bypass of sensitive method\nMany C\\# constructs enable code statements to be executed conditionally, for example, `if` statements and `for` statements. If the statements contain important authentication or login code, and user-controlled data determines whether or not the code is executed, an attacker may be able to bypass security systems.\n\n\n## Recommendation\nNever decide whether to authenticate a user based on data that may be controlled by that user. If necessary, ensure that the data is validated extensively when it is input before any authentication checks are performed.\n\nIt is still possible to have a system that \"remembers\" users, thus not requiring the user to login on every interaction. For example, personalization settings can be applied without authentication because this is not sensitive information. However, users should be allowed to take sensitive actions only when they have been fully authenticated.\n\n\n## Example\nThis example shows two ways of deciding whether to authenticate a user. The first way shows a decision that is based on the value of a cookie. Cookies can be easily controlled by the user, and so this allows a user to become authenticated without providing valid credentials. The second, more secure way shows a decision that is based on looking up the user in a security database.\n\n\n```csharp\npublic boolean doLogin(HttpCookie adminCookie, String user, String password)\n{\n\n    // BAD: login is executed only if the value of 'adminCookie' is 'false',\n    // but 'adminCookie' is controlled by the user\n    if (adminCookie.Value == \"false\")\n        return login(user, password);\n\n    return true;\n}\n\npublic boolean doLogin(HttpCookie adminCookie, String user, String password)\n{\n    // GOOD: use server-side information based on the credentials to decide\n    // whether user has privileges\n    bool isAdmin = queryDbForAdminStatus(user, password);\n    if (!isAdmin)\n        return login(user, password);\n\n    return true;\n}\n\n```\n\n## References\n* Common Weakness Enumeration: [CWE-807](https://cwe.mitre.org/data/definitions/807.html).\n* Common Weakness Enumeration: [CWE-247](https://cwe.mitre.org/data/definitions/247.html).\n* Common Weakness Enumeration: [CWE-350](https://cwe.mitre.org/data/definitions/350.html).\n"
                },
                "properties": {
                  "tags": [
                    "security",
                    "external/cwe/cwe-807",
                    "external/cwe/cwe-247",
                    "external/cwe/cwe-350"
                  ],
                  "description": "User-controlled bypassing of sensitive methods may allow attackers to avoid\n              passing through authentication systems.",
                  "id": "cs/user-controlled-bypass",
                  "kind": "path-problem",
                  "name": "User-controlled bypass of sensitive method",
                  "precision": "high",
                  "problem.severity": "error",
                  "security-severity": "7.5"
                }
              },
              {
                "id": "cs/web/broad-cookie-domain",
                "name": "cs/web/broad-cookie-domain",
                "shortDescription": {
                  "text": "Cookie security: overly broad domain"
                },
                "fullDescription": {
                  "text": "Finds cookies with an overly broad domain."
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning"
                },
                "help": {
                  "text": "# Cookie security: overly broad domain\nThis rule finds cookies with an overly broad domain. Cookies with an overly broad domain, such as \".mybank.com\", can be accessed by all web applications deployed on this domain and its sub-domains. A cookie with sensitive data, but with too broad a domain, could hence be read and tampered with by a less secure and untrusted application.\n\n\n## Recommendation\nPrecisely define the domain of the web application for which this cookie is valid.\n\n\n## Example\nIn this example `cookie1` is accessible from online-bank.com. `cookie2` is accessible from ebanking.online-bank.com and any subdomains of ebanking.online-bank.com.\n\n\n```csharp\nclass CookieWithOverlyBroadDomain\n{\n    static public void AddCookie()\n    {\n        HttpCookie cookie1 = new HttpCookie(\"sessionID\");\n        cookie1.Domain = \"online-bank.com\";\n\n        HttpCookie cookie2 = new HttpCookie(\"sessionID\");\n        cookie2.Domain = \".ebanking.online-bank.com\";\n    }\n}\n\n```\nIn the following example `cookie` is only accessible from ebanking.online-bank.com which is much more secure.\n\n\n```csharp\nclass CookieWithOverlyBroadDomainFix\n{\n    static public void AddCookie()\n    {\n        HttpCookie cookie = new HttpCookie(\"sessionID\");\n        cookie.Domain = \"ebanking.online-bank.com\";\n    }\n}\n\n```\n\n## References\n* MSDN: [HttpCookie.Domain Property](http://msdn.microsoft.com/en-us/library/system.web.httpcookie.domain.aspx).\n* Common Weakness Enumeration: [CWE-287](https://cwe.mitre.org/data/definitions/287.html).\n",
                  "markdown": "# Cookie security: overly broad domain\nThis rule finds cookies with an overly broad domain. Cookies with an overly broad domain, such as \".mybank.com\", can be accessed by all web applications deployed on this domain and its sub-domains. A cookie with sensitive data, but with too broad a domain, could hence be read and tampered with by a less secure and untrusted application.\n\n\n## Recommendation\nPrecisely define the domain of the web application for which this cookie is valid.\n\n\n## Example\nIn this example `cookie1` is accessible from online-bank.com. `cookie2` is accessible from ebanking.online-bank.com and any subdomains of ebanking.online-bank.com.\n\n\n```csharp\nclass CookieWithOverlyBroadDomain\n{\n    static public void AddCookie()\n    {\n        HttpCookie cookie1 = new HttpCookie(\"sessionID\");\n        cookie1.Domain = \"online-bank.com\";\n\n        HttpCookie cookie2 = new HttpCookie(\"sessionID\");\n        cookie2.Domain = \".ebanking.online-bank.com\";\n    }\n}\n\n```\nIn the following example `cookie` is only accessible from ebanking.online-bank.com which is much more secure.\n\n\n```csharp\nclass CookieWithOverlyBroadDomainFix\n{\n    static public void AddCookie()\n    {\n        HttpCookie cookie = new HttpCookie(\"sessionID\");\n        cookie.Domain = \"ebanking.online-bank.com\";\n    }\n}\n\n```\n\n## References\n* MSDN: [HttpCookie.Domain Property](http://msdn.microsoft.com/en-us/library/system.web.httpcookie.domain.aspx).\n* Common Weakness Enumeration: [CWE-287](https://cwe.mitre.org/data/definitions/287.html).\n"
                },
                "properties": {
                  "tags": [
                    "security",
                    "external/cwe/cwe-287"
                  ],
                  "description": "Finds cookies with an overly broad domain.",
                  "id": "cs/web/broad-cookie-domain",
                  "kind": "problem",
                  "name": "Cookie security: overly broad domain",
                  "precision": "high",
                  "problem.severity": "warning",
                  "security-severity": "9.3"
                }
              },
              {
                "id": "cs/exposure-of-sensitive-information",
                "name": "cs/exposure-of-sensitive-information",
                "shortDescription": {
                  "text": "Exposure of private information"
                },
                "fullDescription": {
                  "text": "If private information is written to an external location, it may be accessible by unauthorized persons."
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "error"
                },
                "help": {
                  "text": "# Exposure of private information\nPrivate information that is stored in an external location may be more vulnerable because that location may not be protected by the same access controls as other parts of the system.\n\nExamples include log files, cookies and plain text storage on disk.\n\n\n## Recommendation\nEnsure that private information is only stored in secure data locations.\n\n\n## Example\nThe following example shows some private data - an address - being passed to a HTTP handler. This private information is then stored in a log file. This log file on disk may be accessible to users that do not normally have access to this private data.\n\n\n```csharp\nusing System.Text;\nusing System.Web;\nusing System.Web.Security;\n\npublic class PrivateInformationHandler : IHttpHandler\n{\n\n    public void ProcessRequest(HttpContext ctx)\n    {\n        string address = ctx.Request.QueryString[\"Address1\"];\n        logger.Info(\"User has address: \" + address);\n    }\n}\n\n```\n\n## References\n* Common Weakness Enumeration: [CWE-359](https://cwe.mitre.org/data/definitions/359.html).\n",
                  "markdown": "# Exposure of private information\nPrivate information that is stored in an external location may be more vulnerable because that location may not be protected by the same access controls as other parts of the system.\n\nExamples include log files, cookies and plain text storage on disk.\n\n\n## Recommendation\nEnsure that private information is only stored in secure data locations.\n\n\n## Example\nThe following example shows some private data - an address - being passed to a HTTP handler. This private information is then stored in a log file. This log file on disk may be accessible to users that do not normally have access to this private data.\n\n\n```csharp\nusing System.Text;\nusing System.Web;\nusing System.Web.Security;\n\npublic class PrivateInformationHandler : IHttpHandler\n{\n\n    public void ProcessRequest(HttpContext ctx)\n    {\n        string address = ctx.Request.QueryString[\"Address1\"];\n        logger.Info(\"User has address: \" + address);\n    }\n}\n\n```\n\n## References\n* Common Weakness Enumeration: [CWE-359](https://cwe.mitre.org/data/definitions/359.html).\n"
                },
                "properties": {
                  "tags": [
                    "security",
                    "external/cwe/cwe-359"
                  ],
                  "description": "If private information is written to an external location, it may be accessible by\n              unauthorized persons.",
                  "id": "cs/exposure-of-sensitive-information",
                  "kind": "path-problem",
                  "name": "Exposure of private information",
                  "precision": "high",
                  "problem.severity": "error",
                  "security-severity": "6.5"
                }
              },
              {
                "id": "cs/information-exposure-through-exception",
                "name": "cs/information-exposure-through-exception",
                "shortDescription": {
                  "text": "Information exposure through an exception"
                },
                "fullDescription": {
                  "text": "Leaking information about an exception, such as messages and stack traces, to an external user can expose implementation details that are useful to an attacker for developing a subsequent exploit."
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "error"
                },
                "help": {
                  "text": "# Information exposure through an exception\nSoftware developers often add stack traces to error messages, as a debugging aid. Whenever that error message occurs for an end user, the developer can use the stack trace to help identify how to fix the problem. In particular, stack traces can tell the developer more about the sequence of events that led to a failure, as opposed to merely the final state of the software when the error occurred.\n\nUnfortunately, the same information can be useful to an attacker. The sequence of class names in a stack trace can reveal the structure of the application as well as any internal components it relies on. Furthermore, the error message at the top of a stack trace can include information such as server-side file names and SQL code that the application relies on, allowing an attacker to fine-tune a subsequent injection attack.\n\n\n## Recommendation\nSend the user a more generic error message that reveals less information. Either suppress the stack trace entirely, or log it only on the server.\n\n\n## Example\nIn the following example, an exception is handled in two different ways. In the first version, labeled BAD, the exception is sent back to the remote user by calling `ToString()`, and writing it to the response. As such, the user is able to see a detailed stack trace, which may contain sensitive information. In the second version, the error message is logged only on the server. That way, the developers can still access and use the error log, but remote users will not see the information.\n\n\n```csharp\nusing System;\nusing System.Web;\n\npublic class StackTraceHandler : IHttpHandler\n{\n\n    public void ProcessRequest(HttpContext ctx)\n    {\n        try\n        {\n            doSomeWork();\n        }\n        catch (Exception ex)\n        {\n            // BAD: printing a stack trace back to the response\n            ctx.Response.Write(ex.ToString());\n            return;\n        }\n\n        try\n        {\n            doSomeWork();\n        }\n        catch (Exception ex)\n        {\n            // GOOD: log the stack trace, and send back a non-revealing response\n            log(\"Exception occurred\", ex);\n            ctx.Response.Write(\"Exception occurred\");\n            return;\n        }\n    }\n}\n\n```\n",
                  "markdown": "# Information exposure through an exception\nSoftware developers often add stack traces to error messages, as a debugging aid. Whenever that error message occurs for an end user, the developer can use the stack trace to help identify how to fix the problem. In particular, stack traces can tell the developer more about the sequence of events that led to a failure, as opposed to merely the final state of the software when the error occurred.\n\nUnfortunately, the same information can be useful to an attacker. The sequence of class names in a stack trace can reveal the structure of the application as well as any internal components it relies on. Furthermore, the error message at the top of a stack trace can include information such as server-side file names and SQL code that the application relies on, allowing an attacker to fine-tune a subsequent injection attack.\n\n\n## Recommendation\nSend the user a more generic error message that reveals less information. Either suppress the stack trace entirely, or log it only on the server.\n\n\n## Example\nIn the following example, an exception is handled in two different ways. In the first version, labeled BAD, the exception is sent back to the remote user by calling `ToString()`, and writing it to the response. As such, the user is able to see a detailed stack trace, which may contain sensitive information. In the second version, the error message is logged only on the server. That way, the developers can still access and use the error log, but remote users will not see the information.\n\n\n```csharp\nusing System;\nusing System.Web;\n\npublic class StackTraceHandler : IHttpHandler\n{\n\n    public void ProcessRequest(HttpContext ctx)\n    {\n        try\n        {\n            doSomeWork();\n        }\n        catch (Exception ex)\n        {\n            // BAD: printing a stack trace back to the response\n            ctx.Response.Write(ex.ToString());\n            return;\n        }\n\n        try\n        {\n            doSomeWork();\n        }\n        catch (Exception ex)\n        {\n            // GOOD: log the stack trace, and send back a non-revealing response\n            log(\"Exception occurred\", ex);\n            ctx.Response.Write(\"Exception occurred\");\n            return;\n        }\n    }\n}\n\n```\n"
                },
                "properties": {
                  "tags": [
                    "security",
                    "external/cwe/cwe-209",
                    "external/cwe/cwe-497"
                  ],
                  "description": "Leaking information about an exception, such as messages and stack traces, to an\n              external user can expose implementation details that are useful to an attacker for\n              developing a subsequent exploit.",
                  "id": "cs/information-exposure-through-exception",
                  "kind": "path-problem",
                  "name": "Information exposure through an exception",
                  "precision": "high",
                  "problem.severity": "error",
                  "security-severity": "5.4"
                }
              },
              {
                "id": "cs/web/missing-token-validation",
                "name": "cs/web/missing-token-validation",
                "shortDescription": {
                  "text": "Missing cross-site request forgery token validation"
                },
                "fullDescription": {
                  "text": "Handling a POST request without verifying that the request came from the user allows a malicious attacker to submit a request on behalf of the user."
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "error"
                },
                "help": {
                  "text": "# Missing cross-site request forgery token validation\nWeb applications that use tokens to prevent cross-site request forgery (CSRF) should validate the tokens for all Http POST requests.\n\nAlthough login and authentication methods are not vulnerable to traditional CSRF attacks, they still need to be protected with a token or other mitigation. This because an unprotected login page can be used by an attacker to force a login using an account controlled by the attacker. Subsequent requests to the site are then made using this account, without the user being aware that this is the case. This can result in the user associating private information with the attacker-controlled account.\n\n\n## Recommendation\nThe appropriate attribute should be added to this method to ensure the anti-forgery token is validated when this action method is called. If using the MVC-provided anti-forgery framework this will be the `[ValidateAntiForgeryToken]` attribute.\n\nAlternatively, you may consider including a global filter that applies token validation to all POST requests.\n\n\n## Example\nIn the following example an ASP.NET MVC `Controller` is using the `[ValidateAntiForgeryToken]` attribute to mitigate against CSRF attacks. It has been applied correctly to the `UpdateDetails` method. However, this attribute has not been applied to the `Login` method. This should be fixed by adding this attribute.\n\n\n```csharp\nusing System.Web.Mvc;\n\npublic class HomeController : Controller\n{\n    // BAD: Anti forgery token has been forgotten\n    [HttpPost]\n    public ActionResult Login()\n    {\n        return View();\n    }\n\n    // GOOD: Anti forgery token is validated\n    [HttpPost]\n    [ValidateAntiForgeryToken]\n    public ActionResult UpdateDetails()\n    {\n        return View();\n    }\n}\n\n```\n\n## References\n* Wikipedia: [Cross-Site Request Forgery](https://en.wikipedia.org/wiki/Cross-site_request_forgery).\n* Microsoft Docs: [XSRF/CSRF Prevention in ASP.NET MVC and Web Pages](https://docs.microsoft.com/en-us/aspnet/mvc/overview/security/xsrfcsrf-prevention-in-aspnet-mvc-and-web-pages).\n* Common Weakness Enumeration: [CWE-352](https://cwe.mitre.org/data/definitions/352.html).\n",
                  "markdown": "# Missing cross-site request forgery token validation\nWeb applications that use tokens to prevent cross-site request forgery (CSRF) should validate the tokens for all Http POST requests.\n\nAlthough login and authentication methods are not vulnerable to traditional CSRF attacks, they still need to be protected with a token or other mitigation. This because an unprotected login page can be used by an attacker to force a login using an account controlled by the attacker. Subsequent requests to the site are then made using this account, without the user being aware that this is the case. This can result in the user associating private information with the attacker-controlled account.\n\n\n## Recommendation\nThe appropriate attribute should be added to this method to ensure the anti-forgery token is validated when this action method is called. If using the MVC-provided anti-forgery framework this will be the `[ValidateAntiForgeryToken]` attribute.\n\nAlternatively, you may consider including a global filter that applies token validation to all POST requests.\n\n\n## Example\nIn the following example an ASP.NET MVC `Controller` is using the `[ValidateAntiForgeryToken]` attribute to mitigate against CSRF attacks. It has been applied correctly to the `UpdateDetails` method. However, this attribute has not been applied to the `Login` method. This should be fixed by adding this attribute.\n\n\n```csharp\nusing System.Web.Mvc;\n\npublic class HomeController : Controller\n{\n    // BAD: Anti forgery token has been forgotten\n    [HttpPost]\n    public ActionResult Login()\n    {\n        return View();\n    }\n\n    // GOOD: Anti forgery token is validated\n    [HttpPost]\n    [ValidateAntiForgeryToken]\n    public ActionResult UpdateDetails()\n    {\n        return View();\n    }\n}\n\n```\n\n## References\n* Wikipedia: [Cross-Site Request Forgery](https://en.wikipedia.org/wiki/Cross-site_request_forgery).\n* Microsoft Docs: [XSRF/CSRF Prevention in ASP.NET MVC and Web Pages](https://docs.microsoft.com/en-us/aspnet/mvc/overview/security/xsrfcsrf-prevention-in-aspnet-mvc-and-web-pages).\n* Common Weakness Enumeration: [CWE-352](https://cwe.mitre.org/data/definitions/352.html).\n"
                },
                "properties": {
                  "tags": [
                    "security",
                    "external/cwe/cwe-352"
                  ],
                  "description": "Handling a POST request without verifying that the request came from the user\n              allows a malicious attacker to submit a request on behalf of the user.",
                  "id": "cs/web/missing-token-validation",
                  "kind": "problem",
                  "name": "Missing cross-site request forgery token validation",
                  "precision": "high",
                  "problem.severity": "error",
                  "security-severity": "8.8"
                }
              },
              {
                "id": "cs/xml/xpath-injection",
                "name": "cs/xml/xpath-injection",
                "shortDescription": {
                  "text": "XPath injection"
                },
                "fullDescription": {
                  "text": "Building an XPath expression from user-controlled sources is vulnerable to insertion of malicious code by the user."
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "error"
                },
                "help": {
                  "text": "# XPath injection\nIf an XPath expression is built using string concatenation, and the components of the concatenation include user input, a user is likely to be able to create a malicious XPath expression.\n\n\n## Recommendation\nIf user input must be included in an XPath expression, pre-compile the query and use variable references to include the user input.\n\nWhen using the `System.Xml.XPath` API, this can be done by creating a custom subtype of `System.Xml.Xsl.XsltContext`, and implementing `ResolveVariable(String,String)` to return the user provided data. This custom context can be specified for a given `XPathExpression` using `XPathExpression.SetContext()`. For more details, see the \"User Defined Functions and Variables\" webpage in the list of references.\n\n\n## Example\nIn the first example, the code accepts a user name specified by the user, and uses this unvalidated and unsanitized value in an XPath expression. This is vulnerable to the user providing special characters or string sequences that change the meaning of the XPath expression to search for different values.\n\nIn the second example, the XPath expression is a hard-coded string that specifies some variables, which are safely replaced at runtime using a custom `XsltContext` that looks up the variables in an `XsltArgumentList`.\n\n\n```csharp\nusing System;\nusing System.Web;\nusing System.Xml.XPath;\n\npublic class XPathInjectionHandler : IHttpHandler\n{\n    public void ProcessRequest(HttpContext ctx)\n    {\n        string userName = ctx.Request.QueryString[\"userName\"];\n\n        // BAD: Use user-provided data directly in an XPath expression\n        string badXPathExpr = \"//users/user[login/text()='\" + userName + \"']/home_dir/text()\";\n        XPathExpression.Compile(badXPathExpr);\n\n        // GOOD: XPath expression uses variables to refer to parameters\n        string xpathExpression = \"//users/user[login/text()=$username]/home_dir/text()\";\n        XPathExpression xpath = XPathExpression.Compile(xpathExpression);\n\n        // Arguments are provided as a XsltArgumentList()\n        XsltArgumentList varList = new XsltArgumentList();\n        varList.AddParam(\"userName\", string.Empty, userName);\n\n        // CustomContext is an application specific class, that looks up variables in the\n        // expression from the varList.\n        CustomContext context = new CustomContext(new NameTable(), varList)\n      xpath.SetContext(context);\n    }\n}\n\n```\n\n## References\n* OWASP: [Testing for XPath Injection](https://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/07-Input_Validation_Testing/09-Testing_for_XPath_Injection).\n* OWASP: [XPath Injection](https://www.owasp.org/index.php/XPATH_Injection).\n* MSDN: [User Defined Functions and Variables](https://msdn.microsoft.com/en-us/library/dd567715.aspx).\n* Common Weakness Enumeration: [CWE-643](https://cwe.mitre.org/data/definitions/643.html).\n",
                  "markdown": "# XPath injection\nIf an XPath expression is built using string concatenation, and the components of the concatenation include user input, a user is likely to be able to create a malicious XPath expression.\n\n\n## Recommendation\nIf user input must be included in an XPath expression, pre-compile the query and use variable references to include the user input.\n\nWhen using the `System.Xml.XPath` API, this can be done by creating a custom subtype of `System.Xml.Xsl.XsltContext`, and implementing `ResolveVariable(String,String)` to return the user provided data. This custom context can be specified for a given `XPathExpression` using `XPathExpression.SetContext()`. For more details, see the \"User Defined Functions and Variables\" webpage in the list of references.\n\n\n## Example\nIn the first example, the code accepts a user name specified by the user, and uses this unvalidated and unsanitized value in an XPath expression. This is vulnerable to the user providing special characters or string sequences that change the meaning of the XPath expression to search for different values.\n\nIn the second example, the XPath expression is a hard-coded string that specifies some variables, which are safely replaced at runtime using a custom `XsltContext` that looks up the variables in an `XsltArgumentList`.\n\n\n```csharp\nusing System;\nusing System.Web;\nusing System.Xml.XPath;\n\npublic class XPathInjectionHandler : IHttpHandler\n{\n    public void ProcessRequest(HttpContext ctx)\n    {\n        string userName = ctx.Request.QueryString[\"userName\"];\n\n        // BAD: Use user-provided data directly in an XPath expression\n        string badXPathExpr = \"//users/user[login/text()='\" + userName + \"']/home_dir/text()\";\n        XPathExpression.Compile(badXPathExpr);\n\n        // GOOD: XPath expression uses variables to refer to parameters\n        string xpathExpression = \"//users/user[login/text()=$username]/home_dir/text()\";\n        XPathExpression xpath = XPathExpression.Compile(xpathExpression);\n\n        // Arguments are provided as a XsltArgumentList()\n        XsltArgumentList varList = new XsltArgumentList();\n        varList.AddParam(\"userName\", string.Empty, userName);\n\n        // CustomContext is an application specific class, that looks up variables in the\n        // expression from the varList.\n        CustomContext context = new CustomContext(new NameTable(), varList)\n      xpath.SetContext(context);\n    }\n}\n\n```\n\n## References\n* OWASP: [Testing for XPath Injection](https://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/07-Input_Validation_Testing/09-Testing_for_XPath_Injection).\n* OWASP: [XPath Injection](https://www.owasp.org/index.php/XPATH_Injection).\n* MSDN: [User Defined Functions and Variables](https://msdn.microsoft.com/en-us/library/dd567715.aspx).\n* Common Weakness Enumeration: [CWE-643](https://cwe.mitre.org/data/definitions/643.html).\n"
                },
                "properties": {
                  "tags": [
                    "security",
                    "external/cwe/cwe-643"
                  ],
                  "description": "Building an XPath expression from user-controlled sources is vulnerable to insertion of\n              malicious code by the user.",
                  "id": "cs/xml/xpath-injection",
                  "kind": "path-problem",
                  "name": "XPath injection",
                  "precision": "high",
                  "problem.severity": "error",
                  "security-severity": "9.8"
                }
              },
              {
                "id": "cs/inappropriate-encoding",
                "name": "cs/inappropriate-encoding",
                "shortDescription": {
                  "text": "Inappropriate encoding"
                },
                "fullDescription": {
                  "text": "Using an inappropriate encoding may give unintended results and may pose a security risk."
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "error"
                },
                "help": {
                  "text": "# Inappropriate encoding\nUsing an inappropriate encoding may yield unintended results. For example, using URL encoding for HTML content may result in an incorrectly rendered web page. Using an inappropriate encoding may further pose a security risk when a remote user can control the value being encoded. For example, redirecting to an HTML encoded URL provided by a remote user can facilitate phishing attacks.\n\n\n## Recommendation\nUse the appropriate encoding. For example, use HTML encoding for HTML entities, URL encoding for URLs, etc. If possible, avoid writing custom encoding/escaping functionality, and use predefined functionality such as `HttpUtility.HtmlEncode()` or `SqlParameter`s instead.\n\n\n## Example\nThe following example shows two methods where a value is encoded before being written to an HTML page. In the `Bad` method, URL encoding is incorrectly used. In the `Good` method, HTML encoding is correctly used.\n\n\n```csharp\nusing System;\nusing System.Web;\nusing System.Net;\n\npublic class HtmlEncode\n{\n    public static void Bad(HttpContext ctx)\n    {\n        var user = WebUtility.UrlDecode(ctx.Request.QueryString[\"user\"]);\n        ctx.Response.Write(\"Hello, \" + WebUtility.UrlEncode(user));\n    }\n\n    public static void Good(HttpContext ctx)\n    {\n        var user = WebUtility.UrlDecode(ctx.Request.QueryString[\"user\"]);\n        ctx.Response.Write(\"Hello, \" + WebUtility.HtmlEncode(user));\n    }\n}\n\n```\nThe following example shows two methods where a value is encoded before being used in a URL redirect. In the `Bad` method, HTML encoding is incorrectly used. In the `Good` method, URL encoding is correctly used.\n\n\n```csharp\nusing System;\nusing System.Web;\nusing System.Net;\n\npublic class UrlEncode\n{\n    public static void Bad(string value, HttpContext ctx)\n    {\n        var user = WebUtility.UrlDecode(ctx.Request.QueryString[\"user\"]);\n        ctx.Response.Redirect(\"?param=\" + WebUtility.HtmlEncode(user));\n    }\n\n    public static void Good(string value, HttpContext ctx)\n    {\n        var user = WebUtility.UrlDecode(ctx.Request.QueryString[\"user\"]);\n        ctx.Response.Redirect(\"?param=\" + WebUtility.UrlEncode(user));\n    }\n}\n\n```\nThe following example shows two methods where a value is used in a SQL query. In the `Bad` method, the value is insufficiently encoded by only escaping double quotes. In the `Good` method, encoding is handled by using a SQL parameter.\n\n\n```csharp\nusing System;\nusing System.Data;\nusing System.Data.SqlClient;\nusing System.Web;\nusing System.Net;\n\npublic class SqlEncode\n{\n    public static DataSet Bad(HttpContext ctx)\n    {\n        var user = WebUtility.UrlDecode(ctx.Request.QueryString[\"user\"]);\n        using (var connection = new SqlConnection(\"\"))\n        {\n            var query = \"select * from Users where Name='\" + user.Replace(\"\\\"\", \"\\\"\\\"\") + \"'\";\n            var adapter = new SqlDataAdapter(query, connection);\n            var result = new DataSet();\n            adapter.Fill(result);\n            return result;\n        }\n    }\n\n    public static DataSet Good(HttpContext ctx)\n    {\n        var user = WebUtility.UrlDecode(ctx.Request.QueryString[\"user\"]);\n        using (var connection = new SqlConnection(\"\"))\n        {\n            var query = \"select * from Users where Name=@name\";\n            var adapter = new SqlDataAdapter(query, connection);\n            var parameter = new SqlParameter(\"name\", user);\n            adapter.SelectCommand.Parameters.Add(parameter);\n            var result = new DataSet();\n            adapter.Fill(result);\n            return result;\n        }\n    }\n}\n\n```\n\n## References\n* MSDN: [HttpUtility Class](https://msdn.microsoft.com/en-us/library/system.web.httputility(v=vs.110).aspx), [HttpServerUtility Class](https://msdn.microsoft.com/en-us/library/system.web.httpserverutility(v=vs.110).aspx), [WebUtility Class](https://msdn.microsoft.com/en-us/library/system.net.webutility(v=vs.110).aspx), [How To: Protect From SQL Injection in ASP.NET](https://msdn.microsoft.com/en-us/library/ff648339.aspx).\n* Common Weakness Enumeration: [CWE-838](https://cwe.mitre.org/data/definitions/838.html).\n",
                  "markdown": "# Inappropriate encoding\nUsing an inappropriate encoding may yield unintended results. For example, using URL encoding for HTML content may result in an incorrectly rendered web page. Using an inappropriate encoding may further pose a security risk when a remote user can control the value being encoded. For example, redirecting to an HTML encoded URL provided by a remote user can facilitate phishing attacks.\n\n\n## Recommendation\nUse the appropriate encoding. For example, use HTML encoding for HTML entities, URL encoding for URLs, etc. If possible, avoid writing custom encoding/escaping functionality, and use predefined functionality such as `HttpUtility.HtmlEncode()` or `SqlParameter`s instead.\n\n\n## Example\nThe following example shows two methods where a value is encoded before being written to an HTML page. In the `Bad` method, URL encoding is incorrectly used. In the `Good` method, HTML encoding is correctly used.\n\n\n```csharp\nusing System;\nusing System.Web;\nusing System.Net;\n\npublic class HtmlEncode\n{\n    public static void Bad(HttpContext ctx)\n    {\n        var user = WebUtility.UrlDecode(ctx.Request.QueryString[\"user\"]);\n        ctx.Response.Write(\"Hello, \" + WebUtility.UrlEncode(user));\n    }\n\n    public static void Good(HttpContext ctx)\n    {\n        var user = WebUtility.UrlDecode(ctx.Request.QueryString[\"user\"]);\n        ctx.Response.Write(\"Hello, \" + WebUtility.HtmlEncode(user));\n    }\n}\n\n```\nThe following example shows two methods where a value is encoded before being used in a URL redirect. In the `Bad` method, HTML encoding is incorrectly used. In the `Good` method, URL encoding is correctly used.\n\n\n```csharp\nusing System;\nusing System.Web;\nusing System.Net;\n\npublic class UrlEncode\n{\n    public static void Bad(string value, HttpContext ctx)\n    {\n        var user = WebUtility.UrlDecode(ctx.Request.QueryString[\"user\"]);\n        ctx.Response.Redirect(\"?param=\" + WebUtility.HtmlEncode(user));\n    }\n\n    public static void Good(string value, HttpContext ctx)\n    {\n        var user = WebUtility.UrlDecode(ctx.Request.QueryString[\"user\"]);\n        ctx.Response.Redirect(\"?param=\" + WebUtility.UrlEncode(user));\n    }\n}\n\n```\nThe following example shows two methods where a value is used in a SQL query. In the `Bad` method, the value is insufficiently encoded by only escaping double quotes. In the `Good` method, encoding is handled by using a SQL parameter.\n\n\n```csharp\nusing System;\nusing System.Data;\nusing System.Data.SqlClient;\nusing System.Web;\nusing System.Net;\n\npublic class SqlEncode\n{\n    public static DataSet Bad(HttpContext ctx)\n    {\n        var user = WebUtility.UrlDecode(ctx.Request.QueryString[\"user\"]);\n        using (var connection = new SqlConnection(\"\"))\n        {\n            var query = \"select * from Users where Name='\" + user.Replace(\"\\\"\", \"\\\"\\\"\") + \"'\";\n            var adapter = new SqlDataAdapter(query, connection);\n            var result = new DataSet();\n            adapter.Fill(result);\n            return result;\n        }\n    }\n\n    public static DataSet Good(HttpContext ctx)\n    {\n        var user = WebUtility.UrlDecode(ctx.Request.QueryString[\"user\"]);\n        using (var connection = new SqlConnection(\"\"))\n        {\n            var query = \"select * from Users where Name=@name\";\n            var adapter = new SqlDataAdapter(query, connection);\n            var parameter = new SqlParameter(\"name\", user);\n            adapter.SelectCommand.Parameters.Add(parameter);\n            var result = new DataSet();\n            adapter.Fill(result);\n            return result;\n        }\n    }\n}\n\n```\n\n## References\n* MSDN: [HttpUtility Class](https://msdn.microsoft.com/en-us/library/system.web.httputility(v=vs.110).aspx), [HttpServerUtility Class](https://msdn.microsoft.com/en-us/library/system.web.httpserverutility(v=vs.110).aspx), [WebUtility Class](https://msdn.microsoft.com/en-us/library/system.net.webutility(v=vs.110).aspx), [How To: Protect From SQL Injection in ASP.NET](https://msdn.microsoft.com/en-us/library/ff648339.aspx).\n* Common Weakness Enumeration: [CWE-838](https://cwe.mitre.org/data/definitions/838.html).\n"
                },
                "properties": {
                  "tags": [
                    "security",
                    "external/cwe/cwe-838"
                  ],
                  "description": "Using an inappropriate encoding may give unintended results and may\n              pose a security risk.",
                  "id": "cs/inappropriate-encoding",
                  "kind": "path-problem",
                  "name": "Inappropriate encoding",
                  "precision": "low",
                  "problem.severity": "error",
                  "security-severity": "7.8"
                }
              },
              {
                "id": "cs/web/debug-binary",
                "name": "cs/web/debug-binary",
                "shortDescription": {
                  "text": "Creating an ASP.NET debug binary may reveal sensitive information"
                },
                "fullDescription": {
                  "text": "ASP.NET projects should not produce debug binaries when deploying to production as debug builds provide additional information useful to a malicious attacker."
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning"
                },
                "help": {
                  "text": "# Creating an ASP.NET debug binary may reveal sensitive information\nASP.NET applications that deploy a 'debug' build to production can reveal debugging information to end users. This debugging information can aid a malicious user in attacking the system. The use of the debugging flag may also impair performance, increasing execution time and memory usage.\n\n\n## Recommendation\nRemove the 'debug' flag from the `Web.config` file if this configuration is likely to be used in production.\n\n\n## Example\nThe following example shows the 'debug' flag set to true in a `Web.config` file for ASP.NET:\n\n\n```none\n<?xml version=\"1.0\" encoding=\"utf-8\" ?>\n<configuration>\n  <system.web>\n    <compilation\n      defaultLanguage=\"c#\"\n      debug=\"true\"\n    />\n   ...\n  </system.web>\n</configuration>\n```\nThis will produce a 'debug' build that may be exploited by an end user.\n\nTo fix this problem, the 'debug' flag should be set to `false`, or removed completely:\n\n\n```none\n<?xml version=\"1.0\" encoding=\"utf-8\" ?>\n<configuration>\n  <system.web>\n    <compilation\n      defaultLanguage=\"c#\"\n    />\n   ...\n  </system.web>\n</configuration>\n```\n\n## References\n* MSDN: [Why debug=false in ASP.NET applications in production environment](https://web.archive.org/web/20190919105353/https://blogs.msdn.microsoft.com/prashant_upadhyay/2011/07/14/why-debugfalse-in-asp-net-applications-in-production-environment/).\n* MSDN: [How to: Enable Debugging for ASP.NET Applications](https://msdn.microsoft.com/en-us/library/e8z01xdh.aspx).\n* Common Weakness Enumeration: [CWE-11](https://cwe.mitre.org/data/definitions/11.html).\n* Common Weakness Enumeration: [CWE-532](https://cwe.mitre.org/data/definitions/532.html).\n",
                  "markdown": "# Creating an ASP.NET debug binary may reveal sensitive information\nASP.NET applications that deploy a 'debug' build to production can reveal debugging information to end users. This debugging information can aid a malicious user in attacking the system. The use of the debugging flag may also impair performance, increasing execution time and memory usage.\n\n\n## Recommendation\nRemove the 'debug' flag from the `Web.config` file if this configuration is likely to be used in production.\n\n\n## Example\nThe following example shows the 'debug' flag set to true in a `Web.config` file for ASP.NET:\n\n\n```none\n<?xml version=\"1.0\" encoding=\"utf-8\" ?>\n<configuration>\n  <system.web>\n    <compilation\n      defaultLanguage=\"c#\"\n      debug=\"true\"\n    />\n   ...\n  </system.web>\n</configuration>\n```\nThis will produce a 'debug' build that may be exploited by an end user.\n\nTo fix this problem, the 'debug' flag should be set to `false`, or removed completely:\n\n\n```none\n<?xml version=\"1.0\" encoding=\"utf-8\" ?>\n<configuration>\n  <system.web>\n    <compilation\n      defaultLanguage=\"c#\"\n    />\n   ...\n  </system.web>\n</configuration>\n```\n\n## References\n* MSDN: [Why debug=false in ASP.NET applications in production environment](https://web.archive.org/web/20190919105353/https://blogs.msdn.microsoft.com/prashant_upadhyay/2011/07/14/why-debugfalse-in-asp-net-applications-in-production-environment/).\n* MSDN: [How to: Enable Debugging for ASP.NET Applications](https://msdn.microsoft.com/en-us/library/e8z01xdh.aspx).\n* Common Weakness Enumeration: [CWE-11](https://cwe.mitre.org/data/definitions/11.html).\n* Common Weakness Enumeration: [CWE-532](https://cwe.mitre.org/data/definitions/532.html).\n"
                },
                "properties": {
                  "tags": [
                    "security",
                    "maintainability",
                    "frameworks/asp.net",
                    "external/cwe/cwe-11",
                    "external/cwe/cwe-532"
                  ],
                  "description": "ASP.NET projects should not produce debug binaries when deploying to production as\n              debug builds provide additional information useful to a malicious attacker.",
                  "id": "cs/web/debug-binary",
                  "kind": "problem",
                  "name": "Creating an ASP.NET debug binary may reveal sensitive information",
                  "precision": "very-high",
                  "problem.severity": "warning",
                  "security-severity": "7.5"
                }
              },
              {
                "id": "cs/resource-injection",
                "name": "cs/resource-injection",
                "shortDescription": {
                  "text": "Resource injection"
                },
                "fullDescription": {
                  "text": "Building a resource descriptor from untrusted user input is vulnerable to a malicious user providing an unintended resource."
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "error"
                },
                "help": {
                  "text": "# Resource injection\nIf a resource descriptor is built using string concatenation, and the components of the concatenation include user input, a user may be able to hijack the resource which is loaded.\n\n\n## Recommendation\nIf user input must be included in a resource descriptor, it should be escaped to avoid a malicious user providing special characters that change the meaning of the descriptor. If possible, use an existing library to either escape or construct the resource.\n\nFor data connections within sub namespaces of `System.Data`, a connection builder class is provided. For example, a connection string which is to be passed to `System.Data.SqlClient.SqlConnection` can be constructed safely using an instance of `System.Data.SqlClient.SqlConnectionStringBuilder`.\n\n\n## Example\nIn the following examples, the code accepts a user name from the user, which it uses to create a connection string for an SQL database.\n\nThe first example concatenates the unvalidated and unencoded user input directly into the connection string. A malicious user could provide special characters to change the meaning of the connection string, and connect to a completely different server.\n\nThe second example uses the `SqlConnectionStringBuilder` to construct the connection string and therefore prevents a malicious user modifying the meaning of the connection string.\n\n\n```csharp\nusing System.Data.SqlClient;\nusing System.Web;\n\npublic class ResourceInjectionHandler : IHttpHandler\n{\n    public void ProcessRequest(HttpContext ctx)\n    {\n        string userName = ctx.Request.QueryString[\"userName\"];\n\n        // BAD: Direct use of user input in a connection string passed to SqlConnection\n        string connectionString = \"server=(local);user id=\" + userName + \";password= pass;\";\n        SqlConnection sqlConnectionBad = new SqlConnection(connectionString);\n\n        // GOOD: Use SqlConnectionStringBuilder to safely include user input in a connection string\n        SqlConnectionStringBuilder builder = new SqlConnectionStringBuilder();\n        builder[\"Data Source\"] = \"(local)\";\n        builder[\"integrated Security\"] = true;\n        builder[\"user id\"] = userName;\n        SqlConnection sqlConnectionGood = new SqlConnection(builder.ConnectionString);\n    }\n}\n\n```\n\n## References\n* OWASP: [Resource Injection](https://www.owasp.org/index.php/Resource_Injection).\n* MSDN: [Building Connection Strings](https://msdn.microsoft.com/en-us/library/ms254947(v=vs.80).aspx).\n* MSDN: [Securing Connection Strings](https://msdn.microsoft.com/en-us/library/89211k9b(VS.80).aspx).\n* Common Weakness Enumeration: [CWE-99](https://cwe.mitre.org/data/definitions/99.html).\n",
                  "markdown": "# Resource injection\nIf a resource descriptor is built using string concatenation, and the components of the concatenation include user input, a user may be able to hijack the resource which is loaded.\n\n\n## Recommendation\nIf user input must be included in a resource descriptor, it should be escaped to avoid a malicious user providing special characters that change the meaning of the descriptor. If possible, use an existing library to either escape or construct the resource.\n\nFor data connections within sub namespaces of `System.Data`, a connection builder class is provided. For example, a connection string which is to be passed to `System.Data.SqlClient.SqlConnection` can be constructed safely using an instance of `System.Data.SqlClient.SqlConnectionStringBuilder`.\n\n\n## Example\nIn the following examples, the code accepts a user name from the user, which it uses to create a connection string for an SQL database.\n\nThe first example concatenates the unvalidated and unencoded user input directly into the connection string. A malicious user could provide special characters to change the meaning of the connection string, and connect to a completely different server.\n\nThe second example uses the `SqlConnectionStringBuilder` to construct the connection string and therefore prevents a malicious user modifying the meaning of the connection string.\n\n\n```csharp\nusing System.Data.SqlClient;\nusing System.Web;\n\npublic class ResourceInjectionHandler : IHttpHandler\n{\n    public void ProcessRequest(HttpContext ctx)\n    {\n        string userName = ctx.Request.QueryString[\"userName\"];\n\n        // BAD: Direct use of user input in a connection string passed to SqlConnection\n        string connectionString = \"server=(local);user id=\" + userName + \";password= pass;\";\n        SqlConnection sqlConnectionBad = new SqlConnection(connectionString);\n\n        // GOOD: Use SqlConnectionStringBuilder to safely include user input in a connection string\n        SqlConnectionStringBuilder builder = new SqlConnectionStringBuilder();\n        builder[\"Data Source\"] = \"(local)\";\n        builder[\"integrated Security\"] = true;\n        builder[\"user id\"] = userName;\n        SqlConnection sqlConnectionGood = new SqlConnection(builder.ConnectionString);\n    }\n}\n\n```\n\n## References\n* OWASP: [Resource Injection](https://www.owasp.org/index.php/Resource_Injection).\n* MSDN: [Building Connection Strings](https://msdn.microsoft.com/en-us/library/ms254947(v=vs.80).aspx).\n* MSDN: [Securing Connection Strings](https://msdn.microsoft.com/en-us/library/89211k9b(VS.80).aspx).\n* Common Weakness Enumeration: [CWE-99](https://cwe.mitre.org/data/definitions/99.html).\n"
                },
                "properties": {
                  "tags": [
                    "security",
                    "external/cwe/cwe-099"
                  ],
                  "description": "Building a resource descriptor from untrusted user input is vulnerable to a\n              malicious user providing an unintended resource.",
                  "id": "cs/resource-injection",
                  "kind": "path-problem",
                  "name": "Resource injection",
                  "precision": "high",
                  "problem.severity": "error",
                  "security-severity": "9.8"
                }
              },
              {
                "id": "cs/ecb-encryption",
                "name": "cs/ecb-encryption",
                "shortDescription": {
                  "text": "Encryption using ECB"
                },
                "fullDescription": {
                  "text": "Highlights uses of the encryption mode 'CipherMode.ECB'. This mode should normally not be used because it is vulnerable to replay attacks."
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning"
                },
                "help": {
                  "text": "# Encryption using ECB\nECB should not be used as a mode for encryption. It has dangerous weaknesses. Data is encrypted the same way every time meaning the same plaintext input will always produce the same ciphertext. This makes encrypted messages vulnerable to replay attacks.\n\n\n## Recommendation\nUse a different CypherMode.\n\n\n## References\n* Wikipedia, Block cypher modes of operation, [Electronic codebook (ECB)](https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation#Electronic_codebook_.28ECB.29).\n* Common Weakness Enumeration: [CWE-327](https://cwe.mitre.org/data/definitions/327.html).\n",
                  "markdown": "# Encryption using ECB\nECB should not be used as a mode for encryption. It has dangerous weaknesses. Data is encrypted the same way every time meaning the same plaintext input will always produce the same ciphertext. This makes encrypted messages vulnerable to replay attacks.\n\n\n## Recommendation\nUse a different CypherMode.\n\n\n## References\n* Wikipedia, Block cypher modes of operation, [Electronic codebook (ECB)](https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation#Electronic_codebook_.28ECB.29).\n* Common Weakness Enumeration: [CWE-327](https://cwe.mitre.org/data/definitions/327.html).\n"
                },
                "properties": {
                  "tags": [
                    "security",
                    "external/cwe/cwe-327"
                  ],
                  "description": "Highlights uses of the encryption mode 'CipherMode.ECB'. This mode should normally not be used because it is vulnerable to replay attacks.",
                  "id": "cs/ecb-encryption",
                  "kind": "problem",
                  "name": "Encryption using ECB",
                  "precision": "high",
                  "problem.severity": "warning",
                  "security-severity": "7.5"
                }
              },
              {
                "id": "cs/xml-injection",
                "name": "cs/xml-injection",
                "shortDescription": {
                  "text": "XML injection"
                },
                "fullDescription": {
                  "text": "Building an XML document from user-controlled sources is vulnerable to insertion of malicious code by the user."
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "error"
                },
                "help": {
                  "text": "# XML injection\nThe APIs provided by the .NET libraries for XML manipulation allow the insertion of \"raw\" text at a specified point in an XML document. If user input is passed to this API, it could allow a malicious user to add extra content that could corrupt or supersede existing content, or enable unintended additional functionality.\n\n\n## Recommendation\nAvoid using the `WriteRaw` method on `System.Xml.XmlWriter` with user input. If possible, use the high-level APIs to write new XML elements to a document, as these automatically escape user content. If that is not possible, then user input should be escaped before being included in a string that will be used with the `WriteRaw` API.\n\n\n## Example\nIn this example, user input is provided describing the name of an employee to add to an XML document representing a set of names. The `WriteRaw` API is used to write the new employee record to the XML file.\n\n\n```csharp\nusing System;\nusing System.Security;\nusing System.Web;\nusing System.Xml;\n\npublic class XMLInjectionHandler : IHttpHandler {\n  public void ProcessRequest(HttpContext ctx) {\n    string employeeName = ctx.Request.QueryString[\"employeeName\"];\n\n    using (XmlWriter writer = XmlWriter.Create(\"employees.xml\"))\n    {\n        writer.WriteStartDocument();\n\n        // BAD: Insert user input directly into XML\n        writer.WriteRaw(\"<employee><name>\" + employeeName + \"</name></employee>\");\n\n        writer.WriteEndElement();\n        writer.WriteEndDocument();\n    }\n  }\n}\n```\nHowever, if a malicious user were to provide the content `Bobby Pages</name></employee><employee><name>Hacker1`, they would be able to add an extra entry into the XML file.\n\nThe corrected version demonstrates two ways to avoid this issue. The first is to escape user input before passing it to the `WriteRaw` API, which prevents a malicious user from closing or opening XML tags. The second approach uses the high level XML API to add XML elements, which ensures the content is appropriately escaped.\n\n\n```csharp\nusing System;\nusing System.Security;\nusing System.Web;\nusing System.Xml;\n\npublic class XMLInjectionHandler : IHttpHandler {\n  public void ProcessRequest(HttpContext ctx) {\n    string employeeName = ctx.Request.QueryString[\"employeeName\"];\n\n    using (XmlWriter writer = XmlWriter.Create(\"employees.xml\"))\n    {\n        writer.WriteStartDocument();\n\n        // GOOD: Escape user input before inserting into string\n        writer.WriteRaw(\"<employee><name>\" + SecurityElement.Escape(employeeName) + \"</name></employee>\");\n\n        // GOOD: Use standard API, which automatically encodes values\n        writer.WriteStartElement(\"Employee\");\n        writer.WriteElementString(\"Name\", employeeName);\n        writer.WriteEndElement();\n\n        writer.WriteEndElement();\n        writer.WriteEndDocument();\n    }\n  }\n```\n\n## References\n* Web Application Security Consortium: [XML Injection](http://projects.webappsec.org/w/page/13247004/XML%20Injection).\n* Microsoft Docs: [WriteRaw](https://docs.microsoft.com/en-us/dotnet/api/system.xml.xmlwriter.writeraw?view=netframework-4.8).\n* Common Weakness Enumeration: [CWE-91](https://cwe.mitre.org/data/definitions/91.html).\n",
                  "markdown": "# XML injection\nThe APIs provided by the .NET libraries for XML manipulation allow the insertion of \"raw\" text at a specified point in an XML document. If user input is passed to this API, it could allow a malicious user to add extra content that could corrupt or supersede existing content, or enable unintended additional functionality.\n\n\n## Recommendation\nAvoid using the `WriteRaw` method on `System.Xml.XmlWriter` with user input. If possible, use the high-level APIs to write new XML elements to a document, as these automatically escape user content. If that is not possible, then user input should be escaped before being included in a string that will be used with the `WriteRaw` API.\n\n\n## Example\nIn this example, user input is provided describing the name of an employee to add to an XML document representing a set of names. The `WriteRaw` API is used to write the new employee record to the XML file.\n\n\n```csharp\nusing System;\nusing System.Security;\nusing System.Web;\nusing System.Xml;\n\npublic class XMLInjectionHandler : IHttpHandler {\n  public void ProcessRequest(HttpContext ctx) {\n    string employeeName = ctx.Request.QueryString[\"employeeName\"];\n\n    using (XmlWriter writer = XmlWriter.Create(\"employees.xml\"))\n    {\n        writer.WriteStartDocument();\n\n        // BAD: Insert user input directly into XML\n        writer.WriteRaw(\"<employee><name>\" + employeeName + \"</name></employee>\");\n\n        writer.WriteEndElement();\n        writer.WriteEndDocument();\n    }\n  }\n}\n```\nHowever, if a malicious user were to provide the content `Bobby Pages</name></employee><employee><name>Hacker1`, they would be able to add an extra entry into the XML file.\n\nThe corrected version demonstrates two ways to avoid this issue. The first is to escape user input before passing it to the `WriteRaw` API, which prevents a malicious user from closing or opening XML tags. The second approach uses the high level XML API to add XML elements, which ensures the content is appropriately escaped.\n\n\n```csharp\nusing System;\nusing System.Security;\nusing System.Web;\nusing System.Xml;\n\npublic class XMLInjectionHandler : IHttpHandler {\n  public void ProcessRequest(HttpContext ctx) {\n    string employeeName = ctx.Request.QueryString[\"employeeName\"];\n\n    using (XmlWriter writer = XmlWriter.Create(\"employees.xml\"))\n    {\n        writer.WriteStartDocument();\n\n        // GOOD: Escape user input before inserting into string\n        writer.WriteRaw(\"<employee><name>\" + SecurityElement.Escape(employeeName) + \"</name></employee>\");\n\n        // GOOD: Use standard API, which automatically encodes values\n        writer.WriteStartElement(\"Employee\");\n        writer.WriteElementString(\"Name\", employeeName);\n        writer.WriteEndElement();\n\n        writer.WriteEndElement();\n        writer.WriteEndDocument();\n    }\n  }\n```\n\n## References\n* Web Application Security Consortium: [XML Injection](http://projects.webappsec.org/w/page/13247004/XML%20Injection).\n* Microsoft Docs: [WriteRaw](https://docs.microsoft.com/en-us/dotnet/api/system.xml.xmlwriter.writeraw?view=netframework-4.8).\n* Common Weakness Enumeration: [CWE-91](https://cwe.mitre.org/data/definitions/91.html).\n"
                },
                "properties": {
                  "tags": [
                    "security",
                    "external/cwe/cwe-091"
                  ],
                  "description": "Building an XML document from user-controlled sources is vulnerable to insertion of\n              malicious code by the user.",
                  "id": "cs/xml-injection",
                  "kind": "path-problem",
                  "name": "XML injection",
                  "precision": "high",
                  "problem.severity": "error",
                  "security-severity": "8.8"
                }
              },
              {
                "id": "cs/sql-injection",
                "name": "cs/sql-injection",
                "shortDescription": {
                  "text": "SQL query built from user-controlled sources"
                },
                "fullDescription": {
                  "text": "Building a SQL query from user-controlled sources is vulnerable to insertion of malicious SQL code by the user."
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "error"
                },
                "help": {
                  "text": "# SQL query built from user-controlled sources\nIf a SQL query is built using string concatenation, and the components of the concatenation include user input, a user is likely to be able to run malicious database queries.\n\n\n## Recommendation\nUsually, it is better to use a prepared statement than to build a complete query with string concatenation. A prepared statement can include a parameter, written as either a question mark (`?`) or with an explicit name (`@parameter`), for each part of the SQL query that is expected to be filled in by a different value each time it is run. When the query is later executed, a value must be supplied for each parameter in the query.\n\nIt is good practice to use prepared statements for supplying parameters to a query, whether or not any of the parameters are directly traceable to user input. Doing so avoids any need to worry about quoting and escaping.\n\n\n## Example\nIn the following example, the code runs a simple SQL query in three different ways.\n\nThe first way involves building a query, `query1`, by concatenating a user-supplied text box value with some string literals. The text box value can include special characters, so this code allows for SQL injection attacks.\n\nThe second way uses a stored procedure, `ItemsStoredProcedure`, with a single parameter (`@category`). The parameter is then given a value by calling `Parameters.Add`. This version is immune to injection attacks, because any special characters are not given any special treatment.\n\nThe third way builds a query, `query2`, with a single string literal that includes a parameter (`@category`). The parameter is then given a value by calling `Parameters.Add`. This version is immune to injection attacks, because any special characters are not given any special treatment.\n\n\n```csharp\nusing System.Data;\nusing System.Data.SqlClient;\nusing System.Web.UI.WebControls;\n\nclass SqlInjection\n{\n    TextBox categoryTextBox;\n    string connectionString;\n\n    public DataSet GetDataSetByCategory()\n    {\n        // BAD: the category might have SQL special characters in it\n        using (var connection = new SqlConnection(connectionString))\n        {\n            var query1 = \"SELECT ITEM,PRICE FROM PRODUCT WHERE ITEM_CATEGORY='\"\n              + categoryTextBox.Text + \"' ORDER BY PRICE\";\n            var adapter = new SqlDataAdapter(query1, connection);\n            var result = new DataSet();\n            adapter.Fill(result);\n            return result;\n        }\n\n        // GOOD: use parameters with stored procedures\n        using (var connection = new SqlConnection(connectionString))\n        {\n            var adapter = new SqlDataAdapter(\"ItemsStoredProcedure\", connection);\n            adapter.SelectCommand.CommandType = CommandType.StoredProcedure;\n            var parameter = new SqlParameter(\"category\", categoryTextBox.Text);\n            adapter.SelectCommand.Parameters.Add(parameter);\n            var result = new DataSet();\n            adapter.Fill(result);\n            return result;\n        }\n\n        // GOOD: use parameters with dynamic SQL\n        using (var connection = new SqlConnection(connectionString))\n        {\n            var query2 = \"SELECT ITEM,PRICE FROM PRODUCT WHERE ITEM_CATEGORY=\"\n              + \"@category ORDER BY PRICE\";\n            var adapter = new SqlDataAdapter(query2, connection);\n            var parameter = new SqlParameter(\"category\", categoryTextBox.Text);\n            adapter.SelectCommand.Parameters.Add(parameter);\n            var result = new DataSet();\n            adapter.Fill(result);\n            return result;\n        }\n    }\n}\n\n```\n\n## References\n* MSDN: [How To: Protect From SQL Injection in ASP.NET](https://msdn.microsoft.com/en-us/library/ff648339.aspx).\n* Common Weakness Enumeration: [CWE-89](https://cwe.mitre.org/data/definitions/89.html).\n",
                  "markdown": "# SQL query built from user-controlled sources\nIf a SQL query is built using string concatenation, and the components of the concatenation include user input, a user is likely to be able to run malicious database queries.\n\n\n## Recommendation\nUsually, it is better to use a prepared statement than to build a complete query with string concatenation. A prepared statement can include a parameter, written as either a question mark (`?`) or with an explicit name (`@parameter`), for each part of the SQL query that is expected to be filled in by a different value each time it is run. When the query is later executed, a value must be supplied for each parameter in the query.\n\nIt is good practice to use prepared statements for supplying parameters to a query, whether or not any of the parameters are directly traceable to user input. Doing so avoids any need to worry about quoting and escaping.\n\n\n## Example\nIn the following example, the code runs a simple SQL query in three different ways.\n\nThe first way involves building a query, `query1`, by concatenating a user-supplied text box value with some string literals. The text box value can include special characters, so this code allows for SQL injection attacks.\n\nThe second way uses a stored procedure, `ItemsStoredProcedure`, with a single parameter (`@category`). The parameter is then given a value by calling `Parameters.Add`. This version is immune to injection attacks, because any special characters are not given any special treatment.\n\nThe third way builds a query, `query2`, with a single string literal that includes a parameter (`@category`). The parameter is then given a value by calling `Parameters.Add`. This version is immune to injection attacks, because any special characters are not given any special treatment.\n\n\n```csharp\nusing System.Data;\nusing System.Data.SqlClient;\nusing System.Web.UI.WebControls;\n\nclass SqlInjection\n{\n    TextBox categoryTextBox;\n    string connectionString;\n\n    public DataSet GetDataSetByCategory()\n    {\n        // BAD: the category might have SQL special characters in it\n        using (var connection = new SqlConnection(connectionString))\n        {\n            var query1 = \"SELECT ITEM,PRICE FROM PRODUCT WHERE ITEM_CATEGORY='\"\n              + categoryTextBox.Text + \"' ORDER BY PRICE\";\n            var adapter = new SqlDataAdapter(query1, connection);\n            var result = new DataSet();\n            adapter.Fill(result);\n            return result;\n        }\n\n        // GOOD: use parameters with stored procedures\n        using (var connection = new SqlConnection(connectionString))\n        {\n            var adapter = new SqlDataAdapter(\"ItemsStoredProcedure\", connection);\n            adapter.SelectCommand.CommandType = CommandType.StoredProcedure;\n            var parameter = new SqlParameter(\"category\", categoryTextBox.Text);\n            adapter.SelectCommand.Parameters.Add(parameter);\n            var result = new DataSet();\n            adapter.Fill(result);\n            return result;\n        }\n\n        // GOOD: use parameters with dynamic SQL\n        using (var connection = new SqlConnection(connectionString))\n        {\n            var query2 = \"SELECT ITEM,PRICE FROM PRODUCT WHERE ITEM_CATEGORY=\"\n              + \"@category ORDER BY PRICE\";\n            var adapter = new SqlDataAdapter(query2, connection);\n            var parameter = new SqlParameter(\"category\", categoryTextBox.Text);\n            adapter.SelectCommand.Parameters.Add(parameter);\n            var result = new DataSet();\n            adapter.Fill(result);\n            return result;\n        }\n    }\n}\n\n```\n\n## References\n* MSDN: [How To: Protect From SQL Injection in ASP.NET](https://msdn.microsoft.com/en-us/library/ff648339.aspx).\n* Common Weakness Enumeration: [CWE-89](https://cwe.mitre.org/data/definitions/89.html).\n"
                },
                "properties": {
                  "tags": [
                    "security",
                    "external/cwe/cwe-089"
                  ],
                  "description": "Building a SQL query from user-controlled sources is vulnerable to insertion of\n              malicious SQL code by the user.",
                  "id": "cs/sql-injection",
                  "kind": "path-problem",
                  "name": "SQL query built from user-controlled sources",
                  "precision": "high",
                  "problem.severity": "error",
                  "security-severity": "8.8"
                }
              },
              {
                "id": "cs/web/large-max-request-length",
                "name": "cs/web/large-max-request-length",
                "shortDescription": {
                  "text": "Large 'maxRequestLength' value"
                },
                "fullDescription": {
                  "text": "Setting a large 'maxRequestLength' value may render a webpage vulnerable to denial-of-service attacks."
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning"
                },
                "help": {
                  "text": "# Large 'maxRequestLength' value\nThe `maxRequestLength` attribute sets the limit for the input stream buffering threshold in KB. Attackers can use large requests to cause denial-of-service attacks.\n\n\n## Recommendation\nThe recommended value is 4096 KB but you should try setting it as small as possible according to business requirements.\n\n\n## Example\nThe following example shows the `maxRequestLength` attribute set to a high value (255 MB) in a `Web.config` file for ASP.NET:\n\n\n```none\n<?xml version=\"1.0\" encoding=\"utf-8\" ?>\n<configuration>\n  <system.web>\n    <httpRuntime maxRequestLength=\"255000\" />\n  </system.web>\n</configuration>\n```\nUnless such a high value is strictly needed, it is better to set the recommended value (4096 KB):\n\n\n```none\n<?xml version=\"1.0\" encoding=\"utf-8\" ?>\n<configuration>\n  <system.web>\n    <httpRuntime maxRequestLength=\"4096\" />\n  </system.web>\n</configuration>\n```\n\n## References\n* MSDN: [HttpRuntimeSection.MaxRequestLength Property](https://docs.microsoft.com/en-us/dotnet/api/system.web.configuration.httpruntimesection.maxrequestlength?view=netframework-4.8).\n* Common Weakness Enumeration: [CWE-16](https://cwe.mitre.org/data/definitions/16.html).\n",
                  "markdown": "# Large 'maxRequestLength' value\nThe `maxRequestLength` attribute sets the limit for the input stream buffering threshold in KB. Attackers can use large requests to cause denial-of-service attacks.\n\n\n## Recommendation\nThe recommended value is 4096 KB but you should try setting it as small as possible according to business requirements.\n\n\n## Example\nThe following example shows the `maxRequestLength` attribute set to a high value (255 MB) in a `Web.config` file for ASP.NET:\n\n\n```none\n<?xml version=\"1.0\" encoding=\"utf-8\" ?>\n<configuration>\n  <system.web>\n    <httpRuntime maxRequestLength=\"255000\" />\n  </system.web>\n</configuration>\n```\nUnless such a high value is strictly needed, it is better to set the recommended value (4096 KB):\n\n\n```none\n<?xml version=\"1.0\" encoding=\"utf-8\" ?>\n<configuration>\n  <system.web>\n    <httpRuntime maxRequestLength=\"4096\" />\n  </system.web>\n</configuration>\n```\n\n## References\n* MSDN: [HttpRuntimeSection.MaxRequestLength Property](https://docs.microsoft.com/en-us/dotnet/api/system.web.configuration.httpruntimesection.maxrequestlength?view=netframework-4.8).\n* Common Weakness Enumeration: [CWE-16](https://cwe.mitre.org/data/definitions/16.html).\n"
                },
                "properties": {
                  "tags": [
                    "security",
                    "frameworks/asp.net",
                    "external/cwe/cwe-16"
                  ],
                  "description": "Setting a large 'maxRequestLength' value may render a webpage vulnerable to\n              denial-of-service attacks.",
                  "id": "cs/web/large-max-request-length",
                  "kind": "problem",
                  "name": "Large 'maxRequestLength' value",
                  "problem.severity": "warning",
                  "security-severity": "7.5"
                }
              },
              {
                "id": "cs/insecure-request-validation-mode",
                "name": "cs/insecure-request-validation-mode",
                "shortDescription": {
                  "text": "Insecure configuration for ASP.NET requestValidationMode"
                },
                "fullDescription": {
                  "text": "Setting 'requestValidationMode' to less than 4.5 disables built-in validations included by default in ASP.NET. Disabling or downgrading this protection is not recommended."
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning"
                },
                "help": {
                  "text": "# Insecure configuration for ASP.NET requestValidationMode\nThe `requestValidationMode` attribute in ASP.NET is used to configure built-in validation to protect applications against code injections. Downgrading or disabling this configuration is not recommended. The default value of 4.5 is the only recommended value, as previous versions only test a subset of requests.\n\n\n## Recommendation\nAlways set `requestValidationMode` to 4.5, or leave it at its default value.\n\n\n## Example\nThe following example shows the `requestValidationMode` attribute set to a value of 4.0, which disables some protections and ignores individual `Page` directives:\n\n\n```none\n<configuration>\n  <system.web>\n    <httpRuntime requestValidationMode=\"4.0\"/>\n  </system.web>\n</configuration>\n\n```\nSetting the value to 4.5 enables request validation for all requests:\n\n\n```none\n<configuration>\n  <system.web>\n    <httpRuntime requestValidationMode=\"4.5\"/>\n  </system.web>\n</configuration>\n\n```\n\n## References\n* Microsoft: [HttpRuntimeSection.RequestValidationMode Property ](https://docs.microsoft.com/en-us/dotnet/api/system.web.configuration.httpruntimesection.requestvalidationmode?view=netframework-4.8).\n* OWASP: [ASP.NET Request Validation](https://www.owasp.org/index.php/ASP.NET_Request_Validation).\n* Common Weakness Enumeration: [CWE-16](https://cwe.mitre.org/data/definitions/16.html).\n",
                  "markdown": "# Insecure configuration for ASP.NET requestValidationMode\nThe `requestValidationMode` attribute in ASP.NET is used to configure built-in validation to protect applications against code injections. Downgrading or disabling this configuration is not recommended. The default value of 4.5 is the only recommended value, as previous versions only test a subset of requests.\n\n\n## Recommendation\nAlways set `requestValidationMode` to 4.5, or leave it at its default value.\n\n\n## Example\nThe following example shows the `requestValidationMode` attribute set to a value of 4.0, which disables some protections and ignores individual `Page` directives:\n\n\n```none\n<configuration>\n  <system.web>\n    <httpRuntime requestValidationMode=\"4.0\"/>\n  </system.web>\n</configuration>\n\n```\nSetting the value to 4.5 enables request validation for all requests:\n\n\n```none\n<configuration>\n  <system.web>\n    <httpRuntime requestValidationMode=\"4.5\"/>\n  </system.web>\n</configuration>\n\n```\n\n## References\n* Microsoft: [HttpRuntimeSection.RequestValidationMode Property ](https://docs.microsoft.com/en-us/dotnet/api/system.web.configuration.httpruntimesection.requestvalidationmode?view=netframework-4.8).\n* OWASP: [ASP.NET Request Validation](https://www.owasp.org/index.php/ASP.NET_Request_Validation).\n* Common Weakness Enumeration: [CWE-16](https://cwe.mitre.org/data/definitions/16.html).\n"
                },
                "properties": {
                  "tags": [
                    "security",
                    "external/cwe/cwe-016"
                  ],
                  "description": "Setting 'requestValidationMode' to less than 4.5 disables built-in validations\n              included by default in ASP.NET. Disabling or downgrading this protection is not\n              recommended.",
                  "id": "cs/insecure-request-validation-mode",
                  "kind": "problem",
                  "name": "Insecure configuration for ASP.NET requestValidationMode",
                  "problem.severity": "warning",
                  "security-severity": "7.5"
                }
              },
              {
                "id": "cs/web/request-validation-disabled",
                "name": "cs/web/request-validation-disabled",
                "shortDescription": {
                  "text": "Page request validation is disabled"
                },
                "fullDescription": {
                  "text": "ASP.NET pages should not disable the built-in request validation."
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning"
                },
                "help": {
                  "text": "# Page request validation is disabled\nRequest validation is a feature in ASP.NET that protects web applications against potentially malicious content in requests, specifically against cross-site scripting attacks (XSS).\n\n\n## Recommendation\nEnable the directive `validateRequest` in your `web.config` file: ` <pages validateRequest=\"true\" /> `\n\n\n## Example\nThe following example shows the `validateRequest` flag set to `false` in a `Web.config` file for ASP.NET. This will disable validation, and leave the web application vulnerable against common XSS attacks:\n\n\n```none\n<configuration>\n  <system.web>\n    <pages validateRequest=\"false\" />\n  </system.web>\n</configuration>\n```\nIf `validateRequest` is set to `true`, validation is enabled:\n\n\n```none\n<configuration>\n  <system.web>\n    <pages validateRequest=\"true\" />\n  </system.web>\n</configuration>\n```\n\n## References\n* MSDN: [ Request Validation in ASP.NET ](https://docs.microsoft.com/en-us/previous-versions/aspnet/hh882339(v=vs.110)?redirectedfrom=MSDN).\n* Common Weakness Enumeration: [CWE-16](https://cwe.mitre.org/data/definitions/16.html).\n",
                  "markdown": "# Page request validation is disabled\nRequest validation is a feature in ASP.NET that protects web applications against potentially malicious content in requests, specifically against cross-site scripting attacks (XSS).\n\n\n## Recommendation\nEnable the directive `validateRequest` in your `web.config` file: ` <pages validateRequest=\"true\" /> `\n\n\n## Example\nThe following example shows the `validateRequest` flag set to `false` in a `Web.config` file for ASP.NET. This will disable validation, and leave the web application vulnerable against common XSS attacks:\n\n\n```none\n<configuration>\n  <system.web>\n    <pages validateRequest=\"false\" />\n  </system.web>\n</configuration>\n```\nIf `validateRequest` is set to `true`, validation is enabled:\n\n\n```none\n<configuration>\n  <system.web>\n    <pages validateRequest=\"true\" />\n  </system.web>\n</configuration>\n```\n\n## References\n* MSDN: [ Request Validation in ASP.NET ](https://docs.microsoft.com/en-us/previous-versions/aspnet/hh882339(v=vs.110)?redirectedfrom=MSDN).\n* Common Weakness Enumeration: [CWE-16](https://cwe.mitre.org/data/definitions/16.html).\n"
                },
                "properties": {
                  "tags": [
                    "security",
                    "frameworks/asp.net",
                    "external/cwe/cwe-16"
                  ],
                  "description": "ASP.NET pages should not disable the built-in request validation.",
                  "id": "cs/web/request-validation-disabled",
                  "kind": "problem",
                  "name": "Page request validation is disabled",
                  "precision": "high",
                  "problem.severity": "warning",
                  "security-severity": "7.5"
                }
              },
              {
                "id": "cs/web/directory-browse-enabled",
                "name": "cs/web/directory-browse-enabled",
                "shortDescription": {
                  "text": "ASP.NET config file enables directory browsing"
                },
                "fullDescription": {
                  "text": "Directory browsing should not be enabled in production as it can leak sensitive information."
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning"
                },
                "help": {
                  "text": "# ASP.NET config file enables directory browsing\nASP.NET applications that enable directory browsing can leak sensitive information to an attacker. The precise nature of the vulnerability depends on which files are listed and accessible.\n\n\n## Recommendation\nIf this configuration may be used in production, remove the `directoryBrowse` element from the `Web.config` file or set the value to false.\n\n\n## Example\nThe following example shows the `directoryBrowse` `enable` attribute set to true in a `Web.config` file for ASP.NET:\n\n\n```none\n<?xml version=\"1.0\" encoding=\"utf-8\" ?>\n<configuration>\n  <system.webServer>\n    <directoryBrowse enable=\"true\"/>\n   ...\n  </system.web>\n</configuration>\n```\nTo fix this problem, the `enable` attribute should be set to `false`, or the `directoryBrowse` element should be removed completely:\n\n\n```none\n<?xml version=\"1.0\" encoding=\"utf-8\" ?>\n<configuration>\n  <system.webServer>\n    <directoryBrowse enable=\"false\"/>\n   ...\n  </system.web>\n</configuration>\n```\n\n## References\n* MSDN: [directoryBrowse element](https://msdn.microsoft.com/en-us/library/ms691327(v=vs.90).aspx).\n* Common Weakness Enumeration: [CWE-548](https://cwe.mitre.org/data/definitions/548.html).\n",
                  "markdown": "# ASP.NET config file enables directory browsing\nASP.NET applications that enable directory browsing can leak sensitive information to an attacker. The precise nature of the vulnerability depends on which files are listed and accessible.\n\n\n## Recommendation\nIf this configuration may be used in production, remove the `directoryBrowse` element from the `Web.config` file or set the value to false.\n\n\n## Example\nThe following example shows the `directoryBrowse` `enable` attribute set to true in a `Web.config` file for ASP.NET:\n\n\n```none\n<?xml version=\"1.0\" encoding=\"utf-8\" ?>\n<configuration>\n  <system.webServer>\n    <directoryBrowse enable=\"true\"/>\n   ...\n  </system.web>\n</configuration>\n```\nTo fix this problem, the `enable` attribute should be set to `false`, or the `directoryBrowse` element should be removed completely:\n\n\n```none\n<?xml version=\"1.0\" encoding=\"utf-8\" ?>\n<configuration>\n  <system.webServer>\n    <directoryBrowse enable=\"false\"/>\n   ...\n  </system.web>\n</configuration>\n```\n\n## References\n* MSDN: [directoryBrowse element](https://msdn.microsoft.com/en-us/library/ms691327(v=vs.90).aspx).\n* Common Weakness Enumeration: [CWE-548](https://cwe.mitre.org/data/definitions/548.html).\n"
                },
                "properties": {
                  "tags": [
                    "security",
                    "external/cwe/cwe-548"
                  ],
                  "description": "Directory browsing should not be enabled in production as it can leak sensitive information.",
                  "id": "cs/web/directory-browse-enabled",
                  "kind": "problem",
                  "name": "ASP.NET config file enables directory browsing",
                  "precision": "very-high",
                  "problem.severity": "warning",
                  "security-severity": "6.5"
                }
              },
              {
                "id": "cs/hardcoded-connection-string-credentials",
                "name": "cs/hardcoded-connection-string-credentials",
                "shortDescription": {
                  "text": "Hard-coded connection string with credentials"
                },
                "fullDescription": {
                  "text": "Credentials are hard-coded in a connection string in the source code of the application."
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "error"
                },
                "help": {
                  "text": "# Hard-coded connection string with credentials\nIncluding unencrypted hard-coded inbound or outbound authentication credentials within source code or configuration files is dangerous because the credentials may be easily discovered.\n\nSource or configuration files containing hard-coded credentials may be visible to an attacker. For example, the source code may be open source, or it may be leaked or accidentally revealed. For applications shipped as binaries, the credentials may be accessible within the compiled assemblies.\n\nFor inbound authentication, hard-coded credentials may allow unauthorized access to the system. This is particularly problematic if the credential is hard-coded in the source code, because it cannot be disabled easily. For outbound authentication, the hard-coded credentials may provide an attacker with privileged information or unauthorized access to some other system.\n\n\n## Recommendation\nRemove hard-coded credentials, such as user names, passwords and certificates, from source code, placing them in configuration files or other data stores if necessary. If possible, store configuration files including credential data separately from the source code, in a secure location with restricted access.\n\nFor outbound authentication details, consider encrypting the credentials or the enclosing data stores or configuration files, and using permissions to restrict access.\n\nFor inbound authentication details, consider hashing passwords using standard library functions where possible. For example, Microsoft provide the class `Microsoft.AspNet.Identity.PasswordHasher`.\n\n\n## Example\nThe following examples shows different types of inbound and outbound authentication.\n\nIn the first case, we accept a password from a remote user, and compare it against a plaintext string literal. If an attacker acquires the source code, or the assemblies, they can observe the password, and can log in to the system. Furthermore, if such an intrusion was discovered, the application would need to be recompiled in order to change the password.\n\nIn the second case, the password is compared to a hashed and salted password stored in a configuration file, using the Microsoft provided `PasswordHasher.VerifyHashedPassword`. In this case, access to the source code or the assembly would not reveal the password to an attacker. Even access to the configuration file containing the password hash and salt would be of little value to an attacker, as it is usually extremely difficult to reverse engineer the password from the hash and salt.\n\nIn the final case, a password is changed to a new, hard-coded value. If an attacker has access to the source code, they will be able to observe the new password.\n\n\n```csharp\nusing Microsoft.AspNet.Identity;\nusing System;\nusing System.Web;\nusing System.Web.Security;\n\npublic class HardCodedCredentialHandler : IHttpHandler\n{\n\n    public void ProcessRequest(HttpContext ctx)\n    {\n        string password = ctx.Request.QueryString[\"password\"];\n\n        // BAD: Inbound authentication made by comparison to string literal\n        if (password == \"myPa55word\")\n        {\n            ctx.Response.Redirect(\"login\");\n        }\n\n        string hashedPassword = loadPasswordFromSecretConfig();\n\n        // GOOD: Inbound authentication made by comparing to a hash password from a config\n        if (PasswordHasher.VerifyHashedPassword(hashedPassword, password))\n        {\n            ctx.Response.Redirect(VALID_REDIRECT);\n        }\n\n        // BAD: Set the password to a hardcoded string literal\n        MembershipUser user = loadMembershipUser();\n        user.ChangePassword(password, \"myNewPa55word\");\n    }\n}\n\n```\n\n## References\n* OWASP: [XSS Use of hard-coded password](https://www.owasp.org/index.php/Use_of_hard-coded_password).\n* Microsoft Docs: [Preventing Open Redirection Attacks (C\\#)](https://docs.microsoft.com/en-us/aspnet/mvc/overview/security/preventing-open-redirection-attacks).\n* Common Weakness Enumeration: [CWE-259](https://cwe.mitre.org/data/definitions/259.html).\n* Common Weakness Enumeration: [CWE-321](https://cwe.mitre.org/data/definitions/321.html).\n* Common Weakness Enumeration: [CWE-798](https://cwe.mitre.org/data/definitions/798.html).\n",
                  "markdown": "# Hard-coded connection string with credentials\nIncluding unencrypted hard-coded inbound or outbound authentication credentials within source code or configuration files is dangerous because the credentials may be easily discovered.\n\nSource or configuration files containing hard-coded credentials may be visible to an attacker. For example, the source code may be open source, or it may be leaked or accidentally revealed. For applications shipped as binaries, the credentials may be accessible within the compiled assemblies.\n\nFor inbound authentication, hard-coded credentials may allow unauthorized access to the system. This is particularly problematic if the credential is hard-coded in the source code, because it cannot be disabled easily. For outbound authentication, the hard-coded credentials may provide an attacker with privileged information or unauthorized access to some other system.\n\n\n## Recommendation\nRemove hard-coded credentials, such as user names, passwords and certificates, from source code, placing them in configuration files or other data stores if necessary. If possible, store configuration files including credential data separately from the source code, in a secure location with restricted access.\n\nFor outbound authentication details, consider encrypting the credentials or the enclosing data stores or configuration files, and using permissions to restrict access.\n\nFor inbound authentication details, consider hashing passwords using standard library functions where possible. For example, Microsoft provide the class `Microsoft.AspNet.Identity.PasswordHasher`.\n\n\n## Example\nThe following examples shows different types of inbound and outbound authentication.\n\nIn the first case, we accept a password from a remote user, and compare it against a plaintext string literal. If an attacker acquires the source code, or the assemblies, they can observe the password, and can log in to the system. Furthermore, if such an intrusion was discovered, the application would need to be recompiled in order to change the password.\n\nIn the second case, the password is compared to a hashed and salted password stored in a configuration file, using the Microsoft provided `PasswordHasher.VerifyHashedPassword`. In this case, access to the source code or the assembly would not reveal the password to an attacker. Even access to the configuration file containing the password hash and salt would be of little value to an attacker, as it is usually extremely difficult to reverse engineer the password from the hash and salt.\n\nIn the final case, a password is changed to a new, hard-coded value. If an attacker has access to the source code, they will be able to observe the new password.\n\n\n```csharp\nusing Microsoft.AspNet.Identity;\nusing System;\nusing System.Web;\nusing System.Web.Security;\n\npublic class HardCodedCredentialHandler : IHttpHandler\n{\n\n    public void ProcessRequest(HttpContext ctx)\n    {\n        string password = ctx.Request.QueryString[\"password\"];\n\n        // BAD: Inbound authentication made by comparison to string literal\n        if (password == \"myPa55word\")\n        {\n            ctx.Response.Redirect(\"login\");\n        }\n\n        string hashedPassword = loadPasswordFromSecretConfig();\n\n        // GOOD: Inbound authentication made by comparing to a hash password from a config\n        if (PasswordHasher.VerifyHashedPassword(hashedPassword, password))\n        {\n            ctx.Response.Redirect(VALID_REDIRECT);\n        }\n\n        // BAD: Set the password to a hardcoded string literal\n        MembershipUser user = loadMembershipUser();\n        user.ChangePassword(password, \"myNewPa55word\");\n    }\n}\n\n```\n\n## References\n* OWASP: [XSS Use of hard-coded password](https://www.owasp.org/index.php/Use_of_hard-coded_password).\n* Microsoft Docs: [Preventing Open Redirection Attacks (C\\#)](https://docs.microsoft.com/en-us/aspnet/mvc/overview/security/preventing-open-redirection-attacks).\n* Common Weakness Enumeration: [CWE-259](https://cwe.mitre.org/data/definitions/259.html).\n* Common Weakness Enumeration: [CWE-321](https://cwe.mitre.org/data/definitions/321.html).\n* Common Weakness Enumeration: [CWE-798](https://cwe.mitre.org/data/definitions/798.html).\n"
                },
                "properties": {
                  "tags": [
                    "security",
                    "external/cwe/cwe-259",
                    "external/cwe/cwe-321",
                    "external/cwe/cwe-798"
                  ],
                  "description": "Credentials are hard-coded in a connection string in the source code of the application.",
                  "id": "cs/hardcoded-connection-string-credentials",
                  "kind": "path-problem",
                  "name": "Hard-coded connection string with credentials",
                  "precision": "medium",
                  "problem.severity": "error",
                  "security-severity": "9.8"
                }
              },
              {
                "id": "cs/hardcoded-credentials",
                "name": "cs/hardcoded-credentials",
                "shortDescription": {
                  "text": "Hard-coded credentials"
                },
                "fullDescription": {
                  "text": "Credentials are hard coded in the source code of the application."
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "error"
                },
                "help": {
                  "text": "# Hard-coded credentials\nIncluding unencrypted hard-coded inbound or outbound authentication credentials within source code or configuration files is dangerous because the credentials may be easily discovered.\n\nSource or configuration files containing hard-coded credentials may be visible to an attacker. For example, the source code may be open source, or it may be leaked or accidentally revealed. For applications shipped as binaries, the credentials may be accessible within the compiled assemblies.\n\nFor inbound authentication, hard-coded credentials may allow unauthorized access to the system. This is particularly problematic if the credential is hard-coded in the source code, because it cannot be disabled easily. For outbound authentication, the hard-coded credentials may provide an attacker with privileged information or unauthorized access to some other system.\n\n\n## Recommendation\nRemove hard-coded credentials, such as user names, passwords and certificates, from source code, placing them in configuration files or other data stores if necessary. If possible, store configuration files including credential data separately from the source code, in a secure location with restricted access.\n\nFor outbound authentication details, consider encrypting the credentials or the enclosing data stores or configuration files, and using permissions to restrict access.\n\nFor inbound authentication details, consider hashing passwords using standard library functions where possible. For example, Microsoft provide the class `Microsoft.AspNet.Identity.PasswordHasher`.\n\n\n## Example\nThe following examples shows different types of inbound and outbound authentication.\n\nIn the first case, we accept a password from a remote user, and compare it against a plaintext string literal. If an attacker acquires the source code, or the assemblies, they can observe the password, and can log in to the system. Furthermore, if such an intrusion was discovered, the application would need to be recompiled in order to change the password.\n\nIn the second case, the password is compared to a hashed and salted password stored in a configuration file, using the Microsoft provided `PasswordHasher.VerifyHashedPassword`. In this case, access to the source code or the assembly would not reveal the password to an attacker. Even access to the configuration file containing the password hash and salt would be of little value to an attacker, as it is usually extremely difficult to reverse engineer the password from the hash and salt.\n\nIn the final case, a password is changed to a new, hard-coded value. If an attacker has access to the source code, they will be able to observe the new password.\n\n\n```csharp\nusing Microsoft.AspNet.Identity;\nusing System;\nusing System.Web;\nusing System.Web.Security;\n\npublic class HardCodedCredentialHandler : IHttpHandler\n{\n\n    public void ProcessRequest(HttpContext ctx)\n    {\n        string password = ctx.Request.QueryString[\"password\"];\n\n        // BAD: Inbound authentication made by comparison to string literal\n        if (password == \"myPa55word\")\n        {\n            ctx.Response.Redirect(\"login\");\n        }\n\n        string hashedPassword = loadPasswordFromSecretConfig();\n\n        // GOOD: Inbound authentication made by comparing to a hash password from a config\n        if (PasswordHasher.VerifyHashedPassword(hashedPassword, password))\n        {\n            ctx.Response.Redirect(VALID_REDIRECT);\n        }\n\n        // BAD: Set the password to a hardcoded string literal\n        MembershipUser user = loadMembershipUser();\n        user.ChangePassword(password, \"myNewPa55word\");\n    }\n}\n\n```\n\n## References\n* OWASP: [XSS Use of hard-coded password](https://www.owasp.org/index.php/Use_of_hard-coded_password).\n* Microsoft Docs: [Preventing Open Redirection Attacks (C\\#)](https://docs.microsoft.com/en-us/aspnet/mvc/overview/security/preventing-open-redirection-attacks).\n* Common Weakness Enumeration: [CWE-259](https://cwe.mitre.org/data/definitions/259.html).\n* Common Weakness Enumeration: [CWE-321](https://cwe.mitre.org/data/definitions/321.html).\n* Common Weakness Enumeration: [CWE-798](https://cwe.mitre.org/data/definitions/798.html).\n",
                  "markdown": "# Hard-coded credentials\nIncluding unencrypted hard-coded inbound or outbound authentication credentials within source code or configuration files is dangerous because the credentials may be easily discovered.\n\nSource or configuration files containing hard-coded credentials may be visible to an attacker. For example, the source code may be open source, or it may be leaked or accidentally revealed. For applications shipped as binaries, the credentials may be accessible within the compiled assemblies.\n\nFor inbound authentication, hard-coded credentials may allow unauthorized access to the system. This is particularly problematic if the credential is hard-coded in the source code, because it cannot be disabled easily. For outbound authentication, the hard-coded credentials may provide an attacker with privileged information or unauthorized access to some other system.\n\n\n## Recommendation\nRemove hard-coded credentials, such as user names, passwords and certificates, from source code, placing them in configuration files or other data stores if necessary. If possible, store configuration files including credential data separately from the source code, in a secure location with restricted access.\n\nFor outbound authentication details, consider encrypting the credentials or the enclosing data stores or configuration files, and using permissions to restrict access.\n\nFor inbound authentication details, consider hashing passwords using standard library functions where possible. For example, Microsoft provide the class `Microsoft.AspNet.Identity.PasswordHasher`.\n\n\n## Example\nThe following examples shows different types of inbound and outbound authentication.\n\nIn the first case, we accept a password from a remote user, and compare it against a plaintext string literal. If an attacker acquires the source code, or the assemblies, they can observe the password, and can log in to the system. Furthermore, if such an intrusion was discovered, the application would need to be recompiled in order to change the password.\n\nIn the second case, the password is compared to a hashed and salted password stored in a configuration file, using the Microsoft provided `PasswordHasher.VerifyHashedPassword`. In this case, access to the source code or the assembly would not reveal the password to an attacker. Even access to the configuration file containing the password hash and salt would be of little value to an attacker, as it is usually extremely difficult to reverse engineer the password from the hash and salt.\n\nIn the final case, a password is changed to a new, hard-coded value. If an attacker has access to the source code, they will be able to observe the new password.\n\n\n```csharp\nusing Microsoft.AspNet.Identity;\nusing System;\nusing System.Web;\nusing System.Web.Security;\n\npublic class HardCodedCredentialHandler : IHttpHandler\n{\n\n    public void ProcessRequest(HttpContext ctx)\n    {\n        string password = ctx.Request.QueryString[\"password\"];\n\n        // BAD: Inbound authentication made by comparison to string literal\n        if (password == \"myPa55word\")\n        {\n            ctx.Response.Redirect(\"login\");\n        }\n\n        string hashedPassword = loadPasswordFromSecretConfig();\n\n        // GOOD: Inbound authentication made by comparing to a hash password from a config\n        if (PasswordHasher.VerifyHashedPassword(hashedPassword, password))\n        {\n            ctx.Response.Redirect(VALID_REDIRECT);\n        }\n\n        // BAD: Set the password to a hardcoded string literal\n        MembershipUser user = loadMembershipUser();\n        user.ChangePassword(password, \"myNewPa55word\");\n    }\n}\n\n```\n\n## References\n* OWASP: [XSS Use of hard-coded password](https://www.owasp.org/index.php/Use_of_hard-coded_password).\n* Microsoft Docs: [Preventing Open Redirection Attacks (C\\#)](https://docs.microsoft.com/en-us/aspnet/mvc/overview/security/preventing-open-redirection-attacks).\n* Common Weakness Enumeration: [CWE-259](https://cwe.mitre.org/data/definitions/259.html).\n* Common Weakness Enumeration: [CWE-321](https://cwe.mitre.org/data/definitions/321.html).\n* Common Weakness Enumeration: [CWE-798](https://cwe.mitre.org/data/definitions/798.html).\n"
                },
                "properties": {
                  "tags": [
                    "security",
                    "external/cwe/cwe-259",
                    "external/cwe/cwe-321",
                    "external/cwe/cwe-798"
                  ],
                  "description": "Credentials are hard coded in the source code of the application.",
                  "id": "cs/hardcoded-credentials",
                  "kind": "path-problem",
                  "name": "Hard-coded credentials",
                  "precision": "medium",
                  "problem.severity": "error",
                  "security-severity": "9.8"
                }
              },
              {
                "id": "cs/ldap-injection",
                "name": "cs/ldap-injection",
                "shortDescription": {
                  "text": "LDAP query built from user-controlled sources"
                },
                "fullDescription": {
                  "text": "Building an LDAP query from user-controlled sources is vulnerable to insertion of malicious LDAP code by the user."
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "error"
                },
                "help": {
                  "text": "# LDAP query built from user-controlled sources\nIf an LDAP query is built using string concatenation, and the components of the concatenation include user input, a user is likely to be able to run malicious LDAP queries.\n\n\n## Recommendation\nIf user input must be included in an LDAP query, it should be escaped to avoid a malicious user providing special characters that change the meaning of the query. If possible, use an existing library, such as the AntiXSS library.\n\n\n## Example\nIn the following examples, the code accepts an \"organization name\" and a \"username\" from the user, which it uses to query LDAP to access a \"type\" property.\n\nThe first example concatenates the unvalidated and unencoded user input directly into both the DN (Distinguished Name) and the search filter used for the LDAP query. A malicious user could provide special characters to change the meaning of these queries, and search for a completely different set of values.\n\nThe second example uses the Microsoft AntiXSS library to encode the user values before they are included in the DN and search filters. This ensures the meaning of the query cannot be changed by a malicious user.\n\n\n```csharp\nusing Microsoft.Security.Application.Encoder\nusing System;\nusing System.DirectoryServices;\nusing System.Web;\n\npublic class LDAPInjectionHandler : IHttpHandler\n{\n    public void ProcessRequest(HttpContext ctx)\n    {\n        string userName = ctx.Request.QueryString[\"username\"];\n        string organizationName = ctx.Request.QueryString[\"organization_name\"];\n        // BAD: User input used in DN (Distinguished Name) without encoding\n        string ldapQuery = \"LDAP://myserver/OU=People,O=\" + organizationName;\n        using (DirectoryEntry root = new DirectoryEntry(ldapQuery))\n        {\n            // BAD: User input used in search filter without encoding\n            DirectorySearcher ds = new DirectorySearcher(root, \"username=\" + userName);\n\n            SearchResult result = ds.FindOne();\n            if (result != null)\n            {\n                using (DirectoryEntry user = result.getDirectoryEntry())\n                {\n                    ctx.Response.Write(user.Properties[\"type\"].Value)\n                }\n            }\n        }\n\n        // GOOD: Organization name is encoded before being used in DN\n        string safeOrganizationName = Encoder.LdapDistinguishedNameEncode(organizationName);\n        string safeLDAPQuery = \"LDAP://myserver/OU=People,O=\" + safeOrganizationName;\n        using (DirectoryEntry root = new DirectoryEntry(safeLDAPQuery))\n        {\n            // GOOD: User input is encoded before being used in search filter\n            string safeUserName = Encoder.LdapFilterEncode(userName);\n            DirectorySearcher ds = new DirectorySearcher(root, \"username=\" + safeUserName);\n\n            SearchResult result = ds.FindOne();\n            if (result != null)\n            {\n                using (DirectoryEntry user = result.getDirectoryEntry())\n                {\n                    ctx.Response.Write(user.Properties[\"type\"].Value)\n                }\n            }\n        }\n    }\n}\n\n```\n\n## References\n* OWASP: [LDAP Injection Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/LDAP_Injection_Prevention_Cheat_Sheet.html).\n* OWASP: [Preventing LDAP Injection in Java](https://www.owasp.org/index.php/Preventing_LDAP_Injection_in_Java).\n* AntiXSS doc: [LdapFilterEncode](http://www.nudoq.org/#!/Packages/AntiXSS/AntiXssLibrary/Encoder/M/LdapFilterEncode).\n* AntiXSS doc: [LdapDistinguishedNameEncode](http://www.nudoq.org/#!/Packages/AntiXSS/AntiXssLibrary/Encoder/M/LdapDistinguishedNameEncode).\n* Common Weakness Enumeration: [CWE-90](https://cwe.mitre.org/data/definitions/90.html).\n",
                  "markdown": "# LDAP query built from user-controlled sources\nIf an LDAP query is built using string concatenation, and the components of the concatenation include user input, a user is likely to be able to run malicious LDAP queries.\n\n\n## Recommendation\nIf user input must be included in an LDAP query, it should be escaped to avoid a malicious user providing special characters that change the meaning of the query. If possible, use an existing library, such as the AntiXSS library.\n\n\n## Example\nIn the following examples, the code accepts an \"organization name\" and a \"username\" from the user, which it uses to query LDAP to access a \"type\" property.\n\nThe first example concatenates the unvalidated and unencoded user input directly into both the DN (Distinguished Name) and the search filter used for the LDAP query. A malicious user could provide special characters to change the meaning of these queries, and search for a completely different set of values.\n\nThe second example uses the Microsoft AntiXSS library to encode the user values before they are included in the DN and search filters. This ensures the meaning of the query cannot be changed by a malicious user.\n\n\n```csharp\nusing Microsoft.Security.Application.Encoder\nusing System;\nusing System.DirectoryServices;\nusing System.Web;\n\npublic class LDAPInjectionHandler : IHttpHandler\n{\n    public void ProcessRequest(HttpContext ctx)\n    {\n        string userName = ctx.Request.QueryString[\"username\"];\n        string organizationName = ctx.Request.QueryString[\"organization_name\"];\n        // BAD: User input used in DN (Distinguished Name) without encoding\n        string ldapQuery = \"LDAP://myserver/OU=People,O=\" + organizationName;\n        using (DirectoryEntry root = new DirectoryEntry(ldapQuery))\n        {\n            // BAD: User input used in search filter without encoding\n            DirectorySearcher ds = new DirectorySearcher(root, \"username=\" + userName);\n\n            SearchResult result = ds.FindOne();\n            if (result != null)\n            {\n                using (DirectoryEntry user = result.getDirectoryEntry())\n                {\n                    ctx.Response.Write(user.Properties[\"type\"].Value)\n                }\n            }\n        }\n\n        // GOOD: Organization name is encoded before being used in DN\n        string safeOrganizationName = Encoder.LdapDistinguishedNameEncode(organizationName);\n        string safeLDAPQuery = \"LDAP://myserver/OU=People,O=\" + safeOrganizationName;\n        using (DirectoryEntry root = new DirectoryEntry(safeLDAPQuery))\n        {\n            // GOOD: User input is encoded before being used in search filter\n            string safeUserName = Encoder.LdapFilterEncode(userName);\n            DirectorySearcher ds = new DirectorySearcher(root, \"username=\" + safeUserName);\n\n            SearchResult result = ds.FindOne();\n            if (result != null)\n            {\n                using (DirectoryEntry user = result.getDirectoryEntry())\n                {\n                    ctx.Response.Write(user.Properties[\"type\"].Value)\n                }\n            }\n        }\n    }\n}\n\n```\n\n## References\n* OWASP: [LDAP Injection Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/LDAP_Injection_Prevention_Cheat_Sheet.html).\n* OWASP: [Preventing LDAP Injection in Java](https://www.owasp.org/index.php/Preventing_LDAP_Injection_in_Java).\n* AntiXSS doc: [LdapFilterEncode](http://www.nudoq.org/#!/Packages/AntiXSS/AntiXssLibrary/Encoder/M/LdapFilterEncode).\n* AntiXSS doc: [LdapDistinguishedNameEncode](http://www.nudoq.org/#!/Packages/AntiXSS/AntiXssLibrary/Encoder/M/LdapDistinguishedNameEncode).\n* Common Weakness Enumeration: [CWE-90](https://cwe.mitre.org/data/definitions/90.html).\n"
                },
                "properties": {
                  "tags": [
                    "security",
                    "external/cwe/cwe-090"
                  ],
                  "description": "Building an LDAP query from user-controlled sources is vulnerable to insertion of\n              malicious LDAP code by the user.",
                  "id": "cs/ldap-injection",
                  "kind": "path-problem",
                  "name": "LDAP query built from user-controlled sources",
                  "precision": "high",
                  "problem.severity": "error",
                  "security-severity": "9.8"
                }
              },
              {
                "id": "cs/web/ambiguous-server-variable",
                "name": "cs/web/ambiguous-server-variable",
                "shortDescription": {
                  "text": "Value shadowing: server variable"
                },
                "fullDescription": {
                  "text": "Finds ambiguous accesses to server variables"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning"
                },
                "help": {
                  "text": "# Value shadowing: server variable\nRelying on `HttpRequest` to provide access to a particular server variable is not safe as it can be overridden by the client. The `HttpRequest` class implements an indexer to provide a simplified, combined access to its `QueryString`, `Form` , `Cookies`, or `ServerVariables` collections, in that particular order. When searching for a variable, the first match is returned: `QueryString` parameters hence supersede values from forms, cookies and server variables, and so on. This is a serious attack vector since an attacker could inject a value in the query string that you do not expect, and which supersedes the value of the server variable you were actually trying to check.\n\n\n## Recommendation\nExplicitly restrict the search to the `ServerVariables` collection.\n\n\n## Example\nIn this example the server attempts to ensure the user is using an HTTPS connection. Because the programmer used the `HttpRequest` indexer, URLs like ` http://www.example.org/?HTTPS=ON` appear to be from a secure connection even though they are not.\n\n\n```csharp\nclass ValueShadowingServerVariable\n{\n    public bool isHTTPS(HttpRequest request)\n    {\n        String https = request[\"HTTPS\"];\n        return https == \"ON\";\n    }\n}\n\n```\nThis can be easily fixed by explicitly specifying that we are looking for a server variable.\n\n\n```csharp\nclass ValueShadowingServerVariableFix\n{\n    public bool isHTTPS(HttpRequest request)\n    {\n        String https = request.ServerVariables[\"HTTPS\"];\n        return https == \"ON\";\n    }\n}\n\n```\n\n## References\n* MSDN: [HttpRequest.Item](http://msdn.microsoft.com/en-us/library/system.web.httprequest.item(v=VS.100).aspx).\n* MSDN: [IIS Server Variables](http://msdn.microsoft.com/en-us/library/ms524602.aspx).\n* Common Weakness Enumeration: [CWE-348](https://cwe.mitre.org/data/definitions/348.html).\n",
                  "markdown": "# Value shadowing: server variable\nRelying on `HttpRequest` to provide access to a particular server variable is not safe as it can be overridden by the client. The `HttpRequest` class implements an indexer to provide a simplified, combined access to its `QueryString`, `Form` , `Cookies`, or `ServerVariables` collections, in that particular order. When searching for a variable, the first match is returned: `QueryString` parameters hence supersede values from forms, cookies and server variables, and so on. This is a serious attack vector since an attacker could inject a value in the query string that you do not expect, and which supersedes the value of the server variable you were actually trying to check.\n\n\n## Recommendation\nExplicitly restrict the search to the `ServerVariables` collection.\n\n\n## Example\nIn this example the server attempts to ensure the user is using an HTTPS connection. Because the programmer used the `HttpRequest` indexer, URLs like ` http://www.example.org/?HTTPS=ON` appear to be from a secure connection even though they are not.\n\n\n```csharp\nclass ValueShadowingServerVariable\n{\n    public bool isHTTPS(HttpRequest request)\n    {\n        String https = request[\"HTTPS\"];\n        return https == \"ON\";\n    }\n}\n\n```\nThis can be easily fixed by explicitly specifying that we are looking for a server variable.\n\n\n```csharp\nclass ValueShadowingServerVariableFix\n{\n    public bool isHTTPS(HttpRequest request)\n    {\n        String https = request.ServerVariables[\"HTTPS\"];\n        return https == \"ON\";\n    }\n}\n\n```\n\n## References\n* MSDN: [HttpRequest.Item](http://msdn.microsoft.com/en-us/library/system.web.httprequest.item(v=VS.100).aspx).\n* MSDN: [IIS Server Variables](http://msdn.microsoft.com/en-us/library/ms524602.aspx).\n* Common Weakness Enumeration: [CWE-348](https://cwe.mitre.org/data/definitions/348.html).\n"
                },
                "properties": {
                  "tags": [
                    "security",
                    "maintainability",
                    "frameworks/asp.net",
                    "external/cwe/cwe-348"
                  ],
                  "description": "Finds ambiguous accesses to server variables",
                  "id": "cs/web/ambiguous-server-variable",
                  "kind": "problem",
                  "name": "Value shadowing: server variable",
                  "precision": "medium",
                  "problem.severity": "warning"
                }
              },
              {
                "id": "cs/web/ambiguous-client-variable",
                "name": "cs/web/ambiguous-client-variable",
                "shortDescription": {
                  "text": "Value shadowing"
                },
                "fullDescription": {
                  "text": "Finds ambiguous accesses to client variables"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning"
                },
                "help": {
                  "text": "# Value shadowing\nRelying on `HttpRequest` to provide access to a particular client variable is not safe. The `HttpRequest` class implements an indexer to provide a simplified, combined access to its `QueryString`, `Form`, `Cookies`, or `ServerVariables` collections, in that particular order. When searching for a variable, the first match is returned: `QueryString` parameters hence supersede values from forms, cookies and server variables, and so on. This is a serious attack vector since an attacker could inject a value in the query string that you do not expect, and which supersedes the value of a more trusted collection.\n\n\n## Recommendation\nExplicitly restrict the search to one of the `QueryString`, `Form` or `Cookies` collections.\n\n\n## Example\nIn this example an attempt has been made to prevent cross site request forgery attacks by comparing a cookie set by the server with a form variable sent by the user. The problem is that if the user did not send a form variable called `csrf` then the collection will fall back to using the cookie value, making it look like a forged request was initiated by the user.\n\n\n```csharp\nclass ValueShadowing\n{\n    public bool checkCSRF(HttpRequest request)\n    {\n        string postCSRF = request[\"csrf\"];\n        string cookieCSRF = request.Cookies[\"csrf\"];\n        return postCSRF.Equals(cookieCSRF);\n    }\n}\n\n```\nThis can be easily fixed by explicitly specifying that we are looking for a form variable.\n\n\n```csharp\nclass ValueShadowingFix\n{\n    public bool checkCSRF(HttpRequest request)\n    {\n        string postCSRF = request.Form[\"csrf\"];\n        string cookieCSRF = request.Cookies[\"csrf\"];\n        return postCSRF.Equals(cookieCSRF);\n    }\n}\n\n```\n\n## References\n* MSDN: [HttpRequest.Item](http://msdn.microsoft.com/en-us/library/system.web.httprequest.item(v=VS.100).aspx).\n* Common Weakness Enumeration: [CWE-348](https://cwe.mitre.org/data/definitions/348.html).\n",
                  "markdown": "# Value shadowing\nRelying on `HttpRequest` to provide access to a particular client variable is not safe. The `HttpRequest` class implements an indexer to provide a simplified, combined access to its `QueryString`, `Form`, `Cookies`, or `ServerVariables` collections, in that particular order. When searching for a variable, the first match is returned: `QueryString` parameters hence supersede values from forms, cookies and server variables, and so on. This is a serious attack vector since an attacker could inject a value in the query string that you do not expect, and which supersedes the value of a more trusted collection.\n\n\n## Recommendation\nExplicitly restrict the search to one of the `QueryString`, `Form` or `Cookies` collections.\n\n\n## Example\nIn this example an attempt has been made to prevent cross site request forgery attacks by comparing a cookie set by the server with a form variable sent by the user. The problem is that if the user did not send a form variable called `csrf` then the collection will fall back to using the cookie value, making it look like a forged request was initiated by the user.\n\n\n```csharp\nclass ValueShadowing\n{\n    public bool checkCSRF(HttpRequest request)\n    {\n        string postCSRF = request[\"csrf\"];\n        string cookieCSRF = request.Cookies[\"csrf\"];\n        return postCSRF.Equals(cookieCSRF);\n    }\n}\n\n```\nThis can be easily fixed by explicitly specifying that we are looking for a form variable.\n\n\n```csharp\nclass ValueShadowingFix\n{\n    public bool checkCSRF(HttpRequest request)\n    {\n        string postCSRF = request.Form[\"csrf\"];\n        string cookieCSRF = request.Cookies[\"csrf\"];\n        return postCSRF.Equals(cookieCSRF);\n    }\n}\n\n```\n\n## References\n* MSDN: [HttpRequest.Item](http://msdn.microsoft.com/en-us/library/system.web.httprequest.item(v=VS.100).aspx).\n* Common Weakness Enumeration: [CWE-348](https://cwe.mitre.org/data/definitions/348.html).\n"
                },
                "properties": {
                  "tags": [
                    "security",
                    "maintainability",
                    "frameworks/asp.net",
                    "external/cwe/cwe-348"
                  ],
                  "description": "Finds ambiguous accesses to client variables",
                  "id": "cs/web/ambiguous-client-variable",
                  "kind": "problem",
                  "name": "Value shadowing",
                  "precision": "medium",
                  "problem.severity": "warning"
                }
              },
              {
                "id": "cs/web/file-upload",
                "name": "cs/web/file-upload",
                "shortDescription": {
                  "text": "Use of file upload"
                },
                "fullDescription": {
                  "text": "Finds uses of file upload"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "note"
                },
                "help": {
                  "text": "# Use of file upload\nAllowing end users to upload files may lead to severe security threats. Attackers may use this open door to compromise your application, either by overwriting data or by injecting malicious code to run on your server.\n\n\n## Recommendation\nWhist it might not be possible to remove the ability to upload files, special care should be taken to ensure files are handled in a secure manner. The following checks should be implemented to ensure the security of your application:\n\n* Validate each path where the uploaded data is written to.\n* Check the content of the data being uploaded without just relying on the MIME type.\n* Set a size limit for the uploaded data.\n* Do not run your web application with administrator privileges.\n* Log each upload request.\n* Do not display system information or exception in case the upload fails as this information may help attackers to find a breach.\n\n## References\n* Common Weakness Enumeration: [CWE-434](https://cwe.mitre.org/data/definitions/434.html).\n",
                  "markdown": "# Use of file upload\nAllowing end users to upload files may lead to severe security threats. Attackers may use this open door to compromise your application, either by overwriting data or by injecting malicious code to run on your server.\n\n\n## Recommendation\nWhist it might not be possible to remove the ability to upload files, special care should be taken to ensure files are handled in a secure manner. The following checks should be implemented to ensure the security of your application:\n\n* Validate each path where the uploaded data is written to.\n* Check the content of the data being uploaded without just relying on the MIME type.\n* Set a size limit for the uploaded data.\n* Do not run your web application with administrator privileges.\n* Log each upload request.\n* Do not display system information or exception in case the upload fails as this information may help attackers to find a breach.\n\n## References\n* Common Weakness Enumeration: [CWE-434](https://cwe.mitre.org/data/definitions/434.html).\n"
                },
                "properties": {
                  "tags": [
                    "security",
                    "maintainability",
                    "frameworks/asp.net",
                    "external/cwe/cwe-434"
                  ],
                  "description": "Finds uses of file upload",
                  "id": "cs/web/file-upload",
                  "kind": "problem",
                  "name": "Use of file upload",
                  "precision": "high",
                  "problem.severity": "recommendation",
                  "security-severity": "9.8"
                }
              },
              {
                "id": "cs/web/cookie-httponly-not-set",
                "name": "cs/web/cookie-httponly-not-set",
                "shortDescription": {
                  "text": "'HttpOnly' attribute is not set to true"
                },
                "fullDescription": {
                  "text": "Omitting the 'HttpOnly' attribute for security sensitive data allows malicious JavaScript to steal it in case of XSS vulnerability. Always set 'HttpOnly' to 'true' to authentication related cookie to make it not accessible by JavaScript."
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning"
                },
                "help": {
                  "text": "# 'HttpOnly' attribute is not set to true\nCookies without `HttpOnly` flag are accessible to JavaScript running in the same origin. In case of Cross-Site Scripting (XSS) vulnerability the cookie can be stolen by malicious script.\n\n\n## Recommendation\nProtect sensitive cookies, such as related to authentication, by setting `HttpOnly` to `true` to make them not accessible to JavaScript. In ASP.NET case it is also possible to set the attribute via `<httpCookies>` element of `web.config` with the attribute `httpOnlyCookies=\"true\"`.\n\n\n## Example\nIn the example below `Microsoft.AspNetCore.Http.CookieOptions.HttpOnly` is set to `true`.\n\n\n```csharp\nclass MyController : Controller\n{\n    void Login()\n    {\n        var cookieOptions = new Microsoft.AspNetCore.Http.CookieOptions() { HttpOnly = true };\n        Response.Cookies.Append(\"auth\", \"secret\", cookieOptions);\n    }\n}\n```\nIn the following example `CookiePolicyOptions` are set programmatically to configure defaults.\n\n\n```csharp\npublic class Startup\n{\n    // This method gets called by the runtime. Use this method to configure the HTTP request pipeline.\n    public void Configure(IApplicationBuilder app, IWebHostEnvironment env)\n    {\n        app.UseCookiePolicy(new CookiePolicyOptions()\n        {\n            Secure = Microsoft.AspNetCore.Http.CookieSecurePolicy.Always,\n            HttpOnly = Microsoft.AspNetCore.CookiePolicy.HttpOnlyPolicy.Always\n        });\n    }\n}\n```\nIn the example below `System.Web.HttpCookie.HttpOnly` is set to `true`.\n\n\n```csharp\nclass MyController : Controller\n{\n    void Login()\n    {\n        var cookie = new System.Web.HttpCookie(\"cookieName\") { HttpOnly = true };\n    }\n}\n```\n\n## References\n* [CookieOptions.HttpOnly Property,](https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.http.cookieoptions.httponly)\n* [Set-Cookie](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie) Header,\n* [HttpCookie.HttpOnly Property,](https://msdn.microsoft.com/en-us/library/system.web.httpcookie.httponly(v=vs.110).aspx)\n* [httpCookies Element,](https://msdn.microsoft.com/library/ms228262%28v=vs.100%29.aspx)\n* Common Weakness Enumeration: [CWE-1004](https://cwe.mitre.org/data/definitions/1004.html).\n",
                  "markdown": "# 'HttpOnly' attribute is not set to true\nCookies without `HttpOnly` flag are accessible to JavaScript running in the same origin. In case of Cross-Site Scripting (XSS) vulnerability the cookie can be stolen by malicious script.\n\n\n## Recommendation\nProtect sensitive cookies, such as related to authentication, by setting `HttpOnly` to `true` to make them not accessible to JavaScript. In ASP.NET case it is also possible to set the attribute via `<httpCookies>` element of `web.config` with the attribute `httpOnlyCookies=\"true\"`.\n\n\n## Example\nIn the example below `Microsoft.AspNetCore.Http.CookieOptions.HttpOnly` is set to `true`.\n\n\n```csharp\nclass MyController : Controller\n{\n    void Login()\n    {\n        var cookieOptions = new Microsoft.AspNetCore.Http.CookieOptions() { HttpOnly = true };\n        Response.Cookies.Append(\"auth\", \"secret\", cookieOptions);\n    }\n}\n```\nIn the following example `CookiePolicyOptions` are set programmatically to configure defaults.\n\n\n```csharp\npublic class Startup\n{\n    // This method gets called by the runtime. Use this method to configure the HTTP request pipeline.\n    public void Configure(IApplicationBuilder app, IWebHostEnvironment env)\n    {\n        app.UseCookiePolicy(new CookiePolicyOptions()\n        {\n            Secure = Microsoft.AspNetCore.Http.CookieSecurePolicy.Always,\n            HttpOnly = Microsoft.AspNetCore.CookiePolicy.HttpOnlyPolicy.Always\n        });\n    }\n}\n```\nIn the example below `System.Web.HttpCookie.HttpOnly` is set to `true`.\n\n\n```csharp\nclass MyController : Controller\n{\n    void Login()\n    {\n        var cookie = new System.Web.HttpCookie(\"cookieName\") { HttpOnly = true };\n    }\n}\n```\n\n## References\n* [CookieOptions.HttpOnly Property,](https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.http.cookieoptions.httponly)\n* [Set-Cookie](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie) Header,\n* [HttpCookie.HttpOnly Property,](https://msdn.microsoft.com/en-us/library/system.web.httpcookie.httponly(v=vs.110).aspx)\n* [httpCookies Element,](https://msdn.microsoft.com/library/ms228262%28v=vs.100%29.aspx)\n* Common Weakness Enumeration: [CWE-1004](https://cwe.mitre.org/data/definitions/1004.html).\n"
                },
                "properties": {
                  "tags": [
                    "security",
                    "experimental",
                    "external/cwe/cwe-1004"
                  ],
                  "description": "Omitting the 'HttpOnly' attribute for security sensitive data allows\n              malicious JavaScript to steal it in case of XSS vulnerability. Always set\n              'HttpOnly' to 'true' to authentication related cookie to make it\n              not accessible by JavaScript.",
                  "id": "cs/web/cookie-httponly-not-set",
                  "kind": "problem",
                  "name": "'HttpOnly' attribute is not set to true",
                  "precision": "high",
                  "problem.severity": "warning"
                }
              },
              {
                "id": "cs/backdoor/dangerous-native-functions",
                "name": "cs/backdoor/dangerous-native-functions",
                "shortDescription": {
                  "text": "Potential dangerous use of native functions"
                },
                "fullDescription": {
                  "text": "Detects the use of native functions that can be used for malicious intent or unsafe handling."
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning"
                },
                "help": {
                  "text": "# Potential dangerous use of native functions\nThis query finds native calls to external functions that are often used in creating backdoors or are generally attributed to unsafe code practices. This is an example of a query that may be useful for detecting potential backdoors. Solorigate is one example that uses this mechanism.\n\n\n## Recommendation\nAny findings from this rule are only intended to indicate suspicious code that shares similarities with known portions of code used for the Solorigate attack. There is no certainty that the code is related or that the code is part of any attack.\n\nFor more information about Solorigate, please visit https://aka.ms/solorigate.\n\n",
                  "markdown": "# Potential dangerous use of native functions\nThis query finds native calls to external functions that are often used in creating backdoors or are generally attributed to unsafe code practices. This is an example of a query that may be useful for detecting potential backdoors. Solorigate is one example that uses this mechanism.\n\n\n## Recommendation\nAny findings from this rule are only intended to indicate suspicious code that shares similarities with known portions of code used for the Solorigate attack. There is no certainty that the code is related or that the code is part of any attack.\n\nFor more information about Solorigate, please visit https://aka.ms/solorigate.\n\n"
                },
                "properties": {
                  "tags": [
                    "security",
                    "experimental",
                    "solorigate"
                  ],
                  "description": "Detects the use of native functions that can be used for malicious intent or unsafe handling.",
                  "id": "cs/backdoor/dangerous-native-functions",
                  "kind": "problem",
                  "name": "Potential dangerous use of native functions",
                  "precision": "low",
                  "problem.severity": "warning"
                }
              },
              {
                "id": "cs/backdoor/process-name-to-hash-function",
                "name": "cs/backdoor/process-name-to-hash-function",
                "shortDescription": {
                  "text": "ProcessName to hash function flow"
                },
                "fullDescription": {
                  "text": "Flow from a function retrieving process name to a hash function."
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning"
                },
                "help": {
                  "text": "# ProcessName to hash function flow\nThis query detects code flow from ProcessName property on the Process class into a hash function.\n\nSuch flow is often used in code backdoors to detect running processes and compare them to an obfuscated list of antivirus processes to avoid detection. Solorigate is one example that uses this mechanism.\n\n\n## Recommendation\nAny findings from this rule are only intended to indicate suspicious code that shares similarities with known portions of code used for the Solorigate attack. There is no certainty that the code is related or that the code is part of any attack.\n\nFor more information about Solorigate, please visit https://aka.ms/solorigate.\n\n",
                  "markdown": "# ProcessName to hash function flow\nThis query detects code flow from ProcessName property on the Process class into a hash function.\n\nSuch flow is often used in code backdoors to detect running processes and compare them to an obfuscated list of antivirus processes to avoid detection. Solorigate is one example that uses this mechanism.\n\n\n## Recommendation\nAny findings from this rule are only intended to indicate suspicious code that shares similarities with known portions of code used for the Solorigate attack. There is no certainty that the code is related or that the code is part of any attack.\n\nFor more information about Solorigate, please visit https://aka.ms/solorigate.\n\n"
                },
                "properties": {
                  "tags": [
                    "security",
                    "experimental",
                    "solorigate"
                  ],
                  "description": "Flow from a function retrieving process name to a hash function.",
                  "id": "cs/backdoor/process-name-to-hash-function",
                  "kind": "path-problem",
                  "name": "ProcessName to hash function flow",
                  "precision": "medium",
                  "problem.severity": "warning"
                }
              },
              {
                "id": "cs/backdoor/potential-time-bomb",
                "name": "cs/backdoor/potential-time-bomb",
                "shortDescription": {
                  "text": "Potential Timebomb"
                },
                "fullDescription": {
                  "text": "If there is data flow from a file's last modification date and an offset to a condition statement, this could trigger a \"time bomb\"."
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning"
                },
                "help": {
                  "text": "# Potential Timebomb\nThis query detects situations in which an offset to a last file modification time is used to conditionally execute a particular block of code. This is a common pattern in backdoors, where the file's modification timestamp is the time at which the backdoor was planted, and the time offset is used as a time bomb before a particular code block is executed.\n\n\n## Recommendation\nAny findings from this rule are only intended to indicate suspicious code that shares similarities with known portions of code used for the Solorigate attack. There is no certainty that the code is related or that the code is part of any attack.\n\nFor more information about Solorigate, please visit https://aka.ms/solorigate.\n\n",
                  "markdown": "# Potential Timebomb\nThis query detects situations in which an offset to a last file modification time is used to conditionally execute a particular block of code. This is a common pattern in backdoors, where the file's modification timestamp is the time at which the backdoor was planted, and the time offset is used as a time bomb before a particular code block is executed.\n\n\n## Recommendation\nAny findings from this rule are only intended to indicate suspicious code that shares similarities with known portions of code used for the Solorigate attack. There is no certainty that the code is related or that the code is part of any attack.\n\nFor more information about Solorigate, please visit https://aka.ms/solorigate.\n\n"
                },
                "properties": {
                  "tags": [
                    "security",
                    "experimental",
                    "solorigate"
                  ],
                  "description": "If there is data flow from a file's last modification date and an offset to a condition statement, this could trigger a \"time bomb\".",
                  "id": "cs/backdoor/potential-time-bomb",
                  "kind": "path-problem",
                  "name": "Potential Timebomb",
                  "precision": "Low",
                  "problem.severity": "warning"
                }
              },
              {
                "id": "cs/azure-storage/unsafe-usage-of-client-side-encryption-version",
                "name": "cs/azure-storage/unsafe-usage-of-client-side-encryption-version",
                "shortDescription": {
                  "text": "Unsafe usage of v1 version of Azure Storage client-side encryption (CVE-2022-30187)."
                },
                "fullDescription": {
                  "text": "Unsafe usage of v1 version of Azure Storage client-side encryption, please refer to http://aka.ms/azstorageclientencryptionblog"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "error"
                },
                "help": {
                  "text": "# Unsafe usage of v1 version of Azure Storage client-side encryption (CVE-2022-30187).\nAzure Storage .NET, Java, and Python SDKs support encryption on the client with a customer-managed key that is maintained in Azure Key Vault or another key store.\n\nCurrent release versions of the Azure Storage SDKs use cipher block chaining (CBC mode) for client-side encryption (referred to as `v1`).\n\n\n## Recommendation\nConsider switching to `v2` client-side encryption.\n\n\n## Example\n\n```csharp\n\n{\n    SymmetricKey aesKey = new SymmetricKey(kid: \"symencryptionkey\");\n\n    // BAD: Using the outdated client side encryption version V1_0\n    BlobEncryptionPolicy uploadPolicy = new BlobEncryptionPolicy(key: aesKey, keyResolver: null);\n    BlobRequestOptions uploadOptions = new BlobRequestOptions() { EncryptionPolicy = uploadPolicy };\n\n    MemoryStream stream = new MemoryStream(buffer);\n    blob.UploadFromStream(stream, length: size, accessCondition: null, options: uploadOptions);\n}\n\nvar client = new BlobClient(myConnectionString, new SpecializedBlobClientOptions()\n{\n    // BAD: Using an outdated SDK that does not support client side encryption version V2_0\n    ClientSideEncryption = new ClientSideEncryptionOptions() \n    {\n        KeyEncryptionKey = myKey,\n        KeyResolver = myKeyResolver,\n        KeyWrapAlgorithm = myKeyWrapAlgorithm\n    }\n});\n\nvar client = new BlobClient(myConnectionString, new SpecializedBlobClientOptions()\n{\n    // BAD: Using the outdated client side encryption version V1_0\n    ClientSideEncryption = new ClientSideEncryptionOptions(ClientSideEncryptionVersion.V1_0) \n    {\n        KeyEncryptionKey = myKey,\n        KeyResolver = myKeyResolver,\n        KeyWrapAlgorithm = myKeyWrapAlgorithm\n    }\n});\n\nvar client = new BlobClient(myConnectionString, new SpecializedBlobClientOptions()\n{\n    // GOOD: Using client side encryption version V2_0\n    ClientSideEncryption = new ClientSideEncryptionOptions(ClientSideEncryptionVersion.V2_0) \n    {\n        KeyEncryptionKey = myKey,\n        KeyResolver = myKeyResolver,\n        KeyWrapAlgorithm = myKeyWrapAlgorithm\n    }\n});\n```\n\n## References\n* [Azure Storage Client Encryption Blog.](http://aka.ms/azstorageclientencryptionblog)\n* [CVE-2022-30187](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2022-30187)\n* Common Weakness Enumeration: [CWE-327](https://cwe.mitre.org/data/definitions/327.html).\n",
                  "markdown": "# Unsafe usage of v1 version of Azure Storage client-side encryption (CVE-2022-30187).\nAzure Storage .NET, Java, and Python SDKs support encryption on the client with a customer-managed key that is maintained in Azure Key Vault or another key store.\n\nCurrent release versions of the Azure Storage SDKs use cipher block chaining (CBC mode) for client-side encryption (referred to as `v1`).\n\n\n## Recommendation\nConsider switching to `v2` client-side encryption.\n\n\n## Example\n\n```csharp\n\n{\n    SymmetricKey aesKey = new SymmetricKey(kid: \"symencryptionkey\");\n\n    // BAD: Using the outdated client side encryption version V1_0\n    BlobEncryptionPolicy uploadPolicy = new BlobEncryptionPolicy(key: aesKey, keyResolver: null);\n    BlobRequestOptions uploadOptions = new BlobRequestOptions() { EncryptionPolicy = uploadPolicy };\n\n    MemoryStream stream = new MemoryStream(buffer);\n    blob.UploadFromStream(stream, length: size, accessCondition: null, options: uploadOptions);\n}\n\nvar client = new BlobClient(myConnectionString, new SpecializedBlobClientOptions()\n{\n    // BAD: Using an outdated SDK that does not support client side encryption version V2_0\n    ClientSideEncryption = new ClientSideEncryptionOptions() \n    {\n        KeyEncryptionKey = myKey,\n        KeyResolver = myKeyResolver,\n        KeyWrapAlgorithm = myKeyWrapAlgorithm\n    }\n});\n\nvar client = new BlobClient(myConnectionString, new SpecializedBlobClientOptions()\n{\n    // BAD: Using the outdated client side encryption version V1_0\n    ClientSideEncryption = new ClientSideEncryptionOptions(ClientSideEncryptionVersion.V1_0) \n    {\n        KeyEncryptionKey = myKey,\n        KeyResolver = myKeyResolver,\n        KeyWrapAlgorithm = myKeyWrapAlgorithm\n    }\n});\n\nvar client = new BlobClient(myConnectionString, new SpecializedBlobClientOptions()\n{\n    // GOOD: Using client side encryption version V2_0\n    ClientSideEncryption = new ClientSideEncryptionOptions(ClientSideEncryptionVersion.V2_0) \n    {\n        KeyEncryptionKey = myKey,\n        KeyResolver = myKeyResolver,\n        KeyWrapAlgorithm = myKeyWrapAlgorithm\n    }\n});\n```\n\n## References\n* [Azure Storage Client Encryption Blog.](http://aka.ms/azstorageclientencryptionblog)\n* [CVE-2022-30187](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2022-30187)\n* Common Weakness Enumeration: [CWE-327](https://cwe.mitre.org/data/definitions/327.html).\n"
                },
                "properties": {
                  "tags": [
                    "security",
                    "cryptography",
                    "experimental",
                    "external/cwe/cwe-327"
                  ],
                  "description": "Unsafe usage of v1 version of Azure Storage client-side encryption, please refer to http://aka.ms/azstorageclientencryptionblog",
                  "id": "cs/azure-storage/unsafe-usage-of-client-side-encryption-version",
                  "kind": "problem",
                  "name": "Unsafe usage of v1 version of Azure Storage client-side encryption (CVE-2022-30187).",
                  "precision": "high",
                  "problem.severity": "error"
                }
              },
              {
                "id": "cs/web/cookie-secure-not-set",
                "name": "cs/web/cookie-secure-not-set",
                "shortDescription": {
                  "text": "'Secure' attribute is not set to true"
                },
                "fullDescription": {
                  "text": "Omitting the 'Secure' attribute allows data to be transmitted insecurely using HTTP. Always set 'Secure' to 'true' to ensure that HTTPS is used at all times."
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "error"
                },
                "help": {
                  "text": "# 'Secure' attribute is not set to true\nSensitive data that is transmitted using HTTP is vulnerable to being read by a third party. By default, cookies are sent via HTTP, not HTTPS.\n\n\n## Recommendation\nIn ASP.NET case when using cookies ensure that HTTPS is used by setting the property `Microsoft.AspNetCore.Http.CookieOptions.Secure` to `true`.\n\nIn ASP.NET Core case when using cookies, ensure that HTTPS is used, either via the `<forms>` attribute above, or the `<httpCookies>` element, with the attribute `requireSSL=\"true\"`. It is also possible to require cookies to use HTTPS programmatically, by setting the property `System.Web.HttpCookie.Secure` to `true`.\n\n\n## Example\nIn the example below `Microsoft.AspNetCore.Http.CookieOptions.Secure` is set to `true` programmatically.\n\n\n```csharp\nclass MyController : Controller\n{\n    void Login()\n    {\n        var cookieOptions = new Microsoft.AspNetCore.Http.CookieOptions() { Secure = true };\n        Response.Cookies.Append(\"auth\", \"secret\", cookieOptions);\n    }\n}\n```\nIn the following example `CookiePolicyOptions` are set programmatically to configure defaults.\n\n\n```csharp\npublic class Startup\n{\n    // This method gets called by the runtime. Use this method to configure the HTTP request pipeline.\n    public void Configure(IApplicationBuilder app, IWebHostEnvironment env)\n    {\n        app.UseCookiePolicy(new CookiePolicyOptions()\n        {\n            Secure = Microsoft.AspNetCore.Http.CookieSecurePolicy.Always,\n            HttpOnly = Microsoft.AspNetCore.CookiePolicy.HttpOnlyPolicy.Always\n        });\n    }\n}\n```\nIn the example below `System.Web.HttpCookie.Secure` is set to `true` programmatically.\n\n\n```csharp\nclass MyController : Controller\n{\n    void Login()\n    {\n        var cookie = new System.Web.HttpCookie(\"cookieName\") { Secure = true };\n    }\n}\n```\n\n## References\n* [CookieOptions.Secure Property,](https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.http.cookieoptions.secure)\n* [Set-Cookie](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie) Header,\n* [FormsAuthentication.RequireSSL Property,](https://msdn.microsoft.com/en-us/library/system.web.security.formsauthentication.requiressl(v=vs.110).aspx)\n* [forms Element for authentication,](https://msdn.microsoft.com/en-us/library/1d3t3c61(v=vs.100).aspx)\n* [httpCookies Element,](https://msdn.microsoft.com/library/ms228262%28v=vs.100%29.aspx)\n* Common Weakness Enumeration: [CWE-319](https://cwe.mitre.org/data/definitions/319.html).\n* Common Weakness Enumeration: [CWE-614](https://cwe.mitre.org/data/definitions/614.html).\n",
                  "markdown": "# 'Secure' attribute is not set to true\nSensitive data that is transmitted using HTTP is vulnerable to being read by a third party. By default, cookies are sent via HTTP, not HTTPS.\n\n\n## Recommendation\nIn ASP.NET case when using cookies ensure that HTTPS is used by setting the property `Microsoft.AspNetCore.Http.CookieOptions.Secure` to `true`.\n\nIn ASP.NET Core case when using cookies, ensure that HTTPS is used, either via the `<forms>` attribute above, or the `<httpCookies>` element, with the attribute `requireSSL=\"true\"`. It is also possible to require cookies to use HTTPS programmatically, by setting the property `System.Web.HttpCookie.Secure` to `true`.\n\n\n## Example\nIn the example below `Microsoft.AspNetCore.Http.CookieOptions.Secure` is set to `true` programmatically.\n\n\n```csharp\nclass MyController : Controller\n{\n    void Login()\n    {\n        var cookieOptions = new Microsoft.AspNetCore.Http.CookieOptions() { Secure = true };\n        Response.Cookies.Append(\"auth\", \"secret\", cookieOptions);\n    }\n}\n```\nIn the following example `CookiePolicyOptions` are set programmatically to configure defaults.\n\n\n```csharp\npublic class Startup\n{\n    // This method gets called by the runtime. Use this method to configure the HTTP request pipeline.\n    public void Configure(IApplicationBuilder app, IWebHostEnvironment env)\n    {\n        app.UseCookiePolicy(new CookiePolicyOptions()\n        {\n            Secure = Microsoft.AspNetCore.Http.CookieSecurePolicy.Always,\n            HttpOnly = Microsoft.AspNetCore.CookiePolicy.HttpOnlyPolicy.Always\n        });\n    }\n}\n```\nIn the example below `System.Web.HttpCookie.Secure` is set to `true` programmatically.\n\n\n```csharp\nclass MyController : Controller\n{\n    void Login()\n    {\n        var cookie = new System.Web.HttpCookie(\"cookieName\") { Secure = true };\n    }\n}\n```\n\n## References\n* [CookieOptions.Secure Property,](https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.http.cookieoptions.secure)\n* [Set-Cookie](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie) Header,\n* [FormsAuthentication.RequireSSL Property,](https://msdn.microsoft.com/en-us/library/system.web.security.formsauthentication.requiressl(v=vs.110).aspx)\n* [forms Element for authentication,](https://msdn.microsoft.com/en-us/library/1d3t3c61(v=vs.100).aspx)\n* [httpCookies Element,](https://msdn.microsoft.com/library/ms228262%28v=vs.100%29.aspx)\n* Common Weakness Enumeration: [CWE-319](https://cwe.mitre.org/data/definitions/319.html).\n* Common Weakness Enumeration: [CWE-614](https://cwe.mitre.org/data/definitions/614.html).\n"
                },
                "properties": {
                  "tags": [
                    "security",
                    "experimental",
                    "external/cwe/cwe-319",
                    "external/cwe/cwe-614"
                  ],
                  "description": "Omitting the 'Secure' attribute allows data to be transmitted insecurely\n              using HTTP. Always set 'Secure' to 'true' to ensure that HTTPS\n              is used at all times.",
                  "id": "cs/web/cookie-secure-not-set",
                  "kind": "problem",
                  "name": "'Secure' attribute is not set to true",
                  "precision": "high",
                  "problem.severity": "error"
                }
              },
              {
                "id": "cs/dataset-serialization/defining-dataset-related-type",
                "name": "cs/dataset-serialization/defining-dataset-related-type",
                "shortDescription": {
                  "text": "Defining a class that inherits or has a property derived from the obsolete DataSet or DataTable types"
                },
                "fullDescription": {
                  "text": "Defining a class that inherits or has a property derived from the obsolete DataSet or DataTable types may lead to the usage of dangerous functionality. Please visit https://go.microsoft.com/fwlink/?linkid=2132227 for details."
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning"
                },
                "help": {
                  "text": "# Defining a class that inherits or has a property derived from the obsolete DataSet or DataTable types\nThe `DataSet` and `DataTable` types are legacy .NET components that you can use to represent data sets as managed objects.\n\nWhile `DataSet` and `DataTable` do impose default limitations on the types that are allowed to be present while deserializing XML payloads, `DataSet` and `DataTable` are in general not safe when populated with untrusted input.\n\nPlease visit [DataSet and DataTable security guidance](https://go.microsoft.com/fwlink/?linkid=2132227) for more details.\n\n\n## Recommendation\nPlease review the [DataSet and DataTable security guidance](https://go.microsoft.com/fwlink/?linkid=2132227) before making use of these types for serialization.\n\n\n## References\n* Microsoft Docs[DataSet and DataTable security guidance](https://go.microsoft.com/fwlink/?linkid=2132227).\n",
                  "markdown": "# Defining a class that inherits or has a property derived from the obsolete DataSet or DataTable types\nThe `DataSet` and `DataTable` types are legacy .NET components that you can use to represent data sets as managed objects.\n\nWhile `DataSet` and `DataTable` do impose default limitations on the types that are allowed to be present while deserializing XML payloads, `DataSet` and `DataTable` are in general not safe when populated with untrusted input.\n\nPlease visit [DataSet and DataTable security guidance](https://go.microsoft.com/fwlink/?linkid=2132227) for more details.\n\n\n## Recommendation\nPlease review the [DataSet and DataTable security guidance](https://go.microsoft.com/fwlink/?linkid=2132227) before making use of these types for serialization.\n\n\n## References\n* Microsoft Docs[DataSet and DataTable security guidance](https://go.microsoft.com/fwlink/?linkid=2132227).\n"
                },
                "properties": {
                  "tags": [
                    "security",
                    "experimental"
                  ],
                  "description": "Defining a class that inherits or has a property derived from the obsolete DataSet or DataTable types may lead to the usage of dangerous functionality. Please visit https://go.microsoft.com/fwlink/?linkid=2132227 for details.",
                  "id": "cs/dataset-serialization/defining-dataset-related-type",
                  "kind": "problem",
                  "name": "Defining a class that inherits or has a property derived from the obsolete DataSet or DataTable types",
                  "problem.severity": "warning"
                }
              },
              {
                "id": "cs/dataset-serialization/xml-deserialization-with-dataset",
                "name": "cs/dataset-serialization/xml-deserialization-with-dataset",
                "shortDescription": {
                  "text": "XML deserialization with a type type derived from DataSet or DataTable"
                },
                "fullDescription": {
                  "text": "Making an XML deserialization call with a type derived from DataSet or DataTable types and may lead to a security problem. Please visit https://go.microsoft.com/fwlink/?linkid=2132227 for details.\""
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "error"
                },
                "help": {
                  "text": "# XML deserialization with a type type derived from DataSet or DataTable\nThe `DataSet` and `DataTable` types are legacy .NET components that you can use to represent data sets as managed objects.\n\nWhile `DataSet` and `DataTable` do impose default limitations on the types that are allowed to be present while deserializing XML payloads, `DataSet` and `DataTable` are in general not safe when populated with untrusted input.\n\nPlease visit [DataSet and DataTable security guidance](https://go.microsoft.com/fwlink/?linkid=2132227) for more details.\n\n\n## Recommendation\nPlease review the [DataSet and DataTable security guidance](https://go.microsoft.com/fwlink/?linkid=2132227) before making use of these types for serialization.\n\n\n## References\n* Microsoft Docs[DataSet and DataTable security guidance](https://go.microsoft.com/fwlink/?linkid=2132227).\n",
                  "markdown": "# XML deserialization with a type type derived from DataSet or DataTable\nThe `DataSet` and `DataTable` types are legacy .NET components that you can use to represent data sets as managed objects.\n\nWhile `DataSet` and `DataTable` do impose default limitations on the types that are allowed to be present while deserializing XML payloads, `DataSet` and `DataTable` are in general not safe when populated with untrusted input.\n\nPlease visit [DataSet and DataTable security guidance](https://go.microsoft.com/fwlink/?linkid=2132227) for more details.\n\n\n## Recommendation\nPlease review the [DataSet and DataTable security guidance](https://go.microsoft.com/fwlink/?linkid=2132227) before making use of these types for serialization.\n\n\n## References\n* Microsoft Docs[DataSet and DataTable security guidance](https://go.microsoft.com/fwlink/?linkid=2132227).\n"
                },
                "properties": {
                  "tags": [
                    "security",
                    "experimental"
                  ],
                  "description": "Making an XML deserialization call with a type derived from DataSet or DataTable types and may lead to a security problem. Please visit https://go.microsoft.com/fwlink/?linkid=2132227 for details.\"",
                  "id": "cs/dataset-serialization/xml-deserialization-with-dataset",
                  "kind": "problem",
                  "name": "XML deserialization with a type type derived from DataSet or DataTable",
                  "precision": "medium",
                  "problem.severity": "error"
                }
              },
              {
                "id": "cs/dataset-serialization/defining-potentially-unsafe-xml-serializer",
                "name": "cs/dataset-serialization/defining-potentially-unsafe-xml-serializer",
                "shortDescription": {
                  "text": "Defining a potentially unsafe XML serializer"
                },
                "fullDescription": {
                  "text": "Defining an XML serializable class that includes members that derive from DataSet or DataTable type may lead to a security problem. Please visit https://go.microsoft.com/fwlink/?linkid=2132227 for details."
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "error"
                },
                "help": {
                  "text": "# Defining a potentially unsafe XML serializer\nThe `DataSet` and `DataTable` types are legacy .NET components that you can use to represent data sets as managed objects.\n\nWhile `DataSet` and `DataTable` do impose default limitations on the types that are allowed to be present while deserializing XML payloads, `DataSet` and `DataTable` are in general not safe when populated with untrusted input.\n\nPlease visit [DataSet and DataTable security guidance](https://go.microsoft.com/fwlink/?linkid=2132227) for more details.\n\n\n## Recommendation\nPlease review the [DataSet and DataTable security guidance](https://go.microsoft.com/fwlink/?linkid=2132227) before making use of these types for serialization.\n\n\n## References\n* Microsoft Docs[DataSet and DataTable security guidance](https://go.microsoft.com/fwlink/?linkid=2132227).\n",
                  "markdown": "# Defining a potentially unsafe XML serializer\nThe `DataSet` and `DataTable` types are legacy .NET components that you can use to represent data sets as managed objects.\n\nWhile `DataSet` and `DataTable` do impose default limitations on the types that are allowed to be present while deserializing XML payloads, `DataSet` and `DataTable` are in general not safe when populated with untrusted input.\n\nPlease visit [DataSet and DataTable security guidance](https://go.microsoft.com/fwlink/?linkid=2132227) for more details.\n\n\n## Recommendation\nPlease review the [DataSet and DataTable security guidance](https://go.microsoft.com/fwlink/?linkid=2132227) before making use of these types for serialization.\n\n\n## References\n* Microsoft Docs[DataSet and DataTable security guidance](https://go.microsoft.com/fwlink/?linkid=2132227).\n"
                },
                "properties": {
                  "tags": [
                    "security",
                    "experimental"
                  ],
                  "description": "Defining an XML serializable class that includes members that derive from DataSet or DataTable type may lead to a security problem. Please visit https://go.microsoft.com/fwlink/?linkid=2132227 for details.",
                  "id": "cs/dataset-serialization/defining-potentially-unsafe-xml-serializer",
                  "kind": "problem",
                  "name": "Defining a potentially unsafe XML serializer",
                  "precision": "medium",
                  "problem.severity": "error"
                }
              },
              {
                "id": "cs/dataset-serialization/unsafe-type-used-data-contract-serializer",
                "name": "cs/dataset-serialization/unsafe-type-used-data-contract-serializer",
                "shortDescription": {
                  "text": "Unsafe type is used in data contract serializer"
                },
                "fullDescription": {
                  "text": "Unsafe type is used in data contract serializer. Please visit https://go.microsoft.com/fwlink/?linkid=2132227 for details.\""
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "error"
                },
                "help": {
                  "text": "# Unsafe type is used in data contract serializer\nThe `DataSet` and `DataTable` types are legacy .NET components that you can use to represent data sets as managed objects.\n\nWhile `DataSet` and `DataTable` do impose default limitations on the types that are allowed to be present while deserializing XML payloads, `DataSet` and `DataTable` are in general not safe when populated with untrusted input.\n\nPlease visit [DataSet and DataTable security guidance](https://go.microsoft.com/fwlink/?linkid=2132227) for more details.\n\n\n## Recommendation\nPlease review the [DataSet and DataTable security guidance](https://go.microsoft.com/fwlink/?linkid=2132227) before making use of these types for serialization.\n\n\n## References\n* Microsoft Docs[DataSet and DataTable security guidance](https://go.microsoft.com/fwlink/?linkid=2132227).\n",
                  "markdown": "# Unsafe type is used in data contract serializer\nThe `DataSet` and `DataTable` types are legacy .NET components that you can use to represent data sets as managed objects.\n\nWhile `DataSet` and `DataTable` do impose default limitations on the types that are allowed to be present while deserializing XML payloads, `DataSet` and `DataTable` are in general not safe when populated with untrusted input.\n\nPlease visit [DataSet and DataTable security guidance](https://go.microsoft.com/fwlink/?linkid=2132227) for more details.\n\n\n## Recommendation\nPlease review the [DataSet and DataTable security guidance](https://go.microsoft.com/fwlink/?linkid=2132227) before making use of these types for serialization.\n\n\n## References\n* Microsoft Docs[DataSet and DataTable security guidance](https://go.microsoft.com/fwlink/?linkid=2132227).\n"
                },
                "properties": {
                  "tags": [
                    "security",
                    "experimental"
                  ],
                  "description": "Unsafe type is used in data contract serializer. Please visit https://go.microsoft.com/fwlink/?linkid=2132227 for details.\"",
                  "id": "cs/dataset-serialization/unsafe-type-used-data-contract-serializer",
                  "kind": "problem",
                  "name": "Unsafe type is used in data contract serializer",
                  "precision": "medium",
                  "problem.severity": "error"
                }
              },
              {
                "id": "cs/hash-without-salt",
                "name": "cs/hash-without-salt",
                "shortDescription": {
                  "text": "Use of a hash function without a salt"
                },
                "fullDescription": {
                  "text": "Hashed passwords without a salt are vulnerable to dictionary attacks."
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "error"
                },
                "help": {
                  "text": "# Use of a hash function without a salt\nIn cryptography, a salt is some random data used as an additional input to a one-way function that hashes a password or pass-phrase. It makes dictionary attacks more difficult.\n\nWithout a salt, it is much easier for attackers to pre-compute the hash value using dictionary attack techniques such as rainbow tables to crack passwords.\n\n\n## Recommendation\nUse a long random salt of at least 32 bytes then use the combination of password and salt to hash a password or password phrase.\n\n\n## Example\nThe following example shows two ways of hashing. In the 'BAD' cases, no salt is provided. In the 'GOOD' cases, a salt is provided.\n\n\n```csharp\npublic class Test\n{\n    private const int SaltSize = 32;\n\n    // BAD - Hash without a salt.\n    public static String HashPassword(string password, string strAlgName =\"SHA256\")\n    {\n        IBuffer passBuff = CryptographicBuffer.ConvertStringToBinary(password, BinaryStringEncoding.Utf8);\n        HashAlgorithmProvider algProvider = HashAlgorithmProvider.OpenAlgorithm(strAlgName);\n        IBuffer hashBuff = algProvider.HashData(passBuff);\n        return CryptographicBuffer.EncodeToBase64String(hashBuff);\n    }\n\n    // GOOD - Hash with a salt.\n    public static string HashPassword2(string password, string salt, string strAlgName =\"SHA256\")\n    {\n        // Concatenate the salt with the password.\n        IBuffer passBuff = CryptographicBuffer.ConvertStringToBinary(password+salt, BinaryStringEncoding.Utf8);\n        HashAlgorithmProvider algProvider = HashAlgorithmProvider.OpenAlgorithm(strAlgName);\n        IBuffer hashBuff = algProvider.HashData(passBuff);\n        return CryptographicBuffer.EncodeToBase64String(hashBuff);\n    }\n\n    // BAD - Hash without a salt.\n    public static string HashPassword(string password)\n    {\n        SHA256 sha256Hash = SHA256.Create();\n        byte[] passBytes = System.Text.Encoding.ASCII.GetBytes(password);\n        byte[] hashBytes = sha256Hash.ComputeHash(passBytes);\n        return Convert.ToBase64String(hashBytes);\n    }\n\n    // GOOD - Hash with a salt.\n    public static string HashPassword2(string password)\n    {\n        byte[] passBytes = System.Text.Encoding.ASCII.GetBytes(password);\n        byte[] saltBytes = GenerateSalt();\n\n        // Add the salt to the hash.\n        byte[] rawSalted  = new byte[passBytes.Length + saltBytes.Length]; \n        passBytes.CopyTo(rawSalted, 0);\n        saltBytes.CopyTo(rawSalted, passBytes.Length);\n\n        //Create the salted hash.         \n        SHA256 sha256 = SHA256.Create();\n        byte[] saltedPassBytes = sha256.ComputeHash(rawSalted);\n\n        // Add the salt value to the salted hash.\n        byte[] dbPassword  = new byte[saltedPassBytes.Length + saltBytes.Length];\n        saltedPassBytes.CopyTo(dbPassword, 0);\n        saltBytes.CopyTo(dbPassword, saltedPassBytes.Length);\n\n        return Convert.ToBase64String(dbPassword);\n    }\n\n    public static byte[] GenerateSalt()\n    {\n        using (var rng = new RNGCryptoServiceProvider())\n        {\n            var randomNumber = new byte[SaltSize];\n            rng.GetBytes(randomNumber);\n            return randomNumber;\n        }\n    }\n}\n\n```\n\n## References\n* DZone: [A Look at Java Cryptography](https://dzone.com/articles/a-look-at-java-cryptography)\n* CWE: [CWE-759: Use of a One-Way Hash without a Salt](https://cwe.mitre.org/data/definitions/759.html)\n* Common Weakness Enumeration: [CWE-759](https://cwe.mitre.org/data/definitions/759.html).\n",
                  "markdown": "# Use of a hash function without a salt\nIn cryptography, a salt is some random data used as an additional input to a one-way function that hashes a password or pass-phrase. It makes dictionary attacks more difficult.\n\nWithout a salt, it is much easier for attackers to pre-compute the hash value using dictionary attack techniques such as rainbow tables to crack passwords.\n\n\n## Recommendation\nUse a long random salt of at least 32 bytes then use the combination of password and salt to hash a password or password phrase.\n\n\n## Example\nThe following example shows two ways of hashing. In the 'BAD' cases, no salt is provided. In the 'GOOD' cases, a salt is provided.\n\n\n```csharp\npublic class Test\n{\n    private const int SaltSize = 32;\n\n    // BAD - Hash without a salt.\n    public static String HashPassword(string password, string strAlgName =\"SHA256\")\n    {\n        IBuffer passBuff = CryptographicBuffer.ConvertStringToBinary(password, BinaryStringEncoding.Utf8);\n        HashAlgorithmProvider algProvider = HashAlgorithmProvider.OpenAlgorithm(strAlgName);\n        IBuffer hashBuff = algProvider.HashData(passBuff);\n        return CryptographicBuffer.EncodeToBase64String(hashBuff);\n    }\n\n    // GOOD - Hash with a salt.\n    public static string HashPassword2(string password, string salt, string strAlgName =\"SHA256\")\n    {\n        // Concatenate the salt with the password.\n        IBuffer passBuff = CryptographicBuffer.ConvertStringToBinary(password+salt, BinaryStringEncoding.Utf8);\n        HashAlgorithmProvider algProvider = HashAlgorithmProvider.OpenAlgorithm(strAlgName);\n        IBuffer hashBuff = algProvider.HashData(passBuff);\n        return CryptographicBuffer.EncodeToBase64String(hashBuff);\n    }\n\n    // BAD - Hash without a salt.\n    public static string HashPassword(string password)\n    {\n        SHA256 sha256Hash = SHA256.Create();\n        byte[] passBytes = System.Text.Encoding.ASCII.GetBytes(password);\n        byte[] hashBytes = sha256Hash.ComputeHash(passBytes);\n        return Convert.ToBase64String(hashBytes);\n    }\n\n    // GOOD - Hash with a salt.\n    public static string HashPassword2(string password)\n    {\n        byte[] passBytes = System.Text.Encoding.ASCII.GetBytes(password);\n        byte[] saltBytes = GenerateSalt();\n\n        // Add the salt to the hash.\n        byte[] rawSalted  = new byte[passBytes.Length + saltBytes.Length]; \n        passBytes.CopyTo(rawSalted, 0);\n        saltBytes.CopyTo(rawSalted, passBytes.Length);\n\n        //Create the salted hash.         \n        SHA256 sha256 = SHA256.Create();\n        byte[] saltedPassBytes = sha256.ComputeHash(rawSalted);\n\n        // Add the salt value to the salted hash.\n        byte[] dbPassword  = new byte[saltedPassBytes.Length + saltBytes.Length];\n        saltedPassBytes.CopyTo(dbPassword, 0);\n        saltBytes.CopyTo(dbPassword, saltedPassBytes.Length);\n\n        return Convert.ToBase64String(dbPassword);\n    }\n\n    public static byte[] GenerateSalt()\n    {\n        using (var rng = new RNGCryptoServiceProvider())\n        {\n            var randomNumber = new byte[SaltSize];\n            rng.GetBytes(randomNumber);\n            return randomNumber;\n        }\n    }\n}\n\n```\n\n## References\n* DZone: [A Look at Java Cryptography](https://dzone.com/articles/a-look-at-java-cryptography)\n* CWE: [CWE-759: Use of a One-Way Hash without a Salt](https://cwe.mitre.org/data/definitions/759.html)\n* Common Weakness Enumeration: [CWE-759](https://cwe.mitre.org/data/definitions/759.html).\n"
                },
                "properties": {
                  "tags": [
                    "security",
                    "experimental",
                    "external/cwe/cwe-759"
                  ],
                  "description": "Hashed passwords without a salt are vulnerable to dictionary attacks.",
                  "id": "cs/hash-without-salt",
                  "kind": "path-problem",
                  "name": "Use of a hash function without a salt",
                  "problem.severity": "error"
                }
              },
              {
                "id": "cs/json-webtoken-handler/security-validations-disabled",
                "name": "cs/json-webtoken-handler/security-validations-disabled",
                "shortDescription": {
                  "text": "Security sensitive JsonWebTokenHandler validations are disabled"
                },
                "fullDescription": {
                  "text": "Check if security sensitive token validations for `JsonWebTokenHandler` are being disabled."
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "error"
                },
                "help": {
                  "text": "# Security sensitive JsonWebTokenHandler validations are disabled\nToken validation checks ensure that while validating tokens, all aspects are analyzed and verified. Turning off validation can lead to security holes by allowing untrusted tokens to make it through validation.\n\n\n## Recommendation\nSet `Microsoft.IdentityModel.Tokens.TokenValidationParameters` properties `RequireExpirationTime`, `ValidateAudience`, `ValidateIssuer`, or `ValidateLifetime` to `true`. Or, remove the assignment to `false` because the default value is `true`.\n\n\n## Example\nThis example disabled the validation.\n\n\n```csharp\nusing System;\nusing Microsoft.IdentityModel.Tokens;\nclass TestClass\n{\n    public void TestMethod()\n    {\n        TokenValidationParameters parameters = new TokenValidationParameters();\n        parameters.RequireExpirationTime = false;\n        parameters.ValidateAudience = false;\n        parameters.ValidateIssuer = false;\n        parameters.ValidateLifetime = false;\n    }\n}\n```\nTo fix it, do not disable the validations or use the default value.\n\n\n```csharp\nusing System;\nusing Microsoft.IdentityModel.Tokens;\nclass TestClass\n{\n    public void TestMethod()\n    {\n        TokenValidationParameters parameters = new TokenValidationParameters();\n        parameters.RequireExpirationTime = true;\n        parameters.ValidateAudience = true;\n        parameters.ValidateIssuer = true;\n        parameters.ValidateLifetime = true;\n    }\n}\n```\n\n## References\n* [azure-activedirectory-identitymodel-extensions-for-dotnet ValidatingTokens wiki](https://aka.ms/wilson/tokenvalidation)\n",
                  "markdown": "# Security sensitive JsonWebTokenHandler validations are disabled\nToken validation checks ensure that while validating tokens, all aspects are analyzed and verified. Turning off validation can lead to security holes by allowing untrusted tokens to make it through validation.\n\n\n## Recommendation\nSet `Microsoft.IdentityModel.Tokens.TokenValidationParameters` properties `RequireExpirationTime`, `ValidateAudience`, `ValidateIssuer`, or `ValidateLifetime` to `true`. Or, remove the assignment to `false` because the default value is `true`.\n\n\n## Example\nThis example disabled the validation.\n\n\n```csharp\nusing System;\nusing Microsoft.IdentityModel.Tokens;\nclass TestClass\n{\n    public void TestMethod()\n    {\n        TokenValidationParameters parameters = new TokenValidationParameters();\n        parameters.RequireExpirationTime = false;\n        parameters.ValidateAudience = false;\n        parameters.ValidateIssuer = false;\n        parameters.ValidateLifetime = false;\n    }\n}\n```\nTo fix it, do not disable the validations or use the default value.\n\n\n```csharp\nusing System;\nusing Microsoft.IdentityModel.Tokens;\nclass TestClass\n{\n    public void TestMethod()\n    {\n        TokenValidationParameters parameters = new TokenValidationParameters();\n        parameters.RequireExpirationTime = true;\n        parameters.ValidateAudience = true;\n        parameters.ValidateIssuer = true;\n        parameters.ValidateLifetime = true;\n    }\n}\n```\n\n## References\n* [azure-activedirectory-identitymodel-extensions-for-dotnet ValidatingTokens wiki](https://aka.ms/wilson/tokenvalidation)\n"
                },
                "properties": {
                  "tags": [
                    "security",
                    "experimental",
                    "JsonWebTokenHandler",
                    "manual-verification-required"
                  ],
                  "description": "Check if security sensitive token validations for `JsonWebTokenHandler` are being disabled.",
                  "id": "cs/json-webtoken-handler/security-validations-disabled",
                  "kind": "problem",
                  "name": "Security sensitive JsonWebTokenHandler validations are disabled",
                  "precision": "high",
                  "problem.severity": "error"
                }
              },
              {
                "id": "cs/json-webtoken-handler/delegated-security-validations-always-return-true",
                "name": "cs/json-webtoken-handler/delegated-security-validations-always-return-true",
                "shortDescription": {
                  "text": "Delegated security sensitive validations for JsonWebTokenHandler always return true, medium precision"
                },
                "fullDescription": {
                  "text": "Security sensitive validations for `JsonWebTokenHandler` are being delegated to a function that seems to always return true. Higher precision version checks for exception throws, so less false positives are expected."
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "error"
                },
                "help": {
                  "text": "# Delegated security sensitive validations for JsonWebTokenHandler always return true, medium precision\nBy setting critical `TokenValidationParameter` validation delegates to always return `true`, important authentication safeguards are disabled. Disabling safeguards can lead to incorrect validation of tokens from any issuer or expired tokens.\n\n\n## Recommendation\nImprove the logic of the delegate so not all code paths return `true`, which effectively disables that type of validation; or throw `SecurityTokenInvalidAudienceException` or `SecurityTokenInvalidLifetimeException` in failure cases when you want to fail validation and have other cases pass by returning `true`.\n\n\n## Example\nThis example delegates `AudienceValidator` to a callable that always returns true.\n\n\n```csharp\nusing System;\nusing Microsoft.IdentityModel.Tokens;\nclass TestClass\n{\n    public void TestMethod()\n    {\n        TokenValidationParameters parameters = new TokenValidationParameters();\n        parameters.AudienceValidator = (audiences, token, tvp) => { return true; };\n    }\n}\n```\nTo fix it, use a callable that performs a validation, and fails when appropriate.\n\n\n```csharp\nusing System;\nusing Microsoft.IdentityModel.Tokens;\nclass TestClass\n{\n    public void TestMethod()\n    {\n        TokenValidationParameters parameters = new TokenValidationParameters();\n        parameters.AudienceValidator = (audiences, token, tvp) =>\n        {\n            // Implement your own custom audience validation\n            if (PerformCustomAudienceValidation(audiences, token))\n                return true;\n            else\n                return false;\n        };\n    }\n}\n```\n\n## References\n* [azure-activedirectory-identitymodel-extensions-for-dotnet ValidatingTokens wiki](https://aka.ms/wilson/tokenvalidation)\n",
                  "markdown": "# Delegated security sensitive validations for JsonWebTokenHandler always return true, medium precision\nBy setting critical `TokenValidationParameter` validation delegates to always return `true`, important authentication safeguards are disabled. Disabling safeguards can lead to incorrect validation of tokens from any issuer or expired tokens.\n\n\n## Recommendation\nImprove the logic of the delegate so not all code paths return `true`, which effectively disables that type of validation; or throw `SecurityTokenInvalidAudienceException` or `SecurityTokenInvalidLifetimeException` in failure cases when you want to fail validation and have other cases pass by returning `true`.\n\n\n## Example\nThis example delegates `AudienceValidator` to a callable that always returns true.\n\n\n```csharp\nusing System;\nusing Microsoft.IdentityModel.Tokens;\nclass TestClass\n{\n    public void TestMethod()\n    {\n        TokenValidationParameters parameters = new TokenValidationParameters();\n        parameters.AudienceValidator = (audiences, token, tvp) => { return true; };\n    }\n}\n```\nTo fix it, use a callable that performs a validation, and fails when appropriate.\n\n\n```csharp\nusing System;\nusing Microsoft.IdentityModel.Tokens;\nclass TestClass\n{\n    public void TestMethod()\n    {\n        TokenValidationParameters parameters = new TokenValidationParameters();\n        parameters.AudienceValidator = (audiences, token, tvp) =>\n        {\n            // Implement your own custom audience validation\n            if (PerformCustomAudienceValidation(audiences, token))\n                return true;\n            else\n                return false;\n        };\n    }\n}\n```\n\n## References\n* [azure-activedirectory-identitymodel-extensions-for-dotnet ValidatingTokens wiki](https://aka.ms/wilson/tokenvalidation)\n"
                },
                "properties": {
                  "tags": [
                    "security",
                    "experimental",
                    "JsonWebTokenHandler",
                    "manual-verification-required"
                  ],
                  "description": "Security sensitive validations for `JsonWebTokenHandler` are being delegated to a function that seems to always return true.\n   Higher precision version checks for exception throws, so less false positives are expected.",
                  "id": "cs/json-webtoken-handler/delegated-security-validations-always-return-true",
                  "kind": "problem",
                  "name": "Delegated security sensitive validations for JsonWebTokenHandler always return true, medium precision",
                  "precision": "high",
                  "problem.severity": "error"
                }
              },
              {
                "id": "cs/request-forgery",
                "name": "cs/request-forgery",
                "shortDescription": {
                  "text": "Server-side request forgery"
                },
                "fullDescription": {
                  "text": "Making a network request with user-controlled data in the URL allows for request forgery attacks."
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "error"
                },
                "help": {
                  "text": "# Server-side request forgery\nDirectly incorporating user input into a HTTP request without validating the input can facilitate Server Side Request Forgery (SSRF) attacks. In these attacks, the server may be tricked into making a request and interacting with an attacker-controlled server.\n\n\n## Recommendation\nTo guard against SSRF attacks, it is advisable to avoid putting user input directly into the request URL. Instead, maintain a list of authorized URLs on the server; then choose from that list based on the user input provided.\n\n\n## Example\nThe following example shows an HTTP request parameter being used directly in a forming a new request without validating the input, which facilitates SSRF attacks. It also shows how to remedy the problem by validating the user input against a known fixed string.\n\n\n```csharp\nnamespace RequestForgery.Controllers\n{\n    public class SSRFController : Controller\n    {\n        [HttpPost]\n        [ValidateAntiForgeryToken]\n        public async Task<ActionResult> Bad(string url)\n        {\n            var request = new HttpRequestMessage(HttpMethod.Get, url);\n\n            var client = new HttpClient();\n            await client.SendAsync(request);\n\n            return View();\n        }\n\n        [HttpPost]\n        [ValidateAntiForgeryToken]\n        public async Task<ActionResult> Good(string url)\n        {\n            string baseUrl = \"www.mysecuresite.com/\";\n            if (url.StartsWith(baseUrl))\n            {\n                var request = new HttpRequestMessage(HttpMethod.Get, url);\n                var client = new HttpClient();\n                await client.SendAsync(request);\n\n            }\n\n            return View();\n        }\n    }\n}\n```\n\n## References\n* [OWASP SSRF](https://owasp.org/www-community/attacks/Server_Side_Request_Forgery)\n* Common Weakness Enumeration: [CWE-918](https://cwe.mitre.org/data/definitions/918.html).\n",
                  "markdown": "# Server-side request forgery\nDirectly incorporating user input into a HTTP request without validating the input can facilitate Server Side Request Forgery (SSRF) attacks. In these attacks, the server may be tricked into making a request and interacting with an attacker-controlled server.\n\n\n## Recommendation\nTo guard against SSRF attacks, it is advisable to avoid putting user input directly into the request URL. Instead, maintain a list of authorized URLs on the server; then choose from that list based on the user input provided.\n\n\n## Example\nThe following example shows an HTTP request parameter being used directly in a forming a new request without validating the input, which facilitates SSRF attacks. It also shows how to remedy the problem by validating the user input against a known fixed string.\n\n\n```csharp\nnamespace RequestForgery.Controllers\n{\n    public class SSRFController : Controller\n    {\n        [HttpPost]\n        [ValidateAntiForgeryToken]\n        public async Task<ActionResult> Bad(string url)\n        {\n            var request = new HttpRequestMessage(HttpMethod.Get, url);\n\n            var client = new HttpClient();\n            await client.SendAsync(request);\n\n            return View();\n        }\n\n        [HttpPost]\n        [ValidateAntiForgeryToken]\n        public async Task<ActionResult> Good(string url)\n        {\n            string baseUrl = \"www.mysecuresite.com/\";\n            if (url.StartsWith(baseUrl))\n            {\n                var request = new HttpRequestMessage(HttpMethod.Get, url);\n                var client = new HttpClient();\n                await client.SendAsync(request);\n\n            }\n\n            return View();\n        }\n    }\n}\n```\n\n## References\n* [OWASP SSRF](https://owasp.org/www-community/attacks/Server_Side_Request_Forgery)\n* Common Weakness Enumeration: [CWE-918](https://cwe.mitre.org/data/definitions/918.html).\n"
                },
                "properties": {
                  "tags": [
                    "security",
                    "experimental",
                    "external/cwe/cwe-918"
                  ],
                  "description": "Making a network request with user-controlled data in the URL allows for request forgery attacks.",
                  "id": "cs/request-forgery",
                  "kind": "path-problem",
                  "name": "Server-side request forgery",
                  "precision": "high",
                  "problem.severity": "error"
                }
              },
              {
                "id": "cs/webclient-path-injection",
                "name": "cs/webclient-path-injection",
                "shortDescription": {
                  "text": "Uncontrolled data used in a WebClient"
                },
                "fullDescription": {
                  "text": "The WebClient class allows developers to request resources, accessing resources influenced by users can allow an attacker to access local files."
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "error"
                },
                "help": {
                  "text": "# Uncontrolled data used in a WebClient\nThe WebClient class provides a variety of methods for data transmission and communication with a particular URI. Despite of the class' naming convention, the URI scheme can also identify local resources, not only remote ones. Tainted by user-supplied input, the URI can be leveraged to access resources available on the local file system, therefore leading to the disclosure of sensitive information. This can be trivially achieved by supplying path traversal sequences (../) followed by an existing directory or file path.\n\nSanitization of user-supplied URI values using the `StartsWith(\"https://\")` method is deemed insufficient in preventing arbitrary file reads. This is due to the fact that .NET ignores the protocol handler (https in this case) in URIs like the following: \"https://../../../../etc/passwd\".\n\n\n## Recommendation\nValidate user input before using it to ensure that is a URI of an external resource and not a local one. Potential solutions:\n\n* Sanitize potentially tainted paths using `System.Uri.IsWellFormedUriString`.\n\n## Example\nIn the first example, a domain name is read from a `HttpRequest` and then this domain is requested using the method `DownloadString`. However, a malicious user could enter a local path - for example, \"../../../etc/passwd\" instead of a domain. In the second example, it appears that the user is restricted to the HTTPS protocol handler. However, a malicious user could still enter a local path, since as explained above the protocol handler will be ignored by .net. For example, the string \"https://../../../etc/passwd\" will result in the code reading the file located at \"/etc/passwd\", which is the system's password file. This file would then be sent back to the user, giving them access to all the system's passwords.\n\n\n```csharp\nusing System;\nusing System.IO;\nusing System.Web;\nusing System.Net;\n\npublic class TaintedWebClientHandler : IHttpHandler\n{\n    public void ProcessRequest(HttpContext ctx)\n    {\n        String url = ctx.Request.QueryString[\"domain\"];\n\n        // BAD: This could read any file on the filesystem. (../../../../etc/passwd)\n\t\tusing(WebClient client = new WebClient()) {\n\t\t\tctx.Response.Write(client.DownloadString(url));\n        }\n\n        // BAD: This could still read any file on the filesystem. (https://../../../../etc/passwd)\n        if (url.StartsWith(\"https://\")){\n            using(WebClient client = new WebClient()) {\n                ctx.Response.Write(client.DownloadString(url));\n            }\n        }\n\n        // GOOD: IsWellFormedUriString ensures that it is a valid URL\n        if (Uri.IsWellFormedUriString(url, UriKind.Absolute)){\n            using(WebClient client = new WebClient()) {\n                ctx.Response.Write(client.DownloadString(url));\n            }\n        }\n    }\n}\n\n```\n\n## References\n* OWASP: [Path Traversal](https://owasp.org/www-community/attacks/Path_Traversal).\n* Common Weakness Enumeration: [CWE-99](https://cwe.mitre.org/data/definitions/99.html).\n* Common Weakness Enumeration: [CWE-23](https://cwe.mitre.org/data/definitions/23.html).\n* Common Weakness Enumeration: [CWE-36](https://cwe.mitre.org/data/definitions/36.html).\n* Common Weakness Enumeration: [CWE-73](https://cwe.mitre.org/data/definitions/73.html).\n",
                  "markdown": "# Uncontrolled data used in a WebClient\nThe WebClient class provides a variety of methods for data transmission and communication with a particular URI. Despite of the class' naming convention, the URI scheme can also identify local resources, not only remote ones. Tainted by user-supplied input, the URI can be leveraged to access resources available on the local file system, therefore leading to the disclosure of sensitive information. This can be trivially achieved by supplying path traversal sequences (../) followed by an existing directory or file path.\n\nSanitization of user-supplied URI values using the `StartsWith(\"https://\")` method is deemed insufficient in preventing arbitrary file reads. This is due to the fact that .NET ignores the protocol handler (https in this case) in URIs like the following: \"https://../../../../etc/passwd\".\n\n\n## Recommendation\nValidate user input before using it to ensure that is a URI of an external resource and not a local one. Potential solutions:\n\n* Sanitize potentially tainted paths using `System.Uri.IsWellFormedUriString`.\n\n## Example\nIn the first example, a domain name is read from a `HttpRequest` and then this domain is requested using the method `DownloadString`. However, a malicious user could enter a local path - for example, \"../../../etc/passwd\" instead of a domain. In the second example, it appears that the user is restricted to the HTTPS protocol handler. However, a malicious user could still enter a local path, since as explained above the protocol handler will be ignored by .net. For example, the string \"https://../../../etc/passwd\" will result in the code reading the file located at \"/etc/passwd\", which is the system's password file. This file would then be sent back to the user, giving them access to all the system's passwords.\n\n\n```csharp\nusing System;\nusing System.IO;\nusing System.Web;\nusing System.Net;\n\npublic class TaintedWebClientHandler : IHttpHandler\n{\n    public void ProcessRequest(HttpContext ctx)\n    {\n        String url = ctx.Request.QueryString[\"domain\"];\n\n        // BAD: This could read any file on the filesystem. (../../../../etc/passwd)\n\t\tusing(WebClient client = new WebClient()) {\n\t\t\tctx.Response.Write(client.DownloadString(url));\n        }\n\n        // BAD: This could still read any file on the filesystem. (https://../../../../etc/passwd)\n        if (url.StartsWith(\"https://\")){\n            using(WebClient client = new WebClient()) {\n                ctx.Response.Write(client.DownloadString(url));\n            }\n        }\n\n        // GOOD: IsWellFormedUriString ensures that it is a valid URL\n        if (Uri.IsWellFormedUriString(url, UriKind.Absolute)){\n            using(WebClient client = new WebClient()) {\n                ctx.Response.Write(client.DownloadString(url));\n            }\n        }\n    }\n}\n\n```\n\n## References\n* OWASP: [Path Traversal](https://owasp.org/www-community/attacks/Path_Traversal).\n* Common Weakness Enumeration: [CWE-99](https://cwe.mitre.org/data/definitions/99.html).\n* Common Weakness Enumeration: [CWE-23](https://cwe.mitre.org/data/definitions/23.html).\n* Common Weakness Enumeration: [CWE-36](https://cwe.mitre.org/data/definitions/36.html).\n* Common Weakness Enumeration: [CWE-73](https://cwe.mitre.org/data/definitions/73.html).\n"
                },
                "properties": {
                  "tags": [
                    "security",
                    "experimental",
                    "external/cwe/cwe-099",
                    "external/cwe/cwe-023",
                    "external/cwe/cwe-036",
                    "external/cwe/cwe-073"
                  ],
                  "description": "The WebClient class allows developers to request resources,\n              accessing resources influenced by users can allow an attacker to access local files.",
                  "id": "cs/webclient-path-injection",
                  "kind": "path-problem",
                  "name": "Uncontrolled data used in a WebClient",
                  "precision": "high",
                  "problem.severity": "error"
                }
              },
              {
                "id": "cs/telemetry/external-libs",
                "name": "cs/telemetry/external-libs",
                "shortDescription": {
                  "text": "External libraries"
                },
                "fullDescription": {
                  "text": "A list of external libraries used in the code given by their namespace."
                },
                "defaultConfiguration": {
                  "enabled": true
                },
                "properties": {
                  "tags": [
                    "summary",
                    "telemetry"
                  ],
                  "description": "A list of external libraries used in the code given by their namespace.",
                  "id": "cs/telemetry/external-libs",
                  "kind": "metric",
                  "name": "External libraries"
                }
              },
              {
                "id": "cs/telemetry/supported-external-api-taint",
                "name": "cs/telemetry/supported-external-api-taint",
                "shortDescription": {
                  "text": "Supported flow steps in external libraries"
                },
                "fullDescription": {
                  "text": "A list of 3rd party APIs detected as flow steps. Excludes APIs exposed by test libraries."
                },
                "defaultConfiguration": {
                  "enabled": true
                },
                "properties": {
                  "tags": [
                    "summary",
                    "telemetry"
                  ],
                  "description": "A list of 3rd party APIs detected as flow steps. Excludes APIs exposed by test libraries.",
                  "id": "cs/telemetry/supported-external-api-taint",
                  "kind": "metric",
                  "name": "Supported flow steps in external libraries"
                }
              },
              {
                "id": "cs/telemetry/supported-external-api-sinks",
                "name": "cs/telemetry/supported-external-api-sinks",
                "shortDescription": {
                  "text": "Supported sinks in external libraries"
                },
                "fullDescription": {
                  "text": "A list of 3rd party APIs detected as sinks. Excludes APIs exposed by test libraries."
                },
                "defaultConfiguration": {
                  "enabled": true
                },
                "properties": {
                  "tags": [
                    "summary",
                    "telemetry"
                  ],
                  "description": "A list of 3rd party APIs detected as sinks. Excludes APIs exposed by test libraries.",
                  "id": "cs/telemetry/supported-external-api-sinks",
                  "kind": "metric",
                  "name": "Supported sinks in external libraries"
                }
              },
              {
                "id": "cs/telemetry/supported-external-api-sources",
                "name": "cs/telemetry/supported-external-api-sources",
                "shortDescription": {
                  "text": "Supported sources in external libraries"
                },
                "fullDescription": {
                  "text": "A list of 3rd party APIs detected as sources. Excludes APIs exposed by test libraries."
                },
                "defaultConfiguration": {
                  "enabled": true
                },
                "properties": {
                  "tags": [
                    "summary",
                    "telemetry"
                  ],
                  "description": "A list of 3rd party APIs detected as sources. Excludes APIs exposed by test libraries.",
                  "id": "cs/telemetry/supported-external-api-sources",
                  "kind": "metric",
                  "name": "Supported sources in external libraries"
                }
              },
              {
                "id": "cs/telemetry/extraction-information",
                "name": "cs/telemetry/extraction-information",
                "shortDescription": {
                  "text": "C# extraction information"
                },
                "fullDescription": {
                  "text": "Information about the extraction for a C# database"
                },
                "defaultConfiguration": {
                  "enabled": true
                },
                "properties": {
                  "tags": [
                    "summary",
                    "telemetry"
                  ],
                  "description": "Information about the extraction for a C# database",
                  "id": "cs/telemetry/extraction-information",
                  "kind": "metric",
                  "name": "C# extraction information"
                }
              },
              {
                "id": "cs/telemetry/supported-external-api",
                "name": "cs/telemetry/supported-external-api",
                "shortDescription": {
                  "text": "Usage of supported APIs coming from external libraries"
                },
                "fullDescription": {
                  "text": "A list of supported 3rd party APIs used in the codebase. Excludes APIs exposed by test libraries."
                },
                "defaultConfiguration": {
                  "enabled": true
                },
                "properties": {
                  "tags": [
                    "summary",
                    "telemetry"
                  ],
                  "description": "A list of supported 3rd party APIs used in the codebase. Excludes APIs exposed by test libraries.",
                  "id": "cs/telemetry/supported-external-api",
                  "kind": "metric",
                  "name": "Usage of supported APIs coming from external libraries"
                }
              },
              {
                "id": "cs/telemetry/unsupported-external-api",
                "name": "cs/telemetry/unsupported-external-api",
                "shortDescription": {
                  "text": "Usage of unsupported APIs coming from external libraries"
                },
                "fullDescription": {
                  "text": "A list of 3rd party APIs used in the codebase. Excludes APIs exposed by test libraries."
                },
                "defaultConfiguration": {
                  "enabled": true
                },
                "properties": {
                  "tags": [
                    "summary",
                    "telemetry"
                  ],
                  "description": "A list of 3rd party APIs used in the codebase. Excludes APIs exposed by test libraries.",
                  "id": "cs/telemetry/unsupported-external-api",
                  "kind": "metric",
                  "name": "Usage of unsupported APIs coming from external libraries"
                }
              },
              {
                "id": "cs/summary/lines-of-code",
                "name": "cs/summary/lines-of-code",
                "shortDescription": {
                  "text": "Total lines of C# code in the database"
                },
                "fullDescription": {
                  "text": "The total number of lines of code across all files. This is a useful metric of the size of a database. For all files that were seen during the build, this query counts the lines of code, excluding whitespace or comments."
                },
                "defaultConfiguration": {
                  "enabled": true
                },
                "properties": {
                  "tags": [
                    "summary",
                    "lines-of-code",
                    "debug"
                  ],
                  "description": "The total number of lines of code across all files. This is a useful metric of the size of a database. For all files that were seen during the build, this query counts the lines of code, excluding whitespace or comments.",
                  "id": "cs/summary/lines-of-code",
                  "kind": "metric",
                  "name": "Total lines of C# code in the database"
                }
              }
            ],
            "locations": [
              {
                "uri": "file:///opt/hostedtoolcache/CodeQL/2.20.0/x64/codeql/qlpacks/codeql/csharp-queries/1.0.13/",
                "description": {
                  "text": "The QL pack root directory."
                },
                "properties": {
                  "tags": [
                    "CodeQL/LocalPackRoot"
                  ]
                }
              },
              {
                "uri": "file:///opt/hostedtoolcache/CodeQL/2.20.0/x64/codeql/qlpacks/codeql/csharp-queries/1.0.13/qlpack.yml",
                "description": {
                  "text": "The QL pack definition file."
                },
                "properties": {
                  "tags": [
                    "CodeQL/LocalPackDefinitionFile"
                  ]
                }
              }
            ]
          },
          {
            "name": "codeql/csharp-all",
            "semanticVersion": "4.0.0+3b2e55bc2ac942ac2cf2646f5c69acd081ce8ea2",
            "taxa": [
              {
                "id": "ext/System.model.yml/1/25",
                "properties": {
                  "CodeQL/DataExtensionLocation": {
                    "artifactLocation": {
                      "uri": "ext/System.model.yml"
                    },
                    "region": {
                      "startLine": 43,
                      "startColumn": 9,
                      "endLine": 43,
                      "endColumn": 9
                    }
                  }
                }
              },
              {
                "id": "ext/System.Text.model.yml/0/14",
                "properties": {
                  "CodeQL/DataExtensionLocation": {
                    "artifactLocation": {
                      "uri": "ext/System.Text.model.yml"
                    },
                    "region": {
                      "startLine": 20,
                      "startColumn": 9,
                      "endLine": 20,
                      "endColumn": 9
                    }
                  }
                }
              },
              {
                "id": "ext/Newtonsoft.Json.Linq.model.yml/0/11",
                "properties": {
                  "CodeQL/DataExtensionLocation": {
                    "artifactLocation": {
                      "uri": "ext/Newtonsoft.Json.Linq.model.yml"
                    },
                    "region": {
                      "startLine": 17,
                      "startColumn": 9,
                      "endLine": 17,
                      "endColumn": 9
                    }
                  }
                }
              },
              {
                "id": "ext/Newtonsoft.Json.Linq.model.yml/0/15",
                "properties": {
                  "CodeQL/DataExtensionLocation": {
                    "artifactLocation": {
                      "uri": "ext/Newtonsoft.Json.Linq.model.yml"
                    },
                    "region": {
                      "startLine": 21,
                      "startColumn": 9,
                      "endLine": 21,
                      "endColumn": 9
                    }
                  }
                }
              },
              {
                "id": "ext/System.Text.model.yml/0/5",
                "properties": {
                  "CodeQL/DataExtensionLocation": {
                    "artifactLocation": {
                      "uri": "ext/System.Text.model.yml"
                    },
                    "region": {
                      "startLine": 11,
                      "startColumn": 9,
                      "endLine": 11,
                      "endColumn": 9
                    }
                  }
                }
              }
            ],
            "locations": [
              {
                "uri": "file:///opt/hostedtoolcache/CodeQL/2.20.0/x64/codeql/qlpacks/codeql/csharp-queries/1.0.13/.codeql/libraries/codeql/csharp-all/4.0.0/",
                "description": {
                  "text": "The QL pack root directory."
                },
                "properties": {
                  "tags": [
                    "CodeQL/LocalPackRoot"
                  ]
                }
              },
              {
                "uri": "file:///opt/hostedtoolcache/CodeQL/2.20.0/x64/codeql/qlpacks/codeql/csharp-queries/1.0.13/.codeql/libraries/codeql/csharp-all/4.0.0/qlpack.yml",
                "description": {
                  "text": "The QL pack definition file."
                },
                "properties": {
                  "tags": [
                    "CodeQL/LocalPackDefinitionFile"
                  ]
                }
              }
            ]
          },
          {
            "name": "codeql/threat-models",
            "semanticVersion": "1.0.13+3b2e55bc2ac942ac2cf2646f5c69acd081ce8ea2",
            "locations": [
              {
                "uri": "file:///opt/hostedtoolcache/CodeQL/2.20.0/x64/codeql/qlpacks/codeql/csharp-queries/1.0.13/.codeql/libraries/codeql/threat-models/1.0.13/",
                "description": {
                  "text": "The QL pack root directory."
                },
                "properties": {
                  "tags": [
                    "CodeQL/LocalPackRoot"
                  ]
                }
              },
              {
                "uri": "file:///opt/hostedtoolcache/CodeQL/2.20.0/x64/codeql/qlpacks/codeql/csharp-queries/1.0.13/.codeql/libraries/codeql/threat-models/1.0.13/qlpack.yml",
                "description": {
                  "text": "The QL pack definition file."
                },
                "properties": {
                  "tags": [
                    "CodeQL/LocalPackDefinitionFile"
                  ]
                }
              }
            ]
          },
          {
            "name": "githubsecuritylab/codeql-csharp-queries",
            "semanticVersion": "0.0.4+362912c5ea2620624bd55746b4a4b7b3258d80f1",
            "rules": [
              {
                "id": "githubsecuritylab/hardcoded-salt",
                "name": "githubsecuritylab/hardcoded-salt",
                "shortDescription": {
                  "text": "Hardcoded Salt"
                },
                "fullDescription": {
                  "text": "Hardcoded Salt"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "error"
                },
                "help": {
                  "text": "# Hardcoded Salt\n\n## Summary\n\nHardcoding a salt value in a cryptographic algorithm can make it easier for an attacker to crack the passwords. Even when using a strong algorithm, a salt should be randomly generated and stored with the password.\n\n## Example\n\n```csharp\npublic static string HashPassword(string password)\n{\n    byte[] salt = new byte[16];\n    using (var rng = RandomNumberGenerator.Create())\n    {\n        rng.GetBytes(salt);\n    }\n\n    var pbkdf2 = new Rfc2898DeriveBytes(password, salt, 10000);\n    byte[] hash = pbkdf2.GetBytes(20);\n\n    byte[] hashBytes = new byte[36];\n    Array.Copy(salt, 0, hashBytes, 0, 16);\n    Array.Copy(hash, 0, hashBytes, 16, 20);\n\n    string savedPasswordHash = Convert.ToBase64String(hashBytes);\n\n    return savedPasswordHash;\n}\n```\n",
                  "markdown": "# Hardcoded Salt\n\n## Summary\n\nHardcoding a salt value in a cryptographic algorithm can make it easier for an attacker to crack the passwords. Even when using a strong algorithm, a salt should be randomly generated and stored with the password.\n\n## Example\n\n```csharp\npublic static string HashPassword(string password)\n{\n    byte[] salt = new byte[16];\n    using (var rng = RandomNumberGenerator.Create())\n    {\n        rng.GetBytes(salt);\n    }\n\n    var pbkdf2 = new Rfc2898DeriveBytes(password, salt, 10000);\n    byte[] hash = pbkdf2.GetBytes(20);\n\n    byte[] hashBytes = new byte[36];\n    Array.Copy(salt, 0, hashBytes, 0, 16);\n    Array.Copy(hash, 0, hashBytes, 16, 20);\n\n    string savedPasswordHash = Convert.ToBase64String(hashBytes);\n\n    return savedPasswordHash;\n}\n```\n"
                },
                "properties": {
                  "tags": [
                    "security",
                    "external/cwe/cwe-760"
                  ],
                  "description": "Hardcoded Salt",
                  "id": "githubsecuritylab/hardcoded-salt",
                  "kind": "path-problem",
                  "name": "Hardcoded Salt",
                  "precision": "medium",
                  "problem.severity": "error",
                  "security-severity": "6.1"
                }
              },
              {
                "id": "githubsecuritylab/weak-password-hashing",
                "name": "githubsecuritylab/weak-password-hashing",
                "shortDescription": {
                  "text": "Use of an inappropriate cryptographic hashing algorithm on passwords"
                },
                "fullDescription": {
                  "text": "Using inappropriate cryptographic hashing algorithms with passwords can compromise security."
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning"
                },
                "properties": {
                  "tags": [
                    "security",
                    "external/cwe/cwe-327",
                    "external/cwe/cwe-328",
                    "external/cwe/cwe-916"
                  ],
                  "description": "Using inappropriate cryptographic hashing algorithms with passwords can compromise security.",
                  "id": "githubsecuritylab/weak-password-hashing",
                  "kind": "path-problem",
                  "name": "Use of an inappropriate cryptographic hashing algorithm on passwords",
                  "precision": "high",
                  "problem.severity": "warning",
                  "security-severity": "7.5"
                }
              },
              {
                "id": "githubsecuritylab/weak-sensitive-data-hashing",
                "name": "githubsecuritylab/weak-sensitive-data-hashing",
                "shortDescription": {
                  "text": "Use of a broken or weak cryptographic hashing algorithm on sensitive data"
                },
                "fullDescription": {
                  "text": "Using broken or weak cryptographic hashing algorithms can compromise security."
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning"
                },
                "properties": {
                  "tags": [
                    "security",
                    "external/cwe/cwe-327",
                    "external/cwe/cwe-328"
                  ],
                  "description": "Using broken or weak cryptographic hashing algorithms can compromise security.",
                  "id": "githubsecuritylab/weak-sensitive-data-hashing",
                  "kind": "path-problem",
                  "name": "Use of a broken or weak cryptographic hashing algorithm on sensitive data",
                  "precision": "high",
                  "problem.severity": "warning",
                  "security-severity": "7.5"
                }
              },
              {
                "id": "githubsecuritylab/hardcoded-credentials-symmetricsecuritykey",
                "name": "githubsecuritylab/hardcoded-credentials-symmetricsecuritykey",
                "shortDescription": {
                  "text": "Hard-coded credentials"
                },
                "fullDescription": {
                  "text": "Credentials are hard coded in the source code of the application."
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "error"
                },
                "properties": {
                  "tags": [
                    "security",
                    "external/cwe/cwe-259",
                    "external/cwe/cwe-321",
                    "external/cwe/cwe-798"
                  ],
                  "description": "Credentials are hard coded in the source code of the application.",
                  "id": "githubsecuritylab/hardcoded-credentials-symmetricsecuritykey",
                  "kind": "path-problem",
                  "name": "Hard-coded credentials",
                  "precision": "high",
                  "problem.severity": "error",
                  "security-severity": "9.8"
                }
              }
            ],
            "locations": [
              {
                "uri": "file:///home/runner/.codeql/packages/githubsecuritylab/codeql-csharp-queries/0.0.4/",
                "description": {
                  "text": "The QL pack root directory."
                },
                "properties": {
                  "tags": [
                    "CodeQL/LocalPackRoot"
                  ]
                }
              },
              {
                "uri": "file:///home/runner/.codeql/packages/githubsecuritylab/codeql-csharp-queries/0.0.4/qlpack.yml",
                "description": {
                  "text": "The QL pack definition file."
                },
                "properties": {
                  "tags": [
                    "CodeQL/LocalPackDefinitionFile"
                  ]
                }
              }
            ]
          },
          {
            "name": "codeql/csharp-all",
            "semanticVersion": "0.8.5+d540fc0794dcb2a6c10648b8925403788612e976",
            "locations": [
              {
                "uri": "file:///home/runner/.codeql/packages/githubsecuritylab/codeql-csharp-queries/0.0.4/.codeql/libraries/codeql/csharp-all/0.8.5/",
                "description": {
                  "text": "The QL pack root directory."
                },
                "properties": {
                  "tags": [
                    "CodeQL/LocalPackRoot"
                  ]
                }
              },
              {
                "uri": "file:///home/runner/.codeql/packages/githubsecuritylab/codeql-csharp-queries/0.0.4/.codeql/libraries/codeql/csharp-all/0.8.5/qlpack.yml",
                "description": {
                  "text": "The QL pack definition file."
                },
                "properties": {
                  "tags": [
                    "CodeQL/LocalPackDefinitionFile"
                  ]
                }
              }
            ]
          }
        ]
      },
      "invocations": [
        {
          "toolExecutionNotifications": [
            {
              "locations": [
                {
                  "physicalLocation": {
                    "artifactLocation": {
                      "uri": "Controllers/AuthorizationsController.cs",
                      "uriBaseId": "%SRCROOT%",
                      "index": 2
                    }
                  }
                }
              ],
              "message": {
                "text": ""
              },
              "level": "none",
              "descriptor": {
                "id": "cs/diagnostics/successfully-extracted-files",
                "index": 6,
                "toolComponent": {
                  "index": 4
                }
              },
              "properties": {
                "formattedMessage": {
                  "text": ""
                }
              }
            },
            {
              "locations": [
                {
                  "physicalLocation": {
                    "artifactLocation": {
                      "uri": "Controllers/ImportsController.cs",
                      "uriBaseId": "%SRCROOT%",
                      "index": 0
                    }
                  }
                }
              ],
              "message": {
                "text": ""
              },
              "level": "none",
              "descriptor": {
                "id": "cs/diagnostics/successfully-extracted-files",
                "index": 6,
                "toolComponent": {
                  "index": 4
                }
              },
              "properties": {
                "formattedMessage": {
                  "text": ""
                }
              }
            },
            {
              "locations": [
                {
                  "physicalLocation": {
                    "artifactLocation": {
                      "uri": "Controllers/PasswordResetsController.cs",
                      "uriBaseId": "%SRCROOT%",
                      "index": 6
                    }
                  }
                }
              ],
              "message": {
                "text": ""
              },
              "level": "none",
              "descriptor": {
                "id": "cs/diagnostics/successfully-extracted-files",
                "index": 6,
                "toolComponent": {
                  "index": 4
                }
              },
              "properties": {
                "formattedMessage": {
                  "text": ""
                }
              }
            },
            {
              "locations": [
                {
                  "physicalLocation": {
                    "artifactLocation": {
                      "uri": "Controllers/ProductsController.cs",
                      "uriBaseId": "%SRCROOT%",
                      "index": 1
                    }
                  }
                }
              ],
              "message": {
                "text": ""
              },
              "level": "none",
              "descriptor": {
                "id": "cs/diagnostics/successfully-extracted-files",
                "index": 6,
                "toolComponent": {
                  "index": 4
                }
              },
              "properties": {
                "formattedMessage": {
                  "text": ""
                }
              }
            },
            {
              "locations": [
                {
                  "physicalLocation": {
                    "artifactLocation": {
                      "uri": "Controllers/RegistrationsController.cs",
                      "uriBaseId": "%SRCROOT%",
                      "index": 7
                    }
                  }
                }
              ],
              "message": {
                "text": ""
              },
              "level": "none",
              "descriptor": {
                "id": "cs/diagnostics/successfully-extracted-files",
                "index": 6,
                "toolComponent": {
                  "index": 4
                }
              },
              "properties": {
                "formattedMessage": {
                  "text": ""
                }
              }
            },
            {
              "locations": [
                {
                  "physicalLocation": {
                    "artifactLocation": {
                      "uri": "Controllers/TokensController.cs",
                      "uriBaseId": "%SRCROOT%",
                      "index": 8
                    }
                  }
                }
              ],
              "message": {
                "text": ""
              },
              "level": "none",
              "descriptor": {
                "id": "cs/diagnostics/successfully-extracted-files",
                "index": 6,
                "toolComponent": {
                  "index": 4
                }
              },
              "properties": {
                "formattedMessage": {
                  "text": ""
                }
              }
            },
            {
              "locations": [
                {
                  "physicalLocation": {
                    "artifactLocation": {
                      "uri": "Controllers/UsersController.cs",
                      "uriBaseId": "%SRCROOT%",
                      "index": 9
                    }
                  }
                }
              ],
              "message": {
                "text": ""
              },
              "level": "none",
              "descriptor": {
                "id": "cs/diagnostics/successfully-extracted-files",
                "index": 6,
                "toolComponent": {
                  "index": 4
                }
              },
              "properties": {
                "formattedMessage": {
                  "text": ""
                }
              }
            },
            {
              "locations": [
                {
                  "physicalLocation": {
                    "artifactLocation": {
                      "uri": "Data/GenericDataContext.cs",
                      "uriBaseId": "%SRCROOT%",
                      "index": 10
                    }
                  }
                }
              ],
              "message": {
                "text": ""
              },
              "level": "none",
              "descriptor": {
                "id": "cs/diagnostics/successfully-extracted-files",
                "index": 6,
                "toolComponent": {
                  "index": 4
                }
              },
              "properties": {
                "formattedMessage": {
                  "text": ""
                }
              }
            },
            {
              "locations": [
                {
                  "physicalLocation": {
                    "artifactLocation": {
                      "uri": "Migrations/20180427052355_InitialCreate.Designer.cs",
                      "uriBaseId": "%SRCROOT%",
                      "index": 11
                    }
                  }
                }
              ],
              "message": {
                "text": ""
              },
              "level": "none",
              "descriptor": {
                "id": "cs/diagnostics/successfully-extracted-files",
                "index": 6,
                "toolComponent": {
                  "index": 4
                }
              },
              "properties": {
                "formattedMessage": {
                  "text": ""
                }
              }
            },
            {
              "locations": [
                {
                  "physicalLocation": {
                    "artifactLocation": {
                      "uri": "Migrations/20180427052355_InitialCreate.cs",
                      "uriBaseId": "%SRCROOT%",
                      "index": 12
                    }
                  }
                }
              ],
              "message": {
                "text": ""
              },
              "level": "none",
              "descriptor": {
                "id": "cs/diagnostics/successfully-extracted-files",
                "index": 6,
                "toolComponent": {
                  "index": 4
                }
              },
              "properties": {
                "formattedMessage": {
                  "text": ""
                }
              }
            },
            {
              "locations": [
                {
                  "physicalLocation": {
                    "artifactLocation": {
                      "uri": "Migrations/20180514042927_AddPasswordRestRequest.Designer.cs",
                      "uriBaseId": "%SRCROOT%",
                      "index": 13
                    }
                  }
                }
              ],
              "message": {
                "text": ""
              },
              "level": "none",
              "descriptor": {
                "id": "cs/diagnostics/successfully-extracted-files",
                "index": 6,
                "toolComponent": {
                  "index": 4
                }
              },
              "properties": {
                "formattedMessage": {
                  "text": ""
                }
              }
            },
            {
              "locations": [
                {
                  "physicalLocation": {
                    "artifactLocation": {
                      "uri": "Migrations/20180514042927_AddPasswordRestRequest.cs",
                      "uriBaseId": "%SRCROOT%",
                      "index": 14
                    }
                  }
                }
              ],
              "message": {
                "text": ""
              },
              "level": "none",
              "descriptor": {
                "id": "cs/diagnostics/successfully-extracted-files",
                "index": 6,
                "toolComponent": {
                  "index": 4
                }
              },
              "properties": {
                "formattedMessage": {
                  "text": ""
                }
              }
            },
            {
              "locations": [
                {
                  "physicalLocation": {
                    "artifactLocation": {
                      "uri": "Migrations/20180515161327_AddProduct.Designer.cs",
                      "uriBaseId": "%SRCROOT%",
                      "index": 15
                    }
                  }
                }
              ],
              "message": {
                "text": ""
              },
              "level": "none",
              "descriptor": {
                "id": "cs/diagnostics/successfully-extracted-files",
                "index": 6,
                "toolComponent": {
                  "index": 4
                }
              },
              "properties": {
                "formattedMessage": {
                  "text": ""
                }
              }
            },
            {
              "locations": [
                {
                  "physicalLocation": {
                    "artifactLocation": {
                      "uri": "Migrations/20180515161327_AddProduct.cs",
                      "uriBaseId": "%SRCROOT%",
                      "index": 16
                    }
                  }
                }
              ],
              "message": {
                "text": ""
              },
              "level": "none",
              "descriptor": {
                "id": "cs/diagnostics/successfully-extracted-files",
                "index": 6,
                "toolComponent": {
                  "index": 4
                }
              },
              "properties": {
                "formattedMessage": {
                  "text": ""
                }
              }
            },
            {
              "locations": [
                {
                  "physicalLocation": {
                    "artifactLocation": {
                      "uri": "Migrations/GenericDataContextModelSnapshot.cs",
                      "uriBaseId": "%SRCROOT%",
                      "index": 17
                    }
                  }
                }
              ],
              "message": {
                "text": ""
              },
              "level": "none",
              "descriptor": {
                "id": "cs/diagnostics/successfully-extracted-files",
                "index": 6,
                "toolComponent": {
                  "index": 4
                }
              },
              "properties": {
                "formattedMessage": {
                  "text": ""
                }
              }
            },
            {
              "locations": [
                {
                  "physicalLocation": {
                    "artifactLocation": {
                      "uri": "Models/AuthorizationRequest.cs",
                      "uriBaseId": "%SRCROOT%",
                      "index": 18
                    }
                  }
                }
              ],
              "message": {
                "text": ""
              },
              "level": "none",
              "descriptor": {
                "id": "cs/diagnostics/successfully-extracted-files",
                "index": 6,
                "toolComponent": {
                  "index": 4
                }
              },
              "properties": {
                "formattedMessage": {
                  "text": ""
                }
              }
            },
            {
              "locations": [
                {
                  "physicalLocation": {
                    "artifactLocation": {
                      "uri": "Models/AuthorizationResponse.cs",
                      "uriBaseId": "%SRCROOT%",
                      "index": 19
                    }
                  }
                }
              ],
              "message": {
                "text": ""
              },
              "level": "none",
              "descriptor": {
                "id": "cs/diagnostics/successfully-extracted-files",
                "index": 6,
                "toolComponent": {
                  "index": 4
                }
              },
              "properties": {
                "formattedMessage": {
                  "text": ""
                }
              }
            },
            {
              "locations": [
                {
                  "physicalLocation": {
                    "artifactLocation": {
                      "uri": "Models/PasswordResetRequest.cs",
                      "uriBaseId": "%SRCROOT%",
                      "index": 20
                    }
                  }
                }
              ],
              "message": {
                "text": ""
              },
              "level": "none",
              "descriptor": {
                "id": "cs/diagnostics/successfully-extracted-files",
                "index": 6,
                "toolComponent": {
                  "index": 4
                }
              },
              "properties": {
                "formattedMessage": {
                  "text": ""
                }
              }
            },
            {
              "locations": [
                {
                  "physicalLocation": {
                    "artifactLocation": {
                      "uri": "Models/Product.cs",
                      "uriBaseId": "%SRCROOT%",
                      "index": 21
                    }
                  }
                }
              ],
              "message": {
                "text": ""
              },
              "level": "none",
              "descriptor": {
                "id": "cs/diagnostics/successfully-extracted-files",
                "index": 6,
                "toolComponent": {
                  "index": 4
                }
              },
              "properties": {
                "formattedMessage": {
                  "text": ""
                }
              }
            },
            {
              "locations": [
                {
                  "physicalLocation": {
                    "artifactLocation": {
                      "uri": "Models/RegistrationRequest.cs",
                      "uriBaseId": "%SRCROOT%",
                      "index": 22
                    }
                  }
                }
              ],
              "message": {
                "text": ""
              },
              "level": "none",
              "descriptor": {
                "id": "cs/diagnostics/successfully-extracted-files",
                "index": 6,
                "toolComponent": {
                  "index": 4
                }
              },
              "properties": {
                "formattedMessage": {
                  "text": ""
                }
              }
            },
            {
              "locations": [
                {
                  "physicalLocation": {
                    "artifactLocation": {
                      "uri": "Models/UserUpdateRequest.cs",
                      "uriBaseId": "%SRCROOT%",
                      "index": 23
                    }
                  }
                }
              ],
              "message": {
                "text": ""
              },
              "level": "none",
              "descriptor": {
                "id": "cs/diagnostics/successfully-extracted-files",
                "index": 6,
                "toolComponent": {
                  "index": 4
                }
              },
              "properties": {
                "formattedMessage": {
                  "text": ""
                }
              }
            },
            {
              "locations": [
                {
                  "physicalLocation": {
                    "artifactLocation": {
                      "uri": "Models/User.cs",
                      "uriBaseId": "%SRCROOT%",
                      "index": 3
                    }
                  }
                }
              ],
              "message": {
                "text": ""
              },
              "level": "none",
              "descriptor": {
                "id": "cs/diagnostics/successfully-extracted-files",
                "index": 6,
                "toolComponent": {
                  "index": 4
                }
              },
              "properties": {
                "formattedMessage": {
                  "text": ""
                }
              }
            },
            {
              "locations": [
                {
                  "physicalLocation": {
                    "artifactLocation": {
                      "uri": "Program.cs",
                      "uriBaseId": "%SRCROOT%",
                      "index": 24
                    }
                  }
                }
              ],
              "message": {
                "text": ""
              },
              "level": "none",
              "descriptor": {
                "id": "cs/diagnostics/successfully-extracted-files",
                "index": 6,
                "toolComponent": {
                  "index": 4
                }
              },
              "properties": {
                "formattedMessage": {
                  "text": ""
                }
              }
            },
            {
              "locations": [
                {
                  "physicalLocation": {
                    "artifactLocation": {
                      "uri": "Startup.cs",
                      "uriBaseId": "%SRCROOT%",
                      "index": 4
                    }
                  }
                }
              ],
              "message": {
                "text": ""
              },
              "level": "none",
              "descriptor": {
                "id": "cs/diagnostics/successfully-extracted-files",
                "index": 6,
                "toolComponent": {
                  "index": 4
                }
              },
              "properties": {
                "formattedMessage": {
                  "text": ""
                }
              }
            },
            {
              "locations": [
                {
                  "physicalLocation": {
                    "artifactLocation": {
                      "uri": "obj/Debug/netcoreapp2.0/.NETCoreApp,Version=v2.0.AssemblyAttributes.cs",
                      "uriBaseId": "%SRCROOT%",
                      "index": 25
                    }
                  }
                }
              ],
              "message": {
                "text": ""
              },
              "level": "none",
              "descriptor": {
                "id": "cs/diagnostics/successfully-extracted-files",
                "index": 6,
                "toolComponent": {
                  "index": 4
                }
              },
              "properties": {
                "formattedMessage": {
                  "text": ""
                }
              }
            },
            {
              "locations": [
                {
                  "physicalLocation": {
                    "artifactLocation": {
                      "uri": "obj/Debug/netcoreapp2.0/dvcsharp-core-api.AssemblyInfo.cs",
                      "uriBaseId": "%SRCROOT%",
                      "index": 26
                    }
                  }
                }
              ],
              "message": {
                "text": ""
              },
              "level": "none",
              "descriptor": {
                "id": "cs/diagnostics/successfully-extracted-files",
                "index": 6,
                "toolComponent": {
                  "index": 4
                }
              },
              "properties": {
                "formattedMessage": {
                  "text": ""
                }
              }
            },
            {
              "locations": [
                {
                  "physicalLocation": {
                    "artifactLocation": {
                      "uri": "Startup.cs",
                      "uriBaseId": "%SRCROOT%",
                      "index": 4
                    }
                  }
                }
              ],
              "message": {
                "text": ""
              },
              "level": "none",
              "descriptor": {
                "id": "cli/expected-extracted-files/csharp",
                "index": 0
              },
              "properties": {
                "formattedMessage": {
                  "text": ""
                }
              }
            },
            {
              "locations": [
                {
                  "physicalLocation": {
                    "artifactLocation": {
                      "uri": "Data/GenericDataContext.cs",
                      "uriBaseId": "%SRCROOT%",
                      "index": 10
                    }
                  }
                }
              ],
              "message": {
                "text": ""
              },
              "level": "none",
              "descriptor": {
                "id": "cli/expected-extracted-files/csharp",
                "index": 0
              },
              "properties": {
                "formattedMessage": {
                  "text": ""
                }
              }
            },
            {
              "locations": [
                {
                  "physicalLocation": {
                    "artifactLocation": {
                      "uri": "Migrations/20180515161327_AddProduct.cs",
                      "uriBaseId": "%SRCROOT%",
                      "index": 16
                    }
                  }
                }
              ],
              "message": {
                "text": ""
              },
              "level": "none",
              "descriptor": {
                "id": "cli/expected-extracted-files/csharp",
                "index": 0
              },
              "properties": {
                "formattedMessage": {
                  "text": ""
                }
              }
            },
            {
              "locations": [
                {
                  "physicalLocation": {
                    "artifactLocation": {
                      "uri": "Controllers/UsersController.cs",
                      "uriBaseId": "%SRCROOT%",
                      "index": 9
                    }
                  }
                }
              ],
              "message": {
                "text": ""
              },
              "level": "none",
              "descriptor": {
                "id": "cli/expected-extracted-files/csharp",
                "index": 0
              },
              "properties": {
                "formattedMessage": {
                  "text": ""
                }
              }
            },
            {
              "locations": [
                {
                  "physicalLocation": {
                    "artifactLocation": {
                      "uri": "Migrations/20180514042927_AddPasswordRestRequest.cs",
                      "uriBaseId": "%SRCROOT%",
                      "index": 14
                    }
                  }
                }
              ],
              "message": {
                "text": ""
              },
              "level": "none",
              "descriptor": {
                "id": "cli/expected-extracted-files/csharp",
                "index": 0
              },
              "properties": {
                "formattedMessage": {
                  "text": ""
                }
              }
            },
            {
              "locations": [
                {
                  "physicalLocation": {
                    "artifactLocation": {
                      "uri": "Models/User.cs",
                      "uriBaseId": "%SRCROOT%",
                      "index": 3
                    }
                  }
                }
              ],
              "message": {
                "text": ""
              },
              "level": "none",
              "descriptor": {
                "id": "cli/expected-extracted-files/csharp",
                "index": 0
              },
              "properties": {
                "formattedMessage": {
                  "text": ""
                }
              }
            },
            {
              "locations": [
                {
                  "physicalLocation": {
                    "artifactLocation": {
                      "uri": "Migrations/20180427052355_InitialCreate.cs",
                      "uriBaseId": "%SRCROOT%",
                      "index": 12
                    }
                  }
                }
              ],
              "message": {
                "text": ""
              },
              "level": "none",
              "descriptor": {
                "id": "cli/expected-extracted-files/csharp",
                "index": 0
              },
              "properties": {
                "formattedMessage": {
                  "text": ""
                }
              }
            },
            {
              "locations": [
                {
                  "physicalLocation": {
                    "artifactLocation": {
                      "uri": "Controllers/AuthorizationsController.cs",
                      "uriBaseId": "%SRCROOT%",
                      "index": 2
                    }
                  }
                }
              ],
              "message": {
                "text": ""
              },
              "level": "none",
              "descriptor": {
                "id": "cli/expected-extracted-files/csharp",
                "index": 0
              },
              "properties": {
                "formattedMessage": {
                  "text": ""
                }
              }
            },
            {
              "locations": [
                {
                  "physicalLocation": {
                    "artifactLocation": {
                      "uri": "Controllers/PasswordResetsController.cs",
                      "uriBaseId": "%SRCROOT%",
                      "index": 6
                    }
                  }
                }
              ],
              "message": {
                "text": ""
              },
              "level": "none",
              "descriptor": {
                "id": "cli/expected-extracted-files/csharp",
                "index": 0
              },
              "properties": {
                "formattedMessage": {
                  "text": ""
                }
              }
            },
            {
              "locations": [
                {
                  "physicalLocation": {
                    "artifactLocation": {
                      "uri": "Models/AuthorizationResponse.cs",
                      "uriBaseId": "%SRCROOT%",
                      "index": 19
                    }
                  }
                }
              ],
              "message": {
                "text": ""
              },
              "level": "none",
              "descriptor": {
                "id": "cli/expected-extracted-files/csharp",
                "index": 0
              },
              "properties": {
                "formattedMessage": {
                  "text": ""
                }
              }
            },
            {
              "locations": [
                {
                  "physicalLocation": {
                    "artifactLocation": {
                      "uri": "Models/PasswordResetRequest.cs",
                      "uriBaseId": "%SRCROOT%",
                      "index": 20
                    }
                  }
                }
              ],
              "message": {
                "text": ""
              },
              "level": "none",
              "descriptor": {
                "id": "cli/expected-extracted-files/csharp",
                "index": 0
              },
              "properties": {
                "formattedMessage": {
                  "text": ""
                }
              }
            },
            {
              "locations": [
                {
                  "physicalLocation": {
                    "artifactLocation": {
                      "uri": "Models/UserUpdateRequest.cs",
                      "uriBaseId": "%SRCROOT%",
                      "index": 23
                    }
                  }
                }
              ],
              "message": {
                "text": ""
              },
              "level": "none",
              "descriptor": {
                "id": "cli/expected-extracted-files/csharp",
                "index": 0
              },
              "properties": {
                "formattedMessage": {
                  "text": ""
                }
              }
            },
            {
              "locations": [
                {
                  "physicalLocation": {
                    "artifactLocation": {
                      "uri": "Models/RegistrationRequest.cs",
                      "uriBaseId": "%SRCROOT%",
                      "index": 22
                    }
                  }
                }
              ],
              "message": {
                "text": ""
              },
              "level": "none",
              "descriptor": {
                "id": "cli/expected-extracted-files/csharp",
                "index": 0
              },
              "properties": {
                "formattedMessage": {
                  "text": ""
                }
              }
            },
            {
              "locations": [
                {
                  "physicalLocation": {
                    "artifactLocation": {
                      "uri": "Controllers/ProductsController.cs",
                      "uriBaseId": "%SRCROOT%",
                      "index": 1
                    }
                  }
                }
              ],
              "message": {
                "text": ""
              },
              "level": "none",
              "descriptor": {
                "id": "cli/expected-extracted-files/csharp",
                "index": 0
              },
              "properties": {
                "formattedMessage": {
                  "text": ""
                }
              }
            },
            {
              "locations": [
                {
                  "physicalLocation": {
                    "artifactLocation": {
                      "uri": "Controllers/TokensController.cs",
                      "uriBaseId": "%SRCROOT%",
                      "index": 8
                    }
                  }
                }
              ],
              "message": {
                "text": ""
              },
              "level": "none",
              "descriptor": {
                "id": "cli/expected-extracted-files/csharp",
                "index": 0
              },
              "properties": {
                "formattedMessage": {
                  "text": ""
                }
              }
            },
            {
              "locations": [
                {
                  "physicalLocation": {
                    "artifactLocation": {
                      "uri": "Migrations/20180515161327_AddProduct.Designer.cs",
                      "uriBaseId": "%SRCROOT%",
                      "index": 15
                    }
                  }
                }
              ],
              "message": {
                "text": ""
              },
              "level": "none",
              "descriptor": {
                "id": "cli/expected-extracted-files/csharp",
                "index": 0
              },
              "properties": {
                "formattedMessage": {
                  "text": ""
                }
              }
            },
            {
              "locations": [
                {
                  "physicalLocation": {
                    "artifactLocation": {
                      "uri": "Program.cs",
                      "uriBaseId": "%SRCROOT%",
                      "index": 24
                    }
                  }
                }
              ],
              "message": {
                "text": ""
              },
              "level": "none",
              "descriptor": {
                "id": "cli/expected-extracted-files/csharp",
                "index": 0
              },
              "properties": {
                "formattedMessage": {
                  "text": ""
                }
              }
            },
            {
              "locations": [
                {
                  "physicalLocation": {
                    "artifactLocation": {
                      "uri": "Migrations/GenericDataContextModelSnapshot.cs",
                      "uriBaseId": "%SRCROOT%",
                      "index": 17
                    }
                  }
                }
              ],
              "message": {
                "text": ""
              },
              "level": "none",
              "descriptor": {
                "id": "cli/expected-extracted-files/csharp",
                "index": 0
              },
              "properties": {
                "formattedMessage": {
                  "text": ""
                }
              }
            },
            {
              "locations": [
                {
                  "physicalLocation": {
                    "artifactLocation": {
                      "uri": "Migrations/20180514042927_AddPasswordRestRequest.Designer.cs",
                      "uriBaseId": "%SRCROOT%",
                      "index": 13
                    }
                  }
                }
              ],
              "message": {
                "text": ""
              },
              "level": "none",
              "descriptor": {
                "id": "cli/expected-extracted-files/csharp",
                "index": 0
              },
              "properties": {
                "formattedMessage": {
                  "text": ""
                }
              }
            },
            {
              "locations": [
                {
                  "physicalLocation": {
                    "artifactLocation": {
                      "uri": "Models/AuthorizationRequest.cs",
                      "uriBaseId": "%SRCROOT%",
                      "index": 18
                    }
                  }
                }
              ],
              "message": {
                "text": ""
              },
              "level": "none",
              "descriptor": {
                "id": "cli/expected-extracted-files/csharp",
                "index": 0
              },
              "properties": {
                "formattedMessage": {
                  "text": ""
                }
              }
            },
            {
              "locations": [
                {
                  "physicalLocation": {
                    "artifactLocation": {
                      "uri": "Migrations/20180427052355_InitialCreate.Designer.cs",
                      "uriBaseId": "%SRCROOT%",
                      "index": 11
                    }
                  }
                }
              ],
              "message": {
                "text": ""
              },
              "level": "none",
              "descriptor": {
                "id": "cli/expected-extracted-files/csharp",
                "index": 0
              },
              "properties": {
                "formattedMessage": {
                  "text": ""
                }
              }
            },
            {
              "locations": [
                {
                  "physicalLocation": {
                    "artifactLocation": {
                      "uri": "Controllers/RegistrationsController.cs",
                      "uriBaseId": "%SRCROOT%",
                      "index": 7
                    }
                  }
                }
              ],
              "message": {
                "text": ""
              },
              "level": "none",
              "descriptor": {
                "id": "cli/expected-extracted-files/csharp",
                "index": 0
              },
              "properties": {
                "formattedMessage": {
                  "text": ""
                }
              }
            },
            {
              "locations": [
                {
                  "physicalLocation": {
                    "artifactLocation": {
                      "uri": "Controllers/ImportsController.cs",
                      "uriBaseId": "%SRCROOT%",
                      "index": 0
                    }
                  }
                }
              ],
              "message": {
                "text": ""
              },
              "level": "none",
              "descriptor": {
                "id": "cli/expected-extracted-files/csharp",
                "index": 0
              },
              "properties": {
                "formattedMessage": {
                  "text": ""
                }
              }
            },
            {
              "locations": [
                {
                  "physicalLocation": {
                    "artifactLocation": {
                      "uri": "Models/Product.cs",
                      "uriBaseId": "%SRCROOT%",
                      "index": 21
                    }
                  }
                }
              ],
              "message": {
                "text": ""
              },
              "level": "none",
              "descriptor": {
                "id": "cli/expected-extracted-files/csharp",
                "index": 0
              },
              "properties": {
                "formattedMessage": {
                  "text": ""
                }
              }
            },
            {
              "message": {
                "text": "C# does not support path-based filtering. The `paths` and `paths-ignore` configuration properties will have no effect for this language. If desired, you can use the [advanced-security/filter-sarif Action](https://github.com/advanced-security/filter-sarif) to rewrite the SARIF file to exclude alerts from these paths.",
                "markdown": "C# does not support path-based filtering. The `paths` and `paths-ignore` configuration properties will have no effect for this language. If desired, you can use the [advanced-security/filter-sarif Action](https://github.com/advanced-security/filter-sarif) to rewrite the SARIF file to exclude alerts from these paths."
              },
              "level": "note",
              "timeUtc": "2024-12-12T06:45:31.629294774Z",
              "descriptor": {
                "id": "cli/csharp/path-filtering-not-supported",
                "index": 1
              },
              "properties": {
                "visibility": {
                  "statusPage": true,
                  "telemetry": true
                }
              }
            },
            {
              "message": {
                "text": ""
              },
              "level": "none",
              "timeUtc": "2024-12-12T06:45:12.306Z",
              "descriptor": {
                "id": "codeql-action/bundle-download-telemetry",
                "index": 2
              },
              "properties": {
                "attributes": {
                  "cacheDurationMs": 12514.064393999999,
                  "combinedDurationMs": 9996,
                  "compressionMethod": "zstd",
                  "downloadDurationMs": 4322,
                  "extractionDurationMs": 5674,
                  "streamExtraction": false,
                  "toolsUrl": "https://github.com/github/codeql-action/releases/download/codeql-bundle-v2.20.0/codeql-bundle-linux64.tar.zst"
                },
                "visibility": {
                  "statusPage": false,
                  "telemetry": true
                }
              }
            }
          ],
          "executionSuccessful": true
        }
      ],
      "artifacts": [
        {
          "location": {
            "uri": "Controllers/ImportsController.cs",
            "uriBaseId": "%SRCROOT%",
            "index": 0
          }
        },
        {
          "location": {
            "uri": "Controllers/ProductsController.cs",
            "uriBaseId": "%SRCROOT%",
            "index": 1
          }
        },
        {
          "location": {
            "uri": "Controllers/AuthorizationsController.cs",
            "uriBaseId": "%SRCROOT%",
            "index": 2
          }
        },
        {
          "location": {
            "uri": "Models/User.cs",
            "uriBaseId": "%SRCROOT%",
            "index": 3
          }
        },
        {
          "location": {
            "uri": "Startup.cs",
            "uriBaseId": "%SRCROOT%",
            "index": 4
          }
        },
        {
          "location": {
            "uri": "file:/home/runner/.nuget/packages/microsoft.identitymodel.tokens/5.2.2/lib/netstandard1.4/Microsoft.IdentityModel.Tokens.dll",
            "index": 5
          }
        },
        {
          "location": {
            "uri": "Controllers/PasswordResetsController.cs",
            "uriBaseId": "%SRCROOT%",
            "index": 6
          }
        },
        {
          "location": {
            "uri": "Controllers/RegistrationsController.cs",
            "uriBaseId": "%SRCROOT%",
            "index": 7
          }
        },
        {
          "location": {
            "uri": "Controllers/TokensController.cs",
            "uriBaseId": "%SRCROOT%",
            "index": 8
          }
        },
        {
          "location": {
            "uri": "Controllers/UsersController.cs",
            "uriBaseId": "%SRCROOT%",
            "index": 9
          }
        },
        {
          "location": {
            "uri": "Data/GenericDataContext.cs",
            "uriBaseId": "%SRCROOT%",
            "index": 10
          }
        },
        {
          "location": {
            "uri": "Migrations/20180427052355_InitialCreate.Designer.cs",
            "uriBaseId": "%SRCROOT%",
            "index": 11
          }
        },
        {
          "location": {
            "uri": "Migrations/20180427052355_InitialCreate.cs",
            "uriBaseId": "%SRCROOT%",
            "index": 12
          }
        },
        {
          "location": {
            "uri": "Migrations/20180514042927_AddPasswordRestRequest.Designer.cs",
            "uriBaseId": "%SRCROOT%",
            "index": 13
          }
        },
        {
          "location": {
            "uri": "Migrations/20180514042927_AddPasswordRestRequest.cs",
            "uriBaseId": "%SRCROOT%",
            "index": 14
          }
        },
        {
          "location": {
            "uri": "Migrations/20180515161327_AddProduct.Designer.cs",
            "uriBaseId": "%SRCROOT%",
            "index": 15
          }
        },
        {
          "location": {
            "uri": "Migrations/20180515161327_AddProduct.cs",
            "uriBaseId": "%SRCROOT%",
            "index": 16
          }
        },
        {
          "location": {
            "uri": "Migrations/GenericDataContextModelSnapshot.cs",
            "uriBaseId": "%SRCROOT%",
            "index": 17
          }
        },
        {
          "location": {
            "uri": "Models/AuthorizationRequest.cs",
            "uriBaseId": "%SRCROOT%",
            "index": 18
          }
        },
        {
          "location": {
            "uri": "Models/AuthorizationResponse.cs",
            "uriBaseId": "%SRCROOT%",
            "index": 19
          }
        },
        {
          "location": {
            "uri": "Models/PasswordResetRequest.cs",
            "uriBaseId": "%SRCROOT%",
            "index": 20
          }
        },
        {
          "location": {
            "uri": "Models/Product.cs",
            "uriBaseId": "%SRCROOT%",
            "index": 21
          }
        },
        {
          "location": {
            "uri": "Models/RegistrationRequest.cs",
            "uriBaseId": "%SRCROOT%",
            "index": 22
          }
        },
        {
          "location": {
            "uri": "Models/UserUpdateRequest.cs",
            "uriBaseId": "%SRCROOT%",
            "index": 23
          }
        },
        {
          "location": {
            "uri": "Program.cs",
            "uriBaseId": "%SRCROOT%",
            "index": 24
          }
        },
        {
          "location": {
            "uri": "obj/Debug/netcoreapp2.0/.NETCoreApp,Version=v2.0.AssemblyAttributes.cs",
            "uriBaseId": "%SRCROOT%",
            "index": 25
          }
        },
        {
          "location": {
            "uri": "obj/Debug/netcoreapp2.0/dvcsharp-core-api.AssemblyInfo.cs",
            "uriBaseId": "%SRCROOT%",
            "index": 26
          }
        }
      ],
      "results": [
        {
          "ruleId": "cs/unsafe-deserialization",
          "rule": {
            "id": "cs/unsafe-deserialization",
            "index": 17,
            "toolComponent": {
              "index": 4
            }
          },
          "message": {
            "text": "Unsafe deserializer is used. Make sure the value being deserialized comes from a trusted source."
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "Controllers/ImportsController.cs",
                  "uriBaseId": "%SRCROOT%",
                  "index": 0
                },
                "region": {
                  "startLine": 46,
                  "startColumn": 26,
                  "endColumn": 50
                }
              }
            }
          ],
          "partialFingerprints": {
            "primaryLocationLineHash": "4387e1d58ac4479b:1",
            "primaryLocationStartColumnFingerprint": "13"
          }
        },
        {
          "ruleId": "cs/xml/missing-validation",
          "rule": {
            "id": "cs/xml/missing-validation",
            "index": 43,
            "toolComponent": {
              "index": 4
            }
          },
          "message": {
            "text": "This XML processing depends on a [user-provided value](1) without validation because there is no 'XmlReaderSettings' instance specifying schema validation."
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "Controllers/ProductsController.cs",
                  "uriBaseId": "%SRCROOT%",
                  "index": 1
                },
                "region": {
                  "startLine": 82,
                  "startColumn": 46,
                  "endColumn": 70
                }
              }
            }
          ],
          "partialFingerprints": {
            "primaryLocationLineHash": "ab26b5cc0038e8c1:1",
            "primaryLocationStartColumnFingerprint": "36"
          },
          "relatedLocations": [
            {
              "id": 1,
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "Controllers/ProductsController.cs",
                  "uriBaseId": "%SRCROOT%",
                  "index": 1
                },
                "region": {
                  "startLine": 82,
                  "startColumn": 46,
                  "endColumn": 70
                }
              },
              "message": {
                "text": "user-provided value"
              }
            }
          ]
        },
        {
          "ruleId": "cs/user-controlled-bypass",
          "rule": {
            "id": "cs/user-controlled-bypass",
            "index": 44,
            "toolComponent": {
              "index": 4
            }
          },
          "message": {
            "text": "This condition guards a sensitive [action](1), but a [user-provided value](2) controls it."
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "Controllers/AuthorizationsController.cs",
                  "uriBaseId": "%SRCROOT%",
                  "index": 2
                },
                "region": {
                  "startLine": 53,
                  "startColumn": 13,
                  "endColumn": 27
                }
              }
            }
          ],
          "partialFingerprints": {
            "primaryLocationLineHash": "1f526a9241aae5c6:1",
            "primaryLocationStartColumnFingerprint": "3"
          },
          "codeFlows": [
            {
              "threadFlows": [
                {
                  "locations": [
                    {
                      "location": {
                        "physicalLocation": {
                          "artifactLocation": {
                            "uri": "Controllers/AuthorizationsController.cs",
                            "uriBaseId": "%SRCROOT%",
                            "index": 2
                          },
                          "region": {
                            "startLine": 43,
                            "startColumn": 30,
                            "endColumn": 57
                          }
                        },
                        "message": {
                          "text": "access to property Cookies : IRequestCookieCollection"
                        }
                      }
                    },
                    {
                      "location": {
                        "physicalLocation": {
                          "artifactLocation": {
                            "uri": "Controllers/AuthorizationsController.cs",
                            "uriBaseId": "%SRCROOT%",
                            "index": 2
                          },
                          "region": {
                            "startLine": 43,
                            "startColumn": 14,
                            "endColumn": 27
                          }
                        },
                        "message": {
                          "text": "access to local variable ssoCookieData : String"
                        }
                      }
                    },
                    {
                      "location": {
                        "physicalLocation": {
                          "artifactLocation": {
                            "uri": "Controllers/AuthorizationsController.cs",
                            "uriBaseId": "%SRCROOT%",
                            "index": 2
                          },
                          "region": {
                            "startLine": 49,
                            "startColumn": 58,
                            "endColumn": 71
                          }
                        },
                        "message": {
                          "text": "access to local variable ssoCookieData : String"
                        }
                      }
                    },
                    {
                      "location": {
                        "physicalLocation": {
                          "artifactLocation": {
                            "uri": "Controllers/AuthorizationsController.cs",
                            "uriBaseId": "%SRCROOT%",
                            "index": 2
                          },
                          "region": {
                            "startLine": 49,
                            "startColumn": 33,
                            "endColumn": 72
                          }
                        },
                        "message": {
                          "text": "call to method FromBase64String : Byte[] [element] : Object"
                        }
                      },
                      "taxa": [
                        {
                          "index": 0,
                          "toolComponent": {
                            "index": 5
                          },
                          "properties": {
                            "CodeQL/DataflowRole": "step"
                          }
                        }
                      ]
                    },
                    {
                      "location": {
                        "physicalLocation": {
                          "artifactLocation": {
                            "uri": "Controllers/AuthorizationsController.cs",
                            "uriBaseId": "%SRCROOT%",
                            "index": 2
                          },
                          "region": {
                            "startLine": 49,
                            "startColumn": 14,
                            "endColumn": 30
                          }
                        },
                        "message": {
                          "text": "access to local variable ssoCookieDecoded : Byte[] [element] : Object"
                        }
                      }
                    },
                    {
                      "location": {
                        "physicalLocation": {
                          "artifactLocation": {
                            "uri": "Controllers/AuthorizationsController.cs",
                            "uriBaseId": "%SRCROOT%",
                            "index": 2
                          },
                          "region": {
                            "startLine": 50,
                            "startColumn": 76,
                            "endColumn": 92
                          }
                        },
                        "message": {
                          "text": "access to local variable ssoCookieDecoded : Byte[] [element] : Object"
                        }
                      }
                    },
                    {
                      "location": {
                        "physicalLocation": {
                          "artifactLocation": {
                            "uri": "Controllers/AuthorizationsController.cs",
                            "uriBaseId": "%SRCROOT%",
                            "index": 2
                          },
                          "region": {
                            "startLine": 50,
                            "startColumn": 40,
                            "endColumn": 93
                          }
                        },
                        "message": {
                          "text": "call to method GetString : String"
                        }
                      },
                      "taxa": [
                        {
                          "index": 1,
                          "toolComponent": {
                            "index": 5
                          },
                          "properties": {
                            "CodeQL/DataflowRole": "step"
                          }
                        }
                      ]
                    },
                    {
                      "location": {
                        "physicalLocation": {
                          "artifactLocation": {
                            "uri": "Controllers/AuthorizationsController.cs",
                            "uriBaseId": "%SRCROOT%",
                            "index": 2
                          },
                          "region": {
                            "startLine": 50,
                            "startColumn": 26,
                            "endColumn": 94
                          }
                        },
                        "message": {
                          "text": "call to method Parse : JObject"
                        }
                      },
                      "taxa": [
                        {
                          "index": 2,
                          "toolComponent": {
                            "index": 5
                          },
                          "properties": {
                            "CodeQL/DataflowRole": "step"
                          }
                        }
                      ]
                    },
                    {
                      "location": {
                        "physicalLocation": {
                          "artifactLocation": {
                            "uri": "Controllers/AuthorizationsController.cs",
                            "uriBaseId": "%SRCROOT%",
                            "index": 2
                          },
                          "region": {
                            "startLine": 50,
                            "startColumn": 14,
                            "endColumn": 23
                          }
                        },
                        "message": {
                          "text": "access to local variable ssoCookie : JObject"
                        }
                      }
                    },
                    {
                      "location": {
                        "physicalLocation": {
                          "artifactLocation": {
                            "uri": "Controllers/AuthorizationsController.cs",
                            "uriBaseId": "%SRCROOT%",
                            "index": 2
                          },
                          "region": {
                            "startLine": 53,
                            "startColumn": 13,
                            "endColumn": 27
                          }
                        },
                        "message": {
                          "text": "... == ..."
                        }
                      }
                    }
                  ]
                }
              ]
            },
            {
              "threadFlows": [
                {
                  "locations": [
                    {
                      "location": {
                        "physicalLocation": {
                          "artifactLocation": {
                            "uri": "Controllers/AuthorizationsController.cs",
                            "uriBaseId": "%SRCROOT%",
                            "index": 2
                          },
                          "region": {
                            "startLine": 43,
                            "startColumn": 30,
                            "endColumn": 57
                          }
                        },
                        "message": {
                          "text": "access to property Cookies : IRequestCookieCollection"
                        }
                      }
                    },
                    {
                      "location": {
                        "physicalLocation": {
                          "artifactLocation": {
                            "uri": "Controllers/AuthorizationsController.cs",
                            "uriBaseId": "%SRCROOT%",
                            "index": 2
                          },
                          "region": {
                            "startLine": 43,
                            "startColumn": 14,
                            "endColumn": 27
                          }
                        },
                        "message": {
                          "text": "access to local variable ssoCookieData : String"
                        }
                      }
                    },
                    {
                      "location": {
                        "physicalLocation": {
                          "artifactLocation": {
                            "uri": "Controllers/AuthorizationsController.cs",
                            "uriBaseId": "%SRCROOT%",
                            "index": 2
                          },
                          "region": {
                            "startLine": 49,
                            "startColumn": 58,
                            "endColumn": 71
                          }
                        },
                        "message": {
                          "text": "access to local variable ssoCookieData : String"
                        }
                      }
                    },
                    {
                      "location": {
                        "physicalLocation": {
                          "artifactLocation": {
                            "uri": "Controllers/AuthorizationsController.cs",
                            "uriBaseId": "%SRCROOT%",
                            "index": 2
                          },
                          "region": {
                            "startLine": 49,
                            "startColumn": 33,
                            "endColumn": 72
                          }
                        },
                        "message": {
                          "text": "call to method FromBase64String : Byte[] [element] : Object"
                        }
                      },
                      "taxa": [
                        {
                          "index": 0,
                          "toolComponent": {
                            "index": 5
                          },
                          "properties": {
                            "CodeQL/DataflowRole": "step"
                          }
                        }
                      ]
                    },
                    {
                      "location": {
                        "physicalLocation": {
                          "artifactLocation": {
                            "uri": "Controllers/AuthorizationsController.cs",
                            "uriBaseId": "%SRCROOT%",
                            "index": 2
                          },
                          "region": {
                            "startLine": 49,
                            "startColumn": 14,
                            "endColumn": 30
                          }
                        },
                        "message": {
                          "text": "access to local variable ssoCookieDecoded : Byte[] [element] : Object"
                        }
                      }
                    },
                    {
                      "location": {
                        "physicalLocation": {
                          "artifactLocation": {
                            "uri": "Controllers/AuthorizationsController.cs",
                            "uriBaseId": "%SRCROOT%",
                            "index": 2
                          },
                          "region": {
                            "startLine": 50,
                            "startColumn": 76,
                            "endColumn": 92
                          }
                        },
                        "message": {
                          "text": "access to local variable ssoCookieDecoded : Byte[] [element] : Object"
                        }
                      }
                    },
                    {
                      "location": {
                        "physicalLocation": {
                          "artifactLocation": {
                            "uri": "Controllers/AuthorizationsController.cs",
                            "uriBaseId": "%SRCROOT%",
                            "index": 2
                          },
                          "region": {
                            "startLine": 50,
                            "startColumn": 40,
                            "endColumn": 93
                          }
                        },
                        "message": {
                          "text": "call to method GetString : String"
                        }
                      },
                      "taxa": [
                        {
                          "index": 1,
                          "toolComponent": {
                            "index": 5
                          },
                          "properties": {
                            "CodeQL/DataflowRole": "step"
                          }
                        }
                      ]
                    },
                    {
                      "location": {
                        "physicalLocation": {
                          "artifactLocation": {
                            "uri": "Controllers/AuthorizationsController.cs",
                            "uriBaseId": "%SRCROOT%",
                            "index": 2
                          },
                          "region": {
                            "startLine": 50,
                            "startColumn": 26,
                            "endColumn": 94
                          }
                        },
                        "message": {
                          "text": "call to method Parse : JObject"
                        }
                      },
                      "taxa": [
                        {
                          "index": 2,
                          "toolComponent": {
                            "index": 5
                          },
                          "properties": {
                            "CodeQL/DataflowRole": "step"
                          }
                        }
                      ]
                    },
                    {
                      "location": {
                        "physicalLocation": {
                          "artifactLocation": {
                            "uri": "Controllers/AuthorizationsController.cs",
                            "uriBaseId": "%SRCROOT%",
                            "index": 2
                          },
                          "region": {
                            "startLine": 50,
                            "startColumn": 14,
                            "endColumn": 23
                          }
                        },
                        "message": {
                          "text": "access to local variable ssoCookie : JObject"
                        }
                      }
                    },
                    {
                      "location": {
                        "physicalLocation": {
                          "artifactLocation": {
                            "uri": "Controllers/AuthorizationsController.cs",
                            "uriBaseId": "%SRCROOT%",
                            "index": 2
                          },
                          "region": {
                            "startLine": 52,
                            "startColumn": 23,
                            "endColumn": 32
                          }
                        },
                        "message": {
                          "text": "access to local variable ssoCookie : JObject"
                        }
                      }
                    },
                    {
                      "location": {
                        "physicalLocation": {
                          "artifactLocation": {
                            "uri": "Controllers/AuthorizationsController.cs",
                            "uriBaseId": "%SRCROOT%",
                            "index": 2
                          },
                          "region": {
                            "startLine": 52,
                            "startColumn": 23,
                            "endColumn": 45
                          }
                        },
                        "message": {
                          "text": "access to indexer : JToken"
                        }
                      },
                      "taxa": [
                        {
                          "index": 3,
                          "toolComponent": {
                            "index": 5
                          },
                          "properties": {
                            "CodeQL/DataflowRole": "step"
                          }
                        }
                      ]
                    },
                    {
                      "location": {
                        "physicalLocation": {
                          "artifactLocation": {
                            "uri": "Controllers/AuthorizationsController.cs",
                            "uriBaseId": "%SRCROOT%",
                            "index": 2
                          },
                          "region": {
                            "startLine": 53,
                            "startColumn": 13,
                            "endColumn": 27
                          }
                        },
                        "message": {
                          "text": "... == ..."
                        }
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "relatedLocations": [
            {
              "id": 1,
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "Controllers/AuthorizationsController.cs",
                  "uriBaseId": "%SRCROOT%",
                  "index": 2
                },
                "region": {
                  "startLine": 54,
                  "startColumn": 20,
                  "endColumn": 34
                }
              },
              "message": {
                "text": "action"
              }
            },
            {
              "id": 2,
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "Controllers/AuthorizationsController.cs",
                  "uriBaseId": "%SRCROOT%",
                  "index": 2
                },
                "region": {
                  "startLine": 43,
                  "startColumn": 30,
                  "endColumn": 57
                }
              },
              "message": {
                "text": "user-provided value"
              }
            }
          ]
        },
        {
          "ruleId": "cs/sql-injection",
          "rule": {
            "id": "cs/sql-injection",
            "index": 55,
            "toolComponent": {
              "index": 4
            }
          },
          "message": {
            "text": "This query depends on [this ASP.NET Core MVC action method parameter](1).\nThis query depends on [this ASP.NET Core MVC action method parameter](1)."
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "Controllers/ProductsController.cs",
                  "uriBaseId": "%SRCROOT%",
                  "index": 1
                },
                "region": {
                  "startLine": 73,
                  "startColumn": 22,
                  "endColumn": 27
                }
              }
            }
          ],
          "partialFingerprints": {
            "primaryLocationLineHash": "37240f4cefff6b0:1",
            "primaryLocationStartColumnFingerprint": "9"
          },
          "codeFlows": [
            {
              "threadFlows": [
                {
                  "locations": [
                    {
                      "location": {
                        "physicalLocation": {
                          "artifactLocation": {
                            "uri": "Controllers/ProductsController.cs",
                            "uriBaseId": "%SRCROOT%",
                            "index": 1
                          },
                          "region": {
                            "startLine": 65,
                            "startColumn": 42,
                            "endColumn": 49
                          }
                        },
                        "message": {
                          "text": "keyword : String"
                        }
                      }
                    },
                    {
                      "location": {
                        "physicalLocation": {
                          "artifactLocation": {
                            "uri": "Controllers/ProductsController.cs",
                            "uriBaseId": "%SRCROOT%",
                            "index": 1
                          },
                          "region": {
                            "startLine": 71,
                            "startColumn": 14,
                            "endColumn": 19
                          }
                        },
                        "message": {
                          "text": "access to local variable query : String"
                        }
                      }
                    },
                    {
                      "location": {
                        "physicalLocation": {
                          "artifactLocation": {
                            "uri": "Controllers/ProductsController.cs",
                            "uriBaseId": "%SRCROOT%",
                            "index": 1
                          },
                          "region": {
                            "startLine": 73,
                            "startColumn": 22,
                            "endColumn": 27
                          }
                        },
                        "message": {
                          "text": "call to operator implicit conversion"
                        }
                      }
                    }
                  ]
                }
              ]
            },
            {
              "threadFlows": [
                {
                  "locations": [
                    {
                      "location": {
                        "physicalLocation": {
                          "artifactLocation": {
                            "uri": "Controllers/ProductsController.cs",
                            "uriBaseId": "%SRCROOT%",
                            "index": 1
                          },
                          "region": {
                            "startLine": 65,
                            "startColumn": 42,
                            "endColumn": 49
                          }
                        },
                        "message": {
                          "text": "keyword : String"
                        }
                      }
                    },
                    {
                      "location": {
                        "physicalLocation": {
                          "artifactLocation": {
                            "uri": "Controllers/ProductsController.cs",
                            "uriBaseId": "%SRCROOT%",
                            "index": 1
                          },
                          "region": {
                            "startLine": 71,
                            "startColumn": 14,
                            "endColumn": 19
                          }
                        },
                        "message": {
                          "text": "access to local variable query : String"
                        }
                      }
                    },
                    {
                      "location": {
                        "physicalLocation": {
                          "artifactLocation": {
                            "uri": "Controllers/ProductsController.cs",
                            "uriBaseId": "%SRCROOT%",
                            "index": 1
                          },
                          "region": {
                            "startLine": 73,
                            "startColumn": 22,
                            "endColumn": 27
                          }
                        },
                        "message": {
                          "text": "access to local variable query : String"
                        }
                      }
                    },
                    {
                      "location": {
                        "physicalLocation": {
                          "artifactLocation": {
                            "uri": "Controllers/ProductsController.cs",
                            "uriBaseId": "%SRCROOT%",
                            "index": 1
                          },
                          "region": {
                            "startLine": 73,
                            "startColumn": 22,
                            "endColumn": 27
                          }
                        },
                        "message": {
                          "text": "call to operator implicit conversion"
                        }
                      },
                      "taxa": [
                        {
                          "id": "RawSqlStringConversionSummarizedCallable",
                          "properties": {
                            "CodeQL/DataflowRole": "step"
                          }
                        }
                      ]
                    }
                  ]
                }
              ]
            },
            {
              "threadFlows": [
                {
                  "locations": [
                    {
                      "location": {
                        "physicalLocation": {
                          "artifactLocation": {
                            "uri": "Controllers/ProductsController.cs",
                            "uriBaseId": "%SRCROOT%",
                            "index": 1
                          },
                          "region": {
                            "startLine": 65,
                            "startColumn": 42,
                            "endColumn": 49
                          }
                        },
                        "message": {
                          "text": "keyword : String"
                        }
                      }
                    },
                    {
                      "location": {
                        "physicalLocation": {
                          "artifactLocation": {
                            "uri": "Controllers/ProductsController.cs",
                            "uriBaseId": "%SRCROOT%",
                            "index": 1
                          },
                          "region": {
                            "startLine": 71,
                            "startColumn": 14,
                            "endColumn": 19
                          }
                        },
                        "message": {
                          "text": "access to local variable query : String"
                        }
                      }
                    },
                    {
                      "location": {
                        "physicalLocation": {
                          "artifactLocation": {
                            "uri": "Controllers/ProductsController.cs",
                            "uriBaseId": "%SRCROOT%",
                            "index": 1
                          },
                          "region": {
                            "startLine": 73,
                            "startColumn": 22,
                            "endColumn": 27
                          }
                        },
                        "message": {
                          "text": "access to local variable query"
                        }
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "relatedLocations": [
            {
              "id": 1,
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "Controllers/ProductsController.cs",
                  "uriBaseId": "%SRCROOT%",
                  "index": 1
                },
                "region": {
                  "startLine": 65,
                  "startColumn": 42,
                  "endColumn": 49
                }
              },
              "message": {
                "text": "this ASP.NET Core MVC action method parameter"
              }
            }
          ]
        },
        {
          "ruleId": "cs/hash-without-salt",
          "rule": {
            "id": "cs/hash-without-salt",
            "index": 76,
            "toolComponent": {
              "index": 4
            }
          },
          "message": {
            "text": "[The password](1) is hashed without a salt.\n[The password](2) is hashed without a salt."
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "Models/User.cs",
                  "uriBaseId": "%SRCROOT%",
                  "index": 3
                },
                "region": {
                  "startLine": 74,
                  "startColumn": 37,
                  "endColumn": 82
                }
              }
            }
          ],
          "partialFingerprints": {
            "primaryLocationLineHash": "901fca17e23292b:1",
            "primaryLocationStartColumnFingerprint": "27"
          },
          "codeFlows": [
            {
              "threadFlows": [
                {
                  "locations": [
                    {
                      "location": {
                        "physicalLocation": {
                          "artifactLocation": {
                            "uri": "Models/User.cs",
                            "uriBaseId": "%SRCROOT%",
                            "index": 3
                          },
                          "region": {
                            "startLine": 37,
                            "startColumn": 44,
                            "endColumn": 52
                          }
                        },
                        "message": {
                          "text": "access to parameter password : String"
                        }
                      }
                    },
                    {
                      "location": {
                        "physicalLocation": {
                          "artifactLocation": {
                            "uri": "Models/User.cs",
                            "uriBaseId": "%SRCROOT%",
                            "index": 3
                          },
                          "region": {
                            "startLine": 71,
                            "startColumn": 54,
                            "endColumn": 62
                          }
                        },
                        "message": {
                          "text": "password : String"
                        }
                      }
                    },
                    {
                      "location": {
                        "physicalLocation": {
                          "artifactLocation": {
                            "uri": "Models/User.cs",
                            "uriBaseId": "%SRCROOT%",
                            "index": 3
                          },
                          "region": {
                            "startLine": 74,
                            "startColumn": 73,
                            "endColumn": 81
                          }
                        },
                        "message": {
                          "text": "access to parameter password : String"
                        }
                      }
                    },
                    {
                      "location": {
                        "physicalLocation": {
                          "artifactLocation": {
                            "uri": "Models/User.cs",
                            "uriBaseId": "%SRCROOT%",
                            "index": 3
                          },
                          "region": {
                            "startLine": 74,
                            "startColumn": 37,
                            "endColumn": 82
                          }
                        },
                        "message": {
                          "text": "call to method GetBytes"
                        }
                      },
                      "taxa": [
                        {
                          "index": 4,
                          "toolComponent": {
                            "index": 5
                          },
                          "properties": {
                            "CodeQL/DataflowRole": "step"
                          }
                        }
                      ]
                    }
                  ]
                }
              ]
            },
            {
              "threadFlows": [
                {
                  "locations": [
                    {
                      "location": {
                        "physicalLocation": {
                          "artifactLocation": {
                            "uri": "Models/User.cs",
                            "uriBaseId": "%SRCROOT%",
                            "index": 3
                          },
                          "region": {
                            "startLine": 74,
                            "startColumn": 73,
                            "endColumn": 81
                          }
                        },
                        "message": {
                          "text": "access to parameter password : String"
                        }
                      }
                    },
                    {
                      "location": {
                        "physicalLocation": {
                          "artifactLocation": {
                            "uri": "Models/User.cs",
                            "uriBaseId": "%SRCROOT%",
                            "index": 3
                          },
                          "region": {
                            "startLine": 74,
                            "startColumn": 37,
                            "endColumn": 82
                          }
                        },
                        "message": {
                          "text": "call to method GetBytes"
                        }
                      },
                      "taxa": [
                        {
                          "index": 4,
                          "toolComponent": {
                            "index": 5
                          },
                          "properties": {
                            "CodeQL/DataflowRole": "step"
                          }
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ],
          "relatedLocations": [
            {
              "id": 1,
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "Models/User.cs",
                  "uriBaseId": "%SRCROOT%",
                  "index": 3
                },
                "region": {
                  "startLine": 37,
                  "startColumn": 44,
                  "endColumn": 52
                }
              },
              "message": {
                "text": "The password"
              }
            },
            {
              "id": 2,
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "Models/User.cs",
                  "uriBaseId": "%SRCROOT%",
                  "index": 3
                },
                "region": {
                  "startLine": 74,
                  "startColumn": 73,
                  "endColumn": 81
                }
              },
              "message": {
                "text": "The password"
              }
            }
          ]
        },
        {
          "ruleId": "cs/json-webtoken-handler/security-validations-disabled",
          "rule": {
            "id": "cs/json-webtoken-handler/security-validations-disabled",
            "index": 77,
            "toolComponent": {
              "index": 4
            }
          },
          "message": {
            "text": "The security sensitive property [Microsoft.IdentityModel.Tokens.TokenValidationParameters.ValidateIssuer](1) is being disabled by the following value: [false](2)."
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "Startup.cs",
                  "uriBaseId": "%SRCROOT%",
                  "index": 4
                },
                "region": {
                  "startLine": 48,
                  "startColumn": 42,
                  "endColumn": 47
                }
              }
            }
          ],
          "partialFingerprints": {
            "primaryLocationLineHash": "6d2ea14d1fdf05a0:1",
            "primaryLocationStartColumnFingerprint": "17"
          },
          "relatedLocations": [
            {
              "id": 1,
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "file:/home/runner/.nuget/packages/microsoft.identitymodel.tokens/5.2.2/lib/netstandard1.4/Microsoft.IdentityModel.Tokens.dll",
                  "index": 5
                }
              },
              "message": {
                "text": "Microsoft.IdentityModel.Tokens.TokenValidationParameters.ValidateIssuer"
              }
            },
            {
              "id": 2,
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "Startup.cs",
                  "uriBaseId": "%SRCROOT%",
                  "index": 4
                },
                "region": {
                  "startLine": 48,
                  "startColumn": 42,
                  "endColumn": 47
                }
              },
              "message": {
                "text": "false"
              }
            }
          ]
        },
        {
          "ruleId": "cs/json-webtoken-handler/security-validations-disabled",
          "rule": {
            "id": "cs/json-webtoken-handler/security-validations-disabled",
            "index": 77,
            "toolComponent": {
              "index": 4
            }
          },
          "message": {
            "text": "The security sensitive property [Microsoft.IdentityModel.Tokens.TokenValidationParameters.ValidateAudience](1) is being disabled by the following value: [false](2)."
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "Startup.cs",
                  "uriBaseId": "%SRCROOT%",
                  "index": 4
                },
                "region": {
                  "startLine": 49,
                  "startColumn": 44,
                  "endColumn": 49
                }
              }
            }
          ],
          "partialFingerprints": {
            "primaryLocationLineHash": "1e2d4a4e8b9b55f:1",
            "primaryLocationStartColumnFingerprint": "19"
          },
          "relatedLocations": [
            {
              "id": 1,
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "file:/home/runner/.nuget/packages/microsoft.identitymodel.tokens/5.2.2/lib/netstandard1.4/Microsoft.IdentityModel.Tokens.dll",
                  "index": 5
                }
              },
              "message": {
                "text": "Microsoft.IdentityModel.Tokens.TokenValidationParameters.ValidateAudience"
              }
            },
            {
              "id": 2,
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "Startup.cs",
                  "uriBaseId": "%SRCROOT%",
                  "index": 4
                },
                "region": {
                  "startLine": 49,
                  "startColumn": 44,
                  "endColumn": 49
                }
              },
              "message": {
                "text": "false"
              }
            }
          ]
        },
        {
          "ruleId": "githubsecuritylab/weak-password-hashing",
          "rule": {
            "id": "githubsecuritylab/weak-password-hashing",
            "index": 1,
            "toolComponent": {
              "index": 7
            }
          },
          "message": {
            "text": "Insecure hashing algorithm (MD5) depends on [password (access to parameter password)](1)."
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "Models/User.cs",
                  "uriBaseId": "%SRCROOT%",
                  "index": 3
                },
                "region": {
                  "startLine": 74,
                  "startColumn": 37,
                  "endColumn": 82
                }
              }
            }
          ],
          "partialFingerprints": {
            "primaryLocationLineHash": "901fca17e23292b:1",
            "primaryLocationStartColumnFingerprint": "27"
          },
          "codeFlows": [
            {
              "threadFlows": [
                {
                  "locations": [
                    {
                      "location": {
                        "physicalLocation": {
                          "artifactLocation": {
                            "uri": "Models/User.cs",
                            "uriBaseId": "%SRCROOT%",
                            "index": 3
                          },
                          "region": {
                            "startLine": 74,
                            "startColumn": 73,
                            "endColumn": 81
                          }
                        },
                        "message": {
                          "text": "access to parameter password : String"
                        }
                      }
                    },
                    {
                      "location": {
                        "physicalLocation": {
                          "artifactLocation": {
                            "uri": "Models/User.cs",
                            "uriBaseId": "%SRCROOT%",
                            "index": 3
                          },
                          "region": {
                            "startLine": 74,
                            "startColumn": 37,
                            "endColumn": 82
                          }
                        },
                        "message": {
                          "text": "call to method GetBytes"
                        }
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "relatedLocations": [
            {
              "id": 1,
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "Models/User.cs",
                  "uriBaseId": "%SRCROOT%",
                  "index": 3
                },
                "region": {
                  "startLine": 74,
                  "startColumn": 73,
                  "endColumn": 81
                }
              },
              "message": {
                "text": "password (access to parameter password)"
              }
            }
          ]
        },
        {
          "ruleId": "githubsecuritylab/weak-sensitive-data-hashing",
          "rule": {
            "id": "githubsecuritylab/weak-sensitive-data-hashing",
            "index": 2,
            "toolComponent": {
              "index": 7
            }
          },
          "message": {
            "text": "Insecure hashing algorithm (MD5) depends on [sensitive data (access to parameter passwordResetRequest)](1)."
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "Controllers/PasswordResetsController.cs",
                  "uriBaseId": "%SRCROOT%",
                  "index": 6
                },
                "region": {
                  "startLine": 80,
                  "startColumn": 37,
                  "endColumn": 100
                }
              }
            }
          ],
          "partialFingerprints": {
            "primaryLocationLineHash": "69719252f5c82167:1",
            "primaryLocationStartColumnFingerprint": "27"
          },
          "codeFlows": [
            {
              "threadFlows": [
                {
                  "locations": [
                    {
                      "location": {
                        "physicalLocation": {
                          "artifactLocation": {
                            "uri": "Controllers/PasswordResetsController.cs",
                            "uriBaseId": "%SRCROOT%",
                            "index": 6
                          },
                          "region": {
                            "startLine": 80,
                            "startColumn": 73,
                            "endColumn": 93
                          }
                        },
                        "message": {
                          "text": "access to parameter passwordResetRequest : PasswordResetRequest"
                        }
                      }
                    },
                    {
                      "location": {
                        "physicalLocation": {
                          "artifactLocation": {
                            "uri": "Controllers/PasswordResetsController.cs",
                            "uriBaseId": "%SRCROOT%",
                            "index": 6
                          },
                          "region": {
                            "startLine": 80,
                            "startColumn": 73,
                            "endColumn": 99
                          }
                        },
                        "message": {
                          "text": "access to property email : String"
                        }
                      }
                    },
                    {
                      "location": {
                        "physicalLocation": {
                          "artifactLocation": {
                            "uri": "Controllers/PasswordResetsController.cs",
                            "uriBaseId": "%SRCROOT%",
                            "index": 6
                          },
                          "region": {
                            "startLine": 80,
                            "startColumn": 37,
                            "endColumn": 100
                          }
                        },
                        "message": {
                          "text": "call to method GetBytes"
                        }
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "relatedLocations": [
            {
              "id": 1,
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "Controllers/PasswordResetsController.cs",
                  "uriBaseId": "%SRCROOT%",
                  "index": 6
                },
                "region": {
                  "startLine": 80,
                  "startColumn": 73,
                  "endColumn": 93
                }
              },
              "message": {
                "text": "sensitive data (access to parameter passwordResetRequest)"
              }
            }
          ]
        },
        {
          "ruleId": "githubsecuritylab/weak-sensitive-data-hashing",
          "rule": {
            "id": "githubsecuritylab/weak-sensitive-data-hashing",
            "index": 2,
            "toolComponent": {
              "index": 7
            }
          },
          "message": {
            "text": "Insecure hashing algorithm (MD5) depends on [sensitive data (access to parameter password)](1)."
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "Models/User.cs",
                  "uriBaseId": "%SRCROOT%",
                  "index": 3
                },
                "region": {
                  "startLine": 74,
                  "startColumn": 37,
                  "endColumn": 82
                }
              }
            }
          ],
          "partialFingerprints": {
            "primaryLocationLineHash": "901fca17e23292b:1",
            "primaryLocationStartColumnFingerprint": "27"
          },
          "codeFlows": [
            {
              "threadFlows": [
                {
                  "locations": [
                    {
                      "location": {
                        "physicalLocation": {
                          "artifactLocation": {
                            "uri": "Models/User.cs",
                            "uriBaseId": "%SRCROOT%",
                            "index": 3
                          },
                          "region": {
                            "startLine": 74,
                            "startColumn": 73,
                            "endColumn": 81
                          }
                        },
                        "message": {
                          "text": "access to parameter password : String"
                        }
                      }
                    },
                    {
                      "location": {
                        "physicalLocation": {
                          "artifactLocation": {
                            "uri": "Models/User.cs",
                            "uriBaseId": "%SRCROOT%",
                            "index": 3
                          },
                          "region": {
                            "startLine": 74,
                            "startColumn": 37,
                            "endColumn": 82
                          }
                        },
                        "message": {
                          "text": "call to method GetBytes"
                        }
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "relatedLocations": [
            {
              "id": 1,
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "Models/User.cs",
                  "uriBaseId": "%SRCROOT%",
                  "index": 3
                },
                "region": {
                  "startLine": 74,
                  "startColumn": 73,
                  "endColumn": 81
                }
              },
              "message": {
                "text": "sensitive data (access to parameter password)"
              }
            }
          ]
        },
        {
          "ruleId": "githubsecuritylab/hardcoded-credentials-symmetricsecuritykey",
          "rule": {
            "id": "githubsecuritylab/hardcoded-credentials-symmetricsecuritykey",
            "index": 3,
            "toolComponent": {
              "index": 7
            }
          },
          "message": {
            "text": "Hard-coded credential [\"f449a71cff1d56a122c84fa478c16af9075e5b4b8527787b56580773242e40ce\"](1) used as SymmetricSecurityKey [here](2)\nHard-coded credential [\"f449a71cff1d56a122c84fa478c16af9075e5b4b8527787b56580773242e40ce\"](1) used as SymmetricSecurityKey [here](3)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "Models/User.cs",
                  "uriBaseId": "%SRCROOT%",
                  "index": 3
                },
                "region": {
                  "startLine": 17,
                  "startColumn": 41,
                  "endColumn": 107
                }
              }
            }
          ],
          "partialFingerprints": {
            "primaryLocationLineHash": "8dc75f199d639793:1",
            "primaryLocationStartColumnFingerprint": "34"
          },
          "relatedLocations": [
            {
              "id": 1,
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "Models/User.cs",
                  "uriBaseId": "%SRCROOT%",
                  "index": 3
                },
                "region": {
                  "startLine": 17,
                  "startColumn": 41,
                  "endColumn": 107
                }
              },
              "message": {
                "text": "\"f449a71cff1d56a122c84fa478c16af9075e5b4b8527787b56580773242e40ce\""
              }
            },
            {
              "id": 2,
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "Startup.cs",
                  "uriBaseId": "%SRCROOT%",
                  "index": 4
                },
                "region": {
                  "startLine": 51,
                  "startColumn": 69,
                  "endLine": 52,
                  "endColumn": 62
                }
              },
              "message": {
                "text": "here"
              }
            },
            {
              "id": 3,
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "Models/User.cs",
                  "uriBaseId": "%SRCROOT%",
                  "index": 3
                },
                "region": {
                  "startLine": 53,
                  "startColumn": 41,
                  "endColumn": 71
                }
              },
              "message": {
                "text": "here"
              }
            }
          ]
        }
      ],
      "automationDetails": {
        "id": "/language:csharp/"
      },
      "columnKind": "utf16CodeUnits",
      "properties": {
        "semmle.formatSpecifier": "sarif-latest",
        "metricResults": [
          {
            "rule": {
              "id": "cs/telemetry/external-libs",
              "index": 81,
              "toolComponent": {
                "index": 4
              }
            },
            "ruleId": "cs/telemetry/external-libs",
            "value": 97,
            "message": {
              "text": "Microsoft.EntityFrameworkCore.Metadata.Builders"
            }
          },
          {
            "rule": {
              "id": "cs/telemetry/external-libs",
              "index": 81,
              "toolComponent": {
                "index": 4
              }
            },
            "ruleId": "cs/telemetry/external-libs",
            "value": 67,
            "message": {
              "text": "Microsoft.AspNetCore.Mvc"
            }
          },
          {
            "rule": {
              "id": "cs/telemetry/external-libs",
              "index": 81,
              "toolComponent": {
                "index": 4
              }
            },
            "ruleId": "cs/telemetry/external-libs",
            "value": 38,
            "message": {
              "text": "Microsoft.EntityFrameworkCore"
            }
          },
          {
            "rule": {
              "id": "cs/telemetry/external-libs",
              "index": 81,
              "toolComponent": {
                "index": 4
              }
            },
            "ruleId": "cs/telemetry/external-libs",
            "value": 25,
            "message": {
              "text": "Microsoft.EntityFrameworkCore.Migrations.Operations.Builders"
            }
          },
          {
            "rule": {
              "id": "cs/telemetry/external-libs",
              "index": 81,
              "toolComponent": {
                "index": 4
              }
            },
            "ruleId": "cs/telemetry/external-libs",
            "value": 23,
            "message": {
              "text": "System.Linq"
            }
          },
          {
            "rule": {
              "id": "cs/telemetry/external-libs",
              "index": 81,
              "toolComponent": {
                "index": 4
              }
            },
            "ruleId": "cs/telemetry/external-libs",
            "value": 20,
            "message": {
              "text": "System"
            }
          },
          {
            "rule": {
              "id": "cs/telemetry/external-libs",
              "index": 81,
              "toolComponent": {
                "index": 4
              }
            },
            "ruleId": "cs/telemetry/external-libs",
            "value": 13,
            "message": {
              "text": "Microsoft.AspNetCore.Mvc.ModelBinding"
            }
          },
          {
            "rule": {
              "id": "cs/telemetry/external-libs",
              "index": 81,
              "toolComponent": {
                "index": 4
              }
            },
            "ruleId": "cs/telemetry/external-libs",
            "value": 10,
            "message": {
              "text": "System.Text"
            }
          },
          {
            "rule": {
              "id": "cs/telemetry/external-libs",
              "index": 81,
              "toolComponent": {
                "index": 4
              }
            },
            "ruleId": "cs/telemetry/external-libs",
            "value": 9,
            "message": {
              "text": "Microsoft.AspNetCore.Http"
            }
          },
          {
            "rule": {
              "id": "cs/telemetry/external-libs",
              "index": 81,
              "toolComponent": {
                "index": 4
              }
            },
            "ruleId": "cs/telemetry/external-libs",
            "value": 8,
            "message": {
              "text": "System.Xml.Serialization"
            }
          },
          {
            "rule": {
              "id": "cs/telemetry/external-libs",
              "index": 81,
              "toolComponent": {
                "index": 4
              }
            },
            "ruleId": "cs/telemetry/external-libs",
            "value": 7,
            "message": {
              "text": "System.Security.Claims"
            }
          },
          {
            "rule": {
              "id": "cs/telemetry/external-libs",
              "index": 81,
              "toolComponent": {
                "index": 4
              }
            },
            "ruleId": "cs/telemetry/external-libs",
            "value": 6,
            "message": {
              "text": "Microsoft.EntityFrameworkCore.Migrations"
            }
          },
          {
            "rule": {
              "id": "cs/telemetry/external-libs",
              "index": 81,
              "toolComponent": {
                "index": 4
              }
            },
            "ruleId": "cs/telemetry/external-libs",
            "value": 6,
            "message": {
              "text": "Microsoft.AspNetCore.Cors.Infrastructure"
            }
          },
          {
            "rule": {
              "id": "cs/telemetry/external-libs",
              "index": 81,
              "toolComponent": {
                "index": 4
              }
            },
            "ruleId": "cs/telemetry/external-libs",
            "value": 6,
            "message": {
              "text": "Newtonsoft.Json.Linq"
            }
          },
          {
            "rule": {
              "id": "cs/telemetry/external-libs",
              "index": 81,
              "toolComponent": {
                "index": 4
              }
            },
            "ruleId": "cs/telemetry/external-libs",
            "value": 6,
            "message": {
              "text": "System.Xml"
            }
          },
          {
            "rule": {
              "id": "cs/telemetry/external-libs",
              "index": 81,
              "toolComponent": {
                "index": 4
              }
            },
            "ruleId": "cs/telemetry/external-libs",
            "value": 5,
            "message": {
              "text": "Microsoft.AspNetCore.Builder"
            }
          },
          {
            "rule": {
              "id": "cs/telemetry/external-libs",
              "index": 81,
              "toolComponent": {
                "index": 4
              }
            },
            "ruleId": "cs/telemetry/external-libs",
            "value": 5,
            "message": {
              "text": "Microsoft.Extensions.DependencyInjection"
            }
          },
          {
            "rule": {
              "id": "cs/telemetry/external-libs",
              "index": 81,
              "toolComponent": {
                "index": 4
              }
            },
            "ruleId": "cs/telemetry/external-libs",
            "value": 4,
            "message": {
              "text": "Microsoft.AspNetCore.Hosting"
            }
          },
          {
            "rule": {
              "id": "cs/telemetry/external-libs",
              "index": 81,
              "toolComponent": {
                "index": 4
              }
            },
            "ruleId": "cs/telemetry/external-libs",
            "value": 4,
            "message": {
              "text": "System.Security.Cryptography"
            }
          },
          {
            "rule": {
              "id": "cs/telemetry/external-libs",
              "index": 81,
              "toolComponent": {
                "index": 4
              }
            },
            "ruleId": "cs/telemetry/external-libs",
            "value": 3,
            "message": {
              "text": "Microsoft.IdentityModel.Tokens"
            }
          },
          {
            "rule": {
              "id": "cs/telemetry/external-libs",
              "index": 81,
              "toolComponent": {
                "index": 4
              }
            },
            "ruleId": "cs/telemetry/external-libs",
            "value": 3,
            "message": {
              "text": "System.Net.Http"
            }
          },
          {
            "rule": {
              "id": "cs/telemetry/external-libs",
              "index": 81,
              "toolComponent": {
                "index": 4
              }
            },
            "ruleId": "cs/telemetry/external-libs",
            "value": 2,
            "message": {
              "text": "System.IdentityModel.Tokens.Jwt"
            }
          },
          {
            "rule": {
              "id": "cs/telemetry/external-libs",
              "index": 81,
              "toolComponent": {
                "index": 4
              }
            },
            "ruleId": "cs/telemetry/external-libs",
            "value": 1,
            "message": {
              "text": "Microsoft.Extensions.Configuration"
            }
          },
          {
            "rule": {
              "id": "cs/telemetry/external-libs",
              "index": 81,
              "toolComponent": {
                "index": 4
              }
            },
            "ruleId": "cs/telemetry/external-libs",
            "value": 1,
            "message": {
              "text": "Microsoft.Extensions.Primitives"
            }
          },
          {
            "rule": {
              "id": "cs/telemetry/external-libs",
              "index": 81,
              "toolComponent": {
                "index": 4
              }
            },
            "ruleId": "cs/telemetry/external-libs",
            "value": 1,
            "message": {
              "text": "System.Collections.Generic"
            }
          },
          {
            "rule": {
              "id": "cs/telemetry/external-libs",
              "index": 81,
              "toolComponent": {
                "index": 4
              }
            },
            "ruleId": "cs/telemetry/external-libs",
            "value": 1,
            "message": {
              "text": "System.IO"
            }
          },
          {
            "rule": {
              "id": "cs/telemetry/external-libs",
              "index": 81,
              "toolComponent": {
                "index": 4
              }
            },
            "ruleId": "cs/telemetry/external-libs",
            "value": 1,
            "message": {
              "text": "Microsoft.AspNetCore"
            }
          },
          {
            "rule": {
              "id": "cs/telemetry/supported-external-api-taint",
              "index": 82,
              "toolComponent": {
                "index": 4
              }
            },
            "ruleId": "cs/telemetry/supported-external-api-taint",
            "value": 9,
            "message": {
              "text": "Microsoft.EntityFrameworkCore#ModelBuilder.Entity(System.String,System.Action<Microsoft.EntityFrameworkCore.Metadata.Builders.EntityTypeBuilder>)"
            }
          },
          {
            "rule": {
              "id": "cs/telemetry/supported-external-api-taint",
              "index": 82,
              "toolComponent": {
                "index": 4
              }
            },
            "ruleId": "cs/telemetry/supported-external-api-taint",
            "value": 8,
            "message": {
              "text": "System.Linq#Queryable.FirstOrDefault`1(System.Linq.IQueryable<TSource>)"
            }
          },
          {
            "rule": {
              "id": "cs/telemetry/supported-external-api-taint",
              "index": 82,
              "toolComponent": {
                "index": 4
              }
            },
            "ruleId": "cs/telemetry/supported-external-api-taint",
            "value": 8,
            "message": {
              "text": "System.Linq#Queryable.Where`1(System.Linq.IQueryable<TSource>,System.Linq.Expressions.Expression<System.Func<TSource,System.Boolean>>)"
            }
          },
          {
            "rule": {
              "id": "cs/telemetry/supported-external-api-taint",
              "index": 82,
              "toolComponent": {
                "index": 4
              }
            },
            "ruleId": "cs/telemetry/supported-external-api-taint",
            "value": 6,
            "message": {
              "text": "Microsoft.EntityFrameworkCore#DbContext.SaveChanges()"
            }
          },
          {
            "rule": {
              "id": "cs/telemetry/supported-external-api-taint",
              "index": 82,
              "toolComponent": {
                "index": 4
              }
            },
            "ruleId": "cs/telemetry/supported-external-api-taint",
            "value": 4,
            "message": {
              "text": "System.Text#Encoding.GetBytes(System.String)"
            }
          },
          {
            "rule": {
              "id": "cs/telemetry/supported-external-api-taint",
              "index": 82,
              "toolComponent": {
                "index": 4
              }
            },
            "ruleId": "cs/telemetry/supported-external-api-taint",
            "value": 3,
            "message": {
              "text": "System.Linq#Enumerable.ToList`1(System.Collections.Generic.IEnumerable<TSource>)"
            }
          },
          {
            "rule": {
              "id": "cs/telemetry/supported-external-api-taint",
              "index": 82,
              "toolComponent": {
                "index": 4
              }
            },
            "ruleId": "cs/telemetry/supported-external-api-taint",
            "value": 3,
            "message": {
              "text": "Microsoft.EntityFrameworkCore#DbSet`1.Add(TEntity)"
            }
          },
          {
            "rule": {
              "id": "cs/telemetry/supported-external-api-taint",
              "index": 82,
              "toolComponent": {
                "index": 4
              }
            },
            "ruleId": "cs/telemetry/supported-external-api-taint",
            "value": 3,
            "message": {
              "text": "Microsoft.EntityFrameworkCore.Migrations#MigrationBuilder.CreateTable`1(System.String,System.Func<Microsoft.EntityFrameworkCore.Migrations.Operations.Builders.ColumnsBuilder,TColumns>,System.String,System.Action<Microsoft.EntityFrameworkCore.Migrations.Operations.Builders.CreateTableBuilder<TColumns>>)"
            }
          },
          {
            "rule": {
              "id": "cs/telemetry/supported-external-api-taint",
              "index": 82,
              "toolComponent": {
                "index": 4
              }
            },
            "ruleId": "cs/telemetry/supported-external-api-taint",
            "value": 3,
            "message": {
              "text": "Microsoft.EntityFrameworkCore.Migrations.Operations.Builders#CreateTableBuilder`1.PrimaryKey(System.String,System.Linq.Expressions.Expression<System.Func<TColumns,System.Object>>)"
            }
          },
          {
            "rule": {
              "id": "cs/telemetry/supported-external-api-taint",
              "index": 82,
              "toolComponent": {
                "index": 4
              }
            },
            "ruleId": "cs/telemetry/supported-external-api-taint",
            "value": 2,
            "message": {
              "text": "Microsoft.EntityFrameworkCore#DbSet`1.Update(TEntity)"
            }
          },
          {
            "rule": {
              "id": "cs/telemetry/supported-external-api-taint",
              "index": 82,
              "toolComponent": {
                "index": 4
              }
            },
            "ruleId": "cs/telemetry/supported-external-api-taint",
            "value": 2,
            "message": {
              "text": "System.Linq#Queryable.SingleOrDefault`1(System.Linq.IQueryable<TSource>,System.Linq.Expressions.Expression<System.Func<TSource,System.Boolean>>)"
            }
          },
          {
            "rule": {
              "id": "cs/telemetry/supported-external-api-taint",
              "index": 82,
              "toolComponent": {
                "index": 4
              }
            },
            "ruleId": "cs/telemetry/supported-external-api-taint",
            "value": 2,
            "message": {
              "text": "System.Security.Cryptography#HashAlgorithm.ComputeHash(System.Byte\\[\\])"
            }
          },
          {
            "rule": {
              "id": "cs/telemetry/supported-external-api-taint",
              "index": 82,
              "toolComponent": {
                "index": 4
              }
            },
            "ruleId": "cs/telemetry/supported-external-api-taint",
            "value": 2,
            "message": {
              "text": "System.Xml.Serialization#XmlRootAttribute.XmlRootAttribute(System.String)"
            }
          },
          {
            "rule": {
              "id": "cs/telemetry/supported-external-api-taint",
              "index": 82,
              "toolComponent": {
                "index": 4
              }
            },
            "ruleId": "cs/telemetry/supported-external-api-taint",
            "value": 2,
            "message": {
              "text": "System.Xml.Serialization#XmlSerializer.Deserialize(System.Xml.XmlReader)"
            }
          },
          {
            "rule": {
              "id": "cs/telemetry/supported-external-api-taint",
              "index": 82,
              "toolComponent": {
                "index": 4
              }
            },
            "ruleId": "cs/telemetry/supported-external-api-taint",
            "value": 2,
            "message": {
              "text": "System.Security.Claims#Claim.get_Type()"
            }
          },
          {
            "rule": {
              "id": "cs/telemetry/supported-external-api-taint",
              "index": 82,
              "toolComponent": {
                "index": 4
              }
            },
            "ruleId": "cs/telemetry/supported-external-api-taint",
            "value": 2,
            "message": {
              "text": "System#String.Replace(System.String,System.String)"
            }
          },
          {
            "rule": {
              "id": "cs/telemetry/supported-external-api-taint",
              "index": 82,
              "toolComponent": {
                "index": 4
              }
            },
            "ruleId": "cs/telemetry/supported-external-api-taint",
            "value": 2,
            "message": {
              "text": "System#String.ToLowerInvariant()"
            }
          },
          {
            "rule": {
              "id": "cs/telemetry/supported-external-api-taint",
              "index": 82,
              "toolComponent": {
                "index": 4
              }
            },
            "ruleId": "cs/telemetry/supported-external-api-taint",
            "value": 1,
            "message": {
              "text": "System.Security.Claims#Claim.get_Value()"
            }
          },
          {
            "rule": {
              "id": "cs/telemetry/supported-external-api-taint",
              "index": 82,
              "toolComponent": {
                "index": 4
              }
            },
            "ruleId": "cs/telemetry/supported-external-api-taint",
            "value": 1,
            "message": {
              "text": "System.Security.Claims#ClaimsPrincipal.get_Claims()"
            }
          },
          {
            "rule": {
              "id": "cs/telemetry/supported-external-api-taint",
              "index": 82,
              "toolComponent": {
                "index": 4
              }
            },
            "ruleId": "cs/telemetry/supported-external-api-taint",
            "value": 1,
            "message": {
              "text": "System.Security.Claims#ClaimsPrincipal.HasClaim(System.Predicate<System.Security.Claims.Claim>)"
            }
          },
          {
            "rule": {
              "id": "cs/telemetry/supported-external-api-taint",
              "index": 82,
              "toolComponent": {
                "index": 4
              }
            },
            "ruleId": "cs/telemetry/supported-external-api-taint",
            "value": 1,
            "message": {
              "text": "System.Xml#XmlDocument.Load(System.IO.Stream)"
            }
          },
          {
            "rule": {
              "id": "cs/telemetry/supported-external-api-taint",
              "index": 82,
              "toolComponent": {
                "index": 4
              }
            },
            "ruleId": "cs/telemetry/supported-external-api-taint",
            "value": 1,
            "message": {
              "text": "System.Xml#XmlElement.GetAttribute(System.String)"
            }
          },
          {
            "rule": {
              "id": "cs/telemetry/supported-external-api-taint",
              "index": 82,
              "toolComponent": {
                "index": 4
              }
            },
            "ruleId": "cs/telemetry/supported-external-api-taint",
            "value": 1,
            "message": {
              "text": "System.Xml#XmlNode.SelectNodes(System.String)"
            }
          },
          {
            "rule": {
              "id": "cs/telemetry/supported-external-api-taint",
              "index": 82,
              "toolComponent": {
                "index": 4
              }
            },
            "ruleId": "cs/telemetry/supported-external-api-taint",
            "value": 1,
            "message": {
              "text": "System.Xml#XmlReader.Create(System.IO.Stream)"
            }
          },
          {
            "rule": {
              "id": "cs/telemetry/supported-external-api-taint",
              "index": 82,
              "toolComponent": {
                "index": 4
              }
            },
            "ruleId": "cs/telemetry/supported-external-api-taint",
            "value": 1,
            "message": {
              "text": "Newtonsoft.Json.Linq#JObject.JObject(System.Object\\[\\])"
            }
          },
          {
            "rule": {
              "id": "cs/telemetry/supported-external-api-taint",
              "index": 82,
              "toolComponent": {
                "index": 4
              }
            },
            "ruleId": "cs/telemetry/supported-external-api-taint",
            "value": 1,
            "message": {
              "text": "Newtonsoft.Json.Linq#JObject.get_Item(System.String)"
            }
          },
          {
            "rule": {
              "id": "cs/telemetry/supported-external-api-taint",
              "index": 82,
              "toolComponent": {
                "index": 4
              }
            },
            "ruleId": "cs/telemetry/supported-external-api-taint",
            "value": 1,
            "message": {
              "text": "Newtonsoft.Json.Linq#JObject.Parse(System.String)"
            }
          },
          {
            "rule": {
              "id": "cs/telemetry/supported-external-api-taint",
              "index": 82,
              "toolComponent": {
                "index": 4
              }
            },
            "ruleId": "cs/telemetry/supported-external-api-taint",
            "value": 1,
            "message": {
              "text": "System.Text#Encoding.GetString(System.Byte\\[\\])"
            }
          },
          {
            "rule": {
              "id": "cs/telemetry/supported-external-api-taint",
              "index": 82,
              "toolComponent": {
                "index": 4
              }
            },
            "ruleId": "cs/telemetry/supported-external-api-taint",
            "value": 1,
            "message": {
              "text": "Microsoft.Extensions.DependencyInjection#JwtBearerExtensions.AddJwtBearer(Microsoft.AspNetCore.Authentication.AuthenticationBuilder,System.Action<Microsoft.AspNetCore.Authentication.JwtBearer.JwtBearerOptions>)"
            }
          },
          {
            "rule": {
              "id": "cs/telemetry/supported-external-api-taint",
              "index": 82,
              "toolComponent": {
                "index": 4
              }
            },
            "ruleId": "cs/telemetry/supported-external-api-taint",
            "value": 1,
            "message": {
              "text": "Microsoft.AspNetCore.Cors.Infrastructure#CorsOptions.AddPolicy(System.String,System.Action<Microsoft.AspNetCore.Cors.Infrastructure.CorsPolicyBuilder>)"
            }
          },
          {
            "rule": {
              "id": "cs/telemetry/supported-external-api-taint",
              "index": 82,
              "toolComponent": {
                "index": 4
              }
            },
            "ruleId": "cs/telemetry/supported-external-api-taint",
            "value": 1,
            "message": {
              "text": "Microsoft.Extensions.DependencyInjection#CorsServiceCollectionExtensions.AddCors(Microsoft.Extensions.DependencyInjection.IServiceCollection,System.Action<Microsoft.AspNetCore.Cors.Infrastructure.CorsOptions>)"
            }
          },
          {
            "rule": {
              "id": "cs/telemetry/supported-external-api-taint",
              "index": 82,
              "toolComponent": {
                "index": 4
              }
            },
            "ruleId": "cs/telemetry/supported-external-api-taint",
            "value": 1,
            "message": {
              "text": "Microsoft.AspNetCore.Builder#RunExtensions.Run(Microsoft.AspNetCore.Builder.IApplicationBuilder,Microsoft.AspNetCore.Http.RequestDelegate)"
            }
          },
          {
            "rule": {
              "id": "cs/telemetry/supported-external-api-taint",
              "index": 82,
              "toolComponent": {
                "index": 4
              }
            },
            "ruleId": "cs/telemetry/supported-external-api-taint",
            "value": 1,
            "message": {
              "text": "Microsoft.AspNetCore.Http#IQueryCollection.get_Item(System.String)"
            }
          },
          {
            "rule": {
              "id": "cs/telemetry/supported-external-api-taint",
              "index": 82,
              "toolComponent": {
                "index": 4
              }
            },
            "ruleId": "cs/telemetry/supported-external-api-taint",
            "value": 1,
            "message": {
              "text": "Microsoft.AspNetCore.Http#IRequestCookieCollection.get_Item(System.String)"
            }
          },
          {
            "rule": {
              "id": "cs/telemetry/supported-external-api-taint",
              "index": 82,
              "toolComponent": {
                "index": 4
              }
            },
            "ruleId": "cs/telemetry/supported-external-api-taint",
            "value": 1,
            "message": {
              "text": "System.Collections.Generic#List`1.Add(T)"
            }
          },
          {
            "rule": {
              "id": "cs/telemetry/supported-external-api-taint",
              "index": 82,
              "toolComponent": {
                "index": 4
              }
            },
            "ruleId": "cs/telemetry/supported-external-api-taint",
            "value": 1,
            "message": {
              "text": "System#Exception.get_Message()"
            }
          },
          {
            "rule": {
              "id": "cs/telemetry/supported-external-api-taint",
              "index": 82,
              "toolComponent": {
                "index": 4
              }
            },
            "ruleId": "cs/telemetry/supported-external-api-taint",
            "value": 1,
            "message": {
              "text": "Microsoft.EntityFrameworkCore#SqliteDbContextOptionsBuilderExtensions.UseSqlite(Microsoft.EntityFrameworkCore.DbContextOptionsBuilder,System.String,System.Action<Microsoft.EntityFrameworkCore.Infrastructure.SqliteDbContextOptionsBuilder>)"
            }
          },
          {
            "rule": {
              "id": "cs/telemetry/supported-external-api-taint",
              "index": 82,
              "toolComponent": {
                "index": 4
              }
            },
            "ruleId": "cs/telemetry/supported-external-api-taint",
            "value": 1,
            "message": {
              "text": "Microsoft.EntityFrameworkCore#RawSqlString.implicit conversion(System.String)"
            }
          },
          {
            "rule": {
              "id": "cs/telemetry/supported-external-api-taint",
              "index": 82,
              "toolComponent": {
                "index": 4
              }
            },
            "ruleId": "cs/telemetry/supported-external-api-taint",
            "value": 1,
            "message": {
              "text": "Microsoft.Extensions.Primitives#StringValues.ToString()"
            }
          },
          {
            "rule": {
              "id": "cs/telemetry/supported-external-api-taint",
              "index": 82,
              "toolComponent": {
                "index": 4
              }
            },
            "ruleId": "cs/telemetry/supported-external-api-taint",
            "value": 1,
            "message": {
              "text": "Microsoft.Extensions.DependencyInjection#EntityFrameworkServiceCollectionExtensions.AddDbContext`1(Microsoft.Extensions.DependencyInjection.IServiceCollection,System.Action<Microsoft.EntityFrameworkCore.DbContextOptionsBuilder>,Microsoft.Extensions.DependencyInjection.ServiceLifetime,Microsoft.Extensions.DependencyInjection.ServiceLifetime)"
            }
          },
          {
            "rule": {
              "id": "cs/telemetry/supported-external-api-taint",
              "index": 82,
              "toolComponent": {
                "index": 4
              }
            },
            "ruleId": "cs/telemetry/supported-external-api-taint",
            "value": 1,
            "message": {
              "text": "System.Linq#Enumerable.FirstOrDefault`1(System.Collections.Generic.IEnumerable<TSource>,System.Func<TSource,System.Boolean>)"
            }
          },
          {
            "rule": {
              "id": "cs/telemetry/supported-external-api-taint",
              "index": 82,
              "toolComponent": {
                "index": 4
              }
            },
            "ruleId": "cs/telemetry/supported-external-api-taint",
            "value": 1,
            "message": {
              "text": "System.Linq#Enumerable.ToArray`1(System.Collections.Generic.IEnumerable<TSource>)"
            }
          },
          {
            "rule": {
              "id": "cs/telemetry/supported-external-api-taint",
              "index": 82,
              "toolComponent": {
                "index": 4
              }
            },
            "ruleId": "cs/telemetry/supported-external-api-taint",
            "value": 1,
            "message": {
              "text": "System.Net.Http#HttpResponseMessage.EnsureSuccessStatusCode()"
            }
          },
          {
            "rule": {
              "id": "cs/telemetry/supported-external-api-taint",
              "index": 82,
              "toolComponent": {
                "index": 4
              }
            },
            "ruleId": "cs/telemetry/supported-external-api-taint",
            "value": 1,
            "message": {
              "text": "System.IO#StringReader.StringReader(System.String)"
            }
          },
          {
            "rule": {
              "id": "cs/telemetry/supported-external-api-taint",
              "index": 82,
              "toolComponent": {
                "index": 4
              }
            },
            "ruleId": "cs/telemetry/supported-external-api-taint",
            "value": 1,
            "message": {
              "text": "System#Convert.FromBase64String(System.String)"
            }
          },
          {
            "rule": {
              "id": "cs/telemetry/supported-external-api-sinks",
              "index": 83,
              "toolComponent": {
                "index": 4
              }
            },
            "ruleId": "cs/telemetry/supported-external-api-sinks",
            "value": 2,
            "message": {
              "text": "System.Xml.Serialization#XmlSerializer.Deserialize(System.Xml.XmlReader)"
            }
          },
          {
            "rule": {
              "id": "cs/telemetry/supported-external-api-sinks",
              "index": 83,
              "toolComponent": {
                "index": 4
              }
            },
            "ruleId": "cs/telemetry/supported-external-api-sinks",
            "value": 1,
            "message": {
              "text": "Microsoft.EntityFrameworkCore#RawSqlString.implicit conversion(System.String)"
            }
          },
          {
            "rule": {
              "id": "cs/telemetry/supported-external-api-sinks",
              "index": 83,
              "toolComponent": {
                "index": 4
              }
            },
            "ruleId": "cs/telemetry/supported-external-api-sinks",
            "value": 1,
            "message": {
              "text": "System.Xml#XmlReader.Create(System.IO.Stream)"
            }
          },
          {
            "rule": {
              "id": "cs/telemetry/supported-external-api-sinks",
              "index": 83,
              "toolComponent": {
                "index": 4
              }
            },
            "ruleId": "cs/telemetry/supported-external-api-sinks",
            "value": 1,
            "message": {
              "text": "Microsoft.EntityFrameworkCore#RelationalQueryableExtensions.FromSql`1(System.Linq.IQueryable<TEntity>,Microsoft.EntityFrameworkCore.RawSqlString,System.Object\\[\\])"
            }
          },
          {
            "rule": {
              "id": "cs/telemetry/supported-external-api-sinks",
              "index": 83,
              "toolComponent": {
                "index": 4
              }
            },
            "ruleId": "cs/telemetry/supported-external-api-sinks",
            "value": 1,
            "message": {
              "text": "System.Xml#XmlNode.SelectNodes(System.String)"
            }
          },
          {
            "rule": {
              "id": "cs/telemetry/extraction-information",
              "index": 85,
              "toolComponent": {
                "index": 4
              }
            },
            "ruleId": "cs/telemetry/extraction-information",
            "value": 1.0,
            "message": {
              "text": "Number of files with extension props"
            }
          },
          {
            "rule": {
              "id": "cs/telemetry/extraction-information",
              "index": 85,
              "toolComponent": {
                "index": 4
              }
            },
            "ruleId": "cs/telemetry/extraction-information",
            "value": 314.0,
            "message": {
              "text": "Number of files with extension dll"
            }
          },
          {
            "rule": {
              "id": "cs/telemetry/extraction-information",
              "index": 85,
              "toolComponent": {
                "index": 4
              }
            },
            "ruleId": "cs/telemetry/extraction-information",
            "value": 26.0,
            "message": {
              "text": "Number of files with extension cs"
            }
          },
          {
            "rule": {
              "id": "cs/telemetry/extraction-information",
              "index": 85,
              "toolComponent": {
                "index": 4
              }
            },
            "ruleId": "cs/telemetry/extraction-information",
            "value": 1.0,
            "message": {
              "text": "Number of files with extension csproj"
            }
          },
          {
            "rule": {
              "id": "cs/telemetry/extraction-information",
              "index": 85,
              "toolComponent": {
                "index": 4
              }
            },
            "ruleId": "cs/telemetry/extraction-information",
            "value": 1.0,
            "message": {
              "text": "CSC analyzer: /home/runner/.nuget/packages/microsoft.codeanalysis.analyzers/1.1.0/analyzers/dotnet/cs/Microsoft.CodeAnalysis.Analyzers.dll"
            }
          },
          {
            "rule": {
              "id": "cs/telemetry/extraction-information",
              "index": 85,
              "toolComponent": {
                "index": 4
              }
            },
            "ruleId": "cs/telemetry/extraction-information",
            "value": 1.0,
            "message": {
              "text": "CSC analyzer: /home/runner/.nuget/packages/microsoft.codeanalysis.analyzers/1.1.0/analyzers/dotnet/cs/Microsoft.CodeAnalysis.CSharp.Analyzers.dll"
            }
          },
          {
            "rule": {
              "id": "cs/telemetry/extraction-information",
              "index": 85,
              "toolComponent": {
                "index": 4
              }
            },
            "ruleId": "cs/telemetry/extraction-information",
            "value": 22.0,
            "message": {
              "text": "Number of lines of code with extension props"
            }
          },
          {
            "rule": {
              "id": "cs/telemetry/extraction-information",
              "index": 85,
              "toolComponent": {
                "index": 4
              }
            },
            "ruleId": "cs/telemetry/extraction-information",
            "value": 1034.0,
            "message": {
              "text": "Number of lines of code with extension cs"
            }
          },
          {
            "rule": {
              "id": "cs/telemetry/extraction-information",
              "index": 85,
              "toolComponent": {
                "index": 4
              }
            },
            "ruleId": "cs/telemetry/extraction-information",
            "value": 30.0,
            "message": {
              "text": "Number of lines of code with extension csproj"
            }
          },
          {
            "rule": {
              "id": "cs/telemetry/extraction-information",
              "index": 85,
              "toolComponent": {
                "index": 4
              }
            },
            "ruleId": "cs/telemetry/extraction-information",
            "value": 22.0,
            "message": {
              "text": "Total number of lines with extension props"
            }
          },
          {
            "rule": {
              "id": "cs/telemetry/extraction-information",
              "index": 85,
              "toolComponent": {
                "index": 4
              }
            },
            "ruleId": "cs/telemetry/extraction-information",
            "value": 1359.0,
            "message": {
              "text": "Total number of lines with extension cs"
            }
          },
          {
            "rule": {
              "id": "cs/telemetry/extraction-information",
              "index": 85,
              "toolComponent": {
                "index": 4
              }
            },
            "ruleId": "cs/telemetry/extraction-information",
            "value": 30.0,
            "message": {
              "text": "Total number of lines with extension csproj"
            }
          },
          {
            "rule": {
              "id": "cs/telemetry/extraction-information",
              "index": 85,
              "toolComponent": {
                "index": 4
              }
            },
            "ruleId": "cs/telemetry/extraction-information",
            "value": 343.0,
            "message": {
              "text": "Number of files"
            }
          },
          {
            "rule": {
              "id": "cs/telemetry/extraction-information",
              "index": 85,
              "toolComponent": {
                "index": 4
              }
            },
            "ruleId": "cs/telemetry/extraction-information",
            "value": 1411.0,
            "message": {
              "text": "Total number of lines"
            }
          },
          {
            "rule": {
              "id": "cs/telemetry/extraction-information",
              "index": 85,
              "toolComponent": {
                "index": 4
              }
            },
            "ruleId": "cs/telemetry/extraction-information",
            "value": 1086.0,
            "message": {
              "text": "Number of lines of code"
            }
          },
          {
            "rule": {
              "id": "cs/telemetry/extraction-information",
              "index": 85,
              "toolComponent": {
                "index": 4
              }
            },
            "ruleId": "cs/telemetry/extraction-information",
            "value": 99.97214484679665,
            "message": {
              "text": "Percentage of access with target"
            }
          },
          {
            "rule": {
              "id": "cs/telemetry/extraction-information",
              "index": 85,
              "toolComponent": {
                "index": 4
              }
            },
            "ruleId": "cs/telemetry/extraction-information",
            "value": 3589.0,
            "message": {
              "text": "Number of access with target"
            }
          },
          {
            "rule": {
              "id": "cs/telemetry/extraction-information",
              "index": 85,
              "toolComponent": {
                "index": 4
              }
            },
            "ruleId": "cs/telemetry/extraction-information",
            "value": 100.0,
            "message": {
              "text": "Percentage of calls with call target"
            }
          },
          {
            "rule": {
              "id": "cs/telemetry/extraction-information",
              "index": 85,
              "toolComponent": {
                "index": 4
              }
            },
            "ruleId": "cs/telemetry/extraction-information",
            "value": 503.0,
            "message": {
              "text": "Number of calls with call target"
            }
          },
          {
            "rule": {
              "id": "cs/telemetry/extraction-information",
              "index": 85,
              "toolComponent": {
                "index": 4
              }
            },
            "ruleId": "cs/telemetry/extraction-information",
            "value": 100.0,
            "message": {
              "text": "Percentage of expressions with known kind"
            }
          },
          {
            "rule": {
              "id": "cs/telemetry/extraction-information",
              "index": 85,
              "toolComponent": {
                "index": 4
              }
            },
            "ruleId": "cs/telemetry/extraction-information",
            "value": 100.0,
            "message": {
              "text": "Percentage of expressions with known type"
            }
          },
          {
            "rule": {
              "id": "cs/telemetry/extraction-information",
              "index": 85,
              "toolComponent": {
                "index": 4
              }
            },
            "ruleId": "cs/telemetry/extraction-information",
            "value": 1.0,
            "message": {
              "text": "Number of access with missing target"
            }
          },
          {
            "rule": {
              "id": "cs/telemetry/extraction-information",
              "index": 85,
              "toolComponent": {
                "index": 4
              }
            },
            "ruleId": "cs/telemetry/extraction-information",
            "value": 21277.0,
            "message": {
              "text": "Number of expressions with known kind"
            }
          },
          {
            "rule": {
              "id": "cs/telemetry/extraction-information",
              "index": 85,
              "toolComponent": {
                "index": 4
              }
            },
            "ruleId": "cs/telemetry/extraction-information",
            "value": 1491.0,
            "message": {
              "text": "Number of expressions with known type"
            }
          },
          {
            "rule": {
              "id": "cs/telemetry/extraction-information",
              "index": 85,
              "toolComponent": {
                "index": 4
              }
            },
            "ruleId": "cs/telemetry/extraction-information",
            "value": 100.0,
            "message": {
              "text": "Percentage of type mentions with known type"
            }
          },
          {
            "rule": {
              "id": "cs/telemetry/extraction-information",
              "index": 85,
              "toolComponent": {
                "index": 4
              }
            },
            "ruleId": "cs/telemetry/extraction-information",
            "value": 0.0,
            "message": {
              "text": "Number of expressions with unknown kind"
            }
          },
          {
            "rule": {
              "id": "cs/telemetry/extraction-information",
              "index": 85,
              "toolComponent": {
                "index": 4
              }
            },
            "ruleId": "cs/telemetry/extraction-information",
            "value": 0.0,
            "message": {
              "text": "Number of expressions with unknown type"
            }
          },
          {
            "rule": {
              "id": "cs/telemetry/extraction-information",
              "index": 85,
              "toolComponent": {
                "index": 4
              }
            },
            "ruleId": "cs/telemetry/extraction-information",
            "value": 349.0,
            "message": {
              "text": "Number of type mentions with known type"
            }
          },
          {
            "rule": {
              "id": "cs/telemetry/extraction-information",
              "index": 85,
              "toolComponent": {
                "index": 4
              }
            },
            "ruleId": "cs/telemetry/extraction-information",
            "value": 0.0,
            "message": {
              "text": "Number of calls with missing call target"
            }
          },
          {
            "rule": {
              "id": "cs/telemetry/extraction-information",
              "index": 85,
              "toolComponent": {
                "index": 4
              }
            },
            "ruleId": "cs/telemetry/extraction-information",
            "value": 0.0,
            "message": {
              "text": "Number of type mentions with unknown type"
            }
          },
          {
            "rule": {
              "id": "cs/telemetry/extraction-information",
              "index": 85,
              "toolComponent": {
                "index": 4
              }
            },
            "ruleId": "cs/telemetry/extraction-information",
            "value": 0.0,
            "message": {
              "text": "Is extracted with build-mode set to 'none'"
            }
          },
          {
            "rule": {
              "id": "cs/telemetry/extraction-information",
              "index": 85,
              "toolComponent": {
                "index": 4
              }
            },
            "ruleId": "cs/telemetry/extraction-information",
            "value": 0.0,
            "message": {
              "text": "Number of compiler reported ambiguity errors"
            }
          },
          {
            "rule": {
              "id": "cs/telemetry/extraction-information",
              "index": 85,
              "toolComponent": {
                "index": 4
              }
            },
            "ruleId": "cs/telemetry/extraction-information",
            "value": 0.0,
            "message": {
              "text": "Number of compiler reported ambiguity error messages"
            }
          },
          {
            "rule": {
              "id": "cs/telemetry/supported-external-api",
              "index": 86,
              "toolComponent": {
                "index": 4
              }
            },
            "ruleId": "cs/telemetry/supported-external-api",
            "value": 9,
            "message": {
              "text": "Microsoft.EntityFrameworkCore#ModelBuilder.Entity(System.String,System.Action<Microsoft.EntityFrameworkCore.Metadata.Builders.EntityTypeBuilder>)"
            }
          },
          {
            "rule": {
              "id": "cs/telemetry/supported-external-api",
              "index": 86,
              "toolComponent": {
                "index": 4
              }
            },
            "ruleId": "cs/telemetry/supported-external-api",
            "value": 8,
            "message": {
              "text": "System.Linq#Queryable.Where`1(System.Linq.IQueryable<TSource>,System.Linq.Expressions.Expression<System.Func<TSource,System.Boolean>>)"
            }
          },
          {
            "rule": {
              "id": "cs/telemetry/supported-external-api",
              "index": 86,
              "toolComponent": {
                "index": 4
              }
            },
            "ruleId": "cs/telemetry/supported-external-api",
            "value": 8,
            "message": {
              "text": "System.Linq#Queryable.FirstOrDefault`1(System.Linq.IQueryable<TSource>)"
            }
          },
          {
            "rule": {
              "id": "cs/telemetry/supported-external-api",
              "index": 86,
              "toolComponent": {
                "index": 4
              }
            },
            "ruleId": "cs/telemetry/supported-external-api",
            "value": 6,
            "message": {
              "text": "System#String.IsNullOrEmpty(System.String)"
            }
          },
          {
            "rule": {
              "id": "cs/telemetry/supported-external-api",
              "index": 86,
              "toolComponent": {
                "index": 4
              }
            },
            "ruleId": "cs/telemetry/supported-external-api",
            "value": 6,
            "message": {
              "text": "Microsoft.EntityFrameworkCore#DbContext.SaveChanges()"
            }
          },
          {
            "rule": {
              "id": "cs/telemetry/supported-external-api",
              "index": 86,
              "toolComponent": {
                "index": 4
              }
            },
            "ruleId": "cs/telemetry/supported-external-api",
            "value": 4,
            "message": {
              "text": "System.Text#Encoding.GetBytes(System.String)"
            }
          },
          {
            "rule": {
              "id": "cs/telemetry/supported-external-api",
              "index": 86,
              "toolComponent": {
                "index": 4
              }
            },
            "ruleId": "cs/telemetry/supported-external-api",
            "value": 3,
            "message": {
              "text": "Microsoft.EntityFrameworkCore#DbSet`1.Add(TEntity)"
            }
          },
          {
            "rule": {
              "id": "cs/telemetry/supported-external-api",
              "index": 86,
              "toolComponent": {
                "index": 4
              }
            },
            "ruleId": "cs/telemetry/supported-external-api",
            "value": 3,
            "message": {
              "text": "Microsoft.EntityFrameworkCore.Migrations#MigrationBuilder.CreateTable`1(System.String,System.Func<Microsoft.EntityFrameworkCore.Migrations.Operations.Builders.ColumnsBuilder,TColumns>,System.String,System.Action<Microsoft.EntityFrameworkCore.Migrations.Operations.Builders.CreateTableBuilder<TColumns>>)"
            }
          },
          {
            "rule": {
              "id": "cs/telemetry/supported-external-api",
              "index": 86,
              "toolComponent": {
                "index": 4
              }
            },
            "ruleId": "cs/telemetry/supported-external-api",
            "value": 3,
            "message": {
              "text": "System.Text#Encoding.get_UTF8()"
            }
          },
          {
            "rule": {
              "id": "cs/telemetry/supported-external-api",
              "index": 86,
              "toolComponent": {
                "index": 4
              }
            },
            "ruleId": "cs/telemetry/supported-external-api",
            "value": 3,
            "message": {
              "text": "System#DateTime.get_Now()"
            }
          },
          {
            "rule": {
              "id": "cs/telemetry/supported-external-api",
              "index": 86,
              "toolComponent": {
                "index": 4
              }
            },
            "ruleId": "cs/telemetry/supported-external-api",
            "value": 3,
            "message": {
              "text": "Microsoft.EntityFrameworkCore.Migrations.Operations.Builders#CreateTableBuilder`1.PrimaryKey(System.String,System.Linq.Expressions.Expression<System.Func<TColumns,System.Object>>)"
            }
          },
          {
            "rule": {
              "id": "cs/telemetry/supported-external-api",
              "index": 86,
              "toolComponent": {
                "index": 4
              }
            },
            "ruleId": "cs/telemetry/supported-external-api",
            "value": 3,
            "message": {
              "text": "System.Linq#Enumerable.ToList`1(System.Collections.Generic.IEnumerable<TSource>)"
            }
          },
          {
            "rule": {
              "id": "cs/telemetry/supported-external-api",
              "index": 86,
              "toolComponent": {
                "index": 4
              }
            },
            "ruleId": "cs/telemetry/supported-external-api",
            "value": 2,
            "message": {
              "text": "System.Text#Encoding.get_ASCII()"
            }
          },
          {
            "rule": {
              "id": "cs/telemetry/supported-external-api",
              "index": 86,
              "toolComponent": {
                "index": 4
              }
            },
            "ruleId": "cs/telemetry/supported-external-api",
            "value": 2,
            "message": {
              "text": "System.Xml.Serialization#XmlRootAttribute.XmlRootAttribute(System.String)"
            }
          },
          {
            "rule": {
              "id": "cs/telemetry/supported-external-api",
              "index": 86,
              "toolComponent": {
                "index": 4
              }
            },
            "ruleId": "cs/telemetry/supported-external-api",
            "value": 2,
            "message": {
              "text": "System.Xml.Serialization#XmlSerializer.XmlSerializer(System.Type,System.Xml.Serialization.XmlRootAttribute)"
            }
          },
          {
            "rule": {
              "id": "cs/telemetry/supported-external-api",
              "index": 86,
              "toolComponent": {
                "index": 4
              }
            },
            "ruleId": "cs/telemetry/supported-external-api",
            "value": 2,
            "message": {
              "text": "System.Xml.Serialization#XmlSerializer.Deserialize(System.Xml.XmlReader)"
            }
          },
          {
            "rule": {
              "id": "cs/telemetry/supported-external-api",
              "index": 86,
              "toolComponent": {
                "index": 4
              }
            },
            "ruleId": "cs/telemetry/supported-external-api",
            "value": 2,
            "message": {
              "text": "System#String.ToLowerInvariant()"
            }
          },
          {
            "rule": {
              "id": "cs/telemetry/supported-external-api",
              "index": 86,
              "toolComponent": {
                "index": 4
              }
            },
            "ruleId": "cs/telemetry/supported-external-api",
            "value": 2,
            "message": {
              "text": "System#String.Replace(System.String,System.String)"
            }
          },
          {
            "rule": {
              "id": "cs/telemetry/supported-external-api",
              "index": 86,
              "toolComponent": {
                "index": 4
              }
            },
            "ruleId": "cs/telemetry/supported-external-api",
            "value": 2,
            "message": {
              "text": "System.Security.Cryptography#MD5.Create()"
            }
          },
          {
            "rule": {
              "id": "cs/telemetry/supported-external-api",
              "index": 86,
              "toolComponent": {
                "index": 4
              }
            },
            "ruleId": "cs/telemetry/supported-external-api",
            "value": 2,
            "message": {
              "text": "System.Security.Claims#Claim.get_Type()"
            }
          },
          {
            "rule": {
              "id": "cs/telemetry/supported-external-api",
              "index": 86,
              "toolComponent": {
                "index": 4
              }
            },
            "ruleId": "cs/telemetry/supported-external-api",
            "value": 2,
            "message": {
              "text": "Microsoft.EntityFrameworkCore#DbSet`1.Update(TEntity)"
            }
          },
          {
            "rule": {
              "id": "cs/telemetry/supported-external-api",
              "index": 86,
              "toolComponent": {
                "index": 4
              }
            },
            "ruleId": "cs/telemetry/supported-external-api",
            "value": 2,
            "message": {
              "text": "System.Linq#Queryable.SingleOrDefault`1(System.Linq.IQueryable<TSource>,System.Linq.Expressions.Expression<System.Func<TSource,System.Boolean>>)"
            }
          },
          {
            "rule": {
              "id": "cs/telemetry/supported-external-api",
              "index": 86,
              "toolComponent": {
                "index": 4
              }
            },
            "ruleId": "cs/telemetry/supported-external-api",
            "value": 2,
            "message": {
              "text": "System.Security.Cryptography#HashAlgorithm.ComputeHash(System.Byte\\[\\])"
            }
          },
          {
            "rule": {
              "id": "cs/telemetry/supported-external-api",
              "index": 86,
              "toolComponent": {
                "index": 4
              }
            },
            "ruleId": "cs/telemetry/supported-external-api",
            "value": 2,
            "message": {
              "text": "System#BitConverter.ToString(System.Byte\\[\\])"
            }
          },
          {
            "rule": {
              "id": "cs/telemetry/supported-external-api",
              "index": 86,
              "toolComponent": {
                "index": 4
              }
            },
            "ruleId": "cs/telemetry/supported-external-api",
            "value": 2,
            "message": {
              "text": "System.Security.Claims#Claim.Claim(System.String,System.String)"
            }
          },
          {
            "rule": {
              "id": "cs/telemetry/supported-external-api",
              "index": 86,
              "toolComponent": {
                "index": 4
              }
            },
            "ruleId": "cs/telemetry/supported-external-api",
            "value": 1,
            "message": {
              "text": "Newtonsoft.Json.Linq#JObject.get_Item(System.String)"
            }
          },
          {
            "rule": {
              "id": "cs/telemetry/supported-external-api",
              "index": 86,
              "toolComponent": {
                "index": 4
              }
            },
            "ruleId": "cs/telemetry/supported-external-api",
            "value": 1,
            "message": {
              "text": "Newtonsoft.Json.Linq#JObject.Parse(System.String)"
            }
          },
          {
            "rule": {
              "id": "cs/telemetry/supported-external-api",
              "index": 86,
              "toolComponent": {
                "index": 4
              }
            },
            "ruleId": "cs/telemetry/supported-external-api",
            "value": 1,
            "message": {
              "text": "System.Text#Encoding.GetString(System.Byte\\[\\])"
            }
          },
          {
            "rule": {
              "id": "cs/telemetry/supported-external-api",
              "index": 86,
              "toolComponent": {
                "index": 4
              }
            },
            "ruleId": "cs/telemetry/supported-external-api",
            "value": 1,
            "message": {
              "text": "Microsoft.Extensions.Configuration#ConfigurationExtensions.GetConnectionString(Microsoft.Extensions.Configuration.IConfiguration,System.String)"
            }
          },
          {
            "rule": {
              "id": "cs/telemetry/supported-external-api",
              "index": 86,
              "toolComponent": {
                "index": 4
              }
            },
            "ruleId": "cs/telemetry/supported-external-api",
            "value": 1,
            "message": {
              "text": "Microsoft.EntityFrameworkCore#RelationalQueryableExtensions.FromSql`1(System.Linq.IQueryable<TEntity>,Microsoft.EntityFrameworkCore.RawSqlString,System.Object\\[\\])"
            }
          },
          {
            "rule": {
              "id": "cs/telemetry/supported-external-api",
              "index": 86,
              "toolComponent": {
                "index": 4
              }
            },
            "ruleId": "cs/telemetry/supported-external-api",
            "value": 1,
            "message": {
              "text": "System.Net.Http#HttpClient.GetAsync(System.String)"
            }
          },
          {
            "rule": {
              "id": "cs/telemetry/supported-external-api",
              "index": 86,
              "toolComponent": {
                "index": 4
              }
            },
            "ruleId": "cs/telemetry/supported-external-api",
            "value": 1,
            "message": {
              "text": "System.Net.Http#HttpContent.ReadAsStringAsync()"
            }
          },
          {
            "rule": {
              "id": "cs/telemetry/supported-external-api",
              "index": 86,
              "toolComponent": {
                "index": 4
              }
            },
            "ruleId": "cs/telemetry/supported-external-api",
            "value": 1,
            "message": {
              "text": "System.Xml.Serialization#XmlSerializer.XmlSerializer(System.Type)"
            }
          },
          {
            "rule": {
              "id": "cs/telemetry/supported-external-api",
              "index": 86,
              "toolComponent": {
                "index": 4
              }
            },
            "ruleId": "cs/telemetry/supported-external-api",
            "value": 1,
            "message": {
              "text": "System.Xml.Serialization#XmlSerializer.Serialize(System.IO.Stream,System.Object)"
            }
          },
          {
            "rule": {
              "id": "cs/telemetry/supported-external-api",
              "index": 86,
              "toolComponent": {
                "index": 4
              }
            },
            "ruleId": "cs/telemetry/supported-external-api",
            "value": 1,
            "message": {
              "text": "System.Xml#XmlReader.Close()"
            }
          },
          {
            "rule": {
              "id": "cs/telemetry/supported-external-api",
              "index": 86,
              "toolComponent": {
                "index": 4
              }
            },
            "ruleId": "cs/telemetry/supported-external-api",
            "value": 1,
            "message": {
              "text": "System.Xml#XmlTextReader.XmlTextReader(System.IO.TextReader)"
            }
          },
          {
            "rule": {
              "id": "cs/telemetry/supported-external-api",
              "index": 86,
              "toolComponent": {
                "index": 4
              }
            },
            "ruleId": "cs/telemetry/supported-external-api",
            "value": 1,
            "message": {
              "text": "System#DateTime.AddMinutes(System.Double)"
            }
          },
          {
            "rule": {
              "id": "cs/telemetry/supported-external-api",
              "index": 86,
              "toolComponent": {
                "index": 4
              }
            },
            "ruleId": "cs/telemetry/supported-external-api",
            "value": 1,
            "message": {
              "text": "System#Type.GetType(System.String)"
            }
          },
          {
            "rule": {
              "id": "cs/telemetry/supported-external-api",
              "index": 86,
              "toolComponent": {
                "index": 4
              }
            },
            "ruleId": "cs/telemetry/supported-external-api",
            "value": 1,
            "message": {
              "text": "System#Int32.ToString()"
            }
          },
          {
            "rule": {
              "id": "cs/telemetry/supported-external-api",
              "index": 86,
              "toolComponent": {
                "index": 4
              }
            },
            "ruleId": "cs/telemetry/supported-external-api",
            "value": 1,
            "message": {
              "text": "Microsoft.Extensions.DependencyInjection#JwtBearerExtensions.AddJwtBearer(Microsoft.AspNetCore.Authentication.AuthenticationBuilder,System.Action<Microsoft.AspNetCore.Authentication.JwtBearer.JwtBearerOptions>)"
            }
          },
          {
            "rule": {
              "id": "cs/telemetry/supported-external-api",
              "index": 86,
              "toolComponent": {
                "index": 4
              }
            },
            "ruleId": "cs/telemetry/supported-external-api",
            "value": 1,
            "message": {
              "text": "Microsoft.AspNetCore.Cors.Infrastructure#CorsOptions.AddPolicy(System.String,System.Action<Microsoft.AspNetCore.Cors.Infrastructure.CorsPolicyBuilder>)"
            }
          },
          {
            "rule": {
              "id": "cs/telemetry/supported-external-api",
              "index": 86,
              "toolComponent": {
                "index": 4
              }
            },
            "ruleId": "cs/telemetry/supported-external-api",
            "value": 1,
            "message": {
              "text": "Microsoft.Extensions.DependencyInjection#CorsServiceCollectionExtensions.AddCors(Microsoft.Extensions.DependencyInjection.IServiceCollection,System.Action<Microsoft.AspNetCore.Cors.Infrastructure.CorsOptions>)"
            }
          },
          {
            "rule": {
              "id": "cs/telemetry/supported-external-api",
              "index": 86,
              "toolComponent": {
                "index": 4
              }
            },
            "ruleId": "cs/telemetry/supported-external-api",
            "value": 1,
            "message": {
              "text": "Microsoft.AspNetCore.Builder#RunExtensions.Run(Microsoft.AspNetCore.Builder.IApplicationBuilder,Microsoft.AspNetCore.Http.RequestDelegate)"
            }
          },
          {
            "rule": {
              "id": "cs/telemetry/supported-external-api",
              "index": 86,
              "toolComponent": {
                "index": 4
              }
            },
            "ruleId": "cs/telemetry/supported-external-api",
            "value": 1,
            "message": {
              "text": "Microsoft.AspNetCore.Http#IQueryCollection.get_Item(System.String)"
            }
          },
          {
            "rule": {
              "id": "cs/telemetry/supported-external-api",
              "index": 86,
              "toolComponent": {
                "index": 4
              }
            },
            "ruleId": "cs/telemetry/supported-external-api",
            "value": 1,
            "message": {
              "text": "Microsoft.AspNetCore.Http#IRequestCookieCollection.get_Item(System.String)"
            }
          },
          {
            "rule": {
              "id": "cs/telemetry/supported-external-api",
              "index": 86,
              "toolComponent": {
                "index": 4
              }
            },
            "ruleId": "cs/telemetry/supported-external-api",
            "value": 1,
            "message": {
              "text": "System.Collections.Generic#List`1.Add(T)"
            }
          },
          {
            "rule": {
              "id": "cs/telemetry/supported-external-api",
              "index": 86,
              "toolComponent": {
                "index": 4
              }
            },
            "ruleId": "cs/telemetry/supported-external-api",
            "value": 1,
            "message": {
              "text": "System#Exception.get_Message()"
            }
          },
          {
            "rule": {
              "id": "cs/telemetry/supported-external-api",
              "index": 86,
              "toolComponent": {
                "index": 4
              }
            },
            "ruleId": "cs/telemetry/supported-external-api",
            "value": 1,
            "message": {
              "text": "Microsoft.EntityFrameworkCore#SqliteDbContextOptionsBuilderExtensions.UseSqlite(Microsoft.EntityFrameworkCore.DbContextOptionsBuilder,System.String,System.Action<Microsoft.EntityFrameworkCore.Infrastructure.SqliteDbContextOptionsBuilder>)"
            }
          },
          {
            "rule": {
              "id": "cs/telemetry/supported-external-api",
              "index": 86,
              "toolComponent": {
                "index": 4
              }
            },
            "ruleId": "cs/telemetry/supported-external-api",
            "value": 1,
            "message": {
              "text": "Microsoft.EntityFrameworkCore#RawSqlString.implicit conversion(System.String)"
            }
          },
          {
            "rule": {
              "id": "cs/telemetry/supported-external-api",
              "index": 86,
              "toolComponent": {
                "index": 4
              }
            },
            "ruleId": "cs/telemetry/supported-external-api",
            "value": 1,
            "message": {
              "text": "Microsoft.Extensions.Primitives#StringValues.ToString()"
            }
          },
          {
            "rule": {
              "id": "cs/telemetry/supported-external-api",
              "index": 86,
              "toolComponent": {
                "index": 4
              }
            },
            "ruleId": "cs/telemetry/supported-external-api",
            "value": 1,
            "message": {
              "text": "Microsoft.Extensions.DependencyInjection#EntityFrameworkServiceCollectionExtensions.AddDbContext`1(Microsoft.Extensions.DependencyInjection.IServiceCollection,System.Action<Microsoft.EntityFrameworkCore.DbContextOptionsBuilder>,Microsoft.Extensions.DependencyInjection.ServiceLifetime,Microsoft.Extensions.DependencyInjection.ServiceLifetime)"
            }
          },
          {
            "rule": {
              "id": "cs/telemetry/supported-external-api",
              "index": 86,
              "toolComponent": {
                "index": 4
              }
            },
            "ruleId": "cs/telemetry/supported-external-api",
            "value": 1,
            "message": {
              "text": "System.Linq#Enumerable.FirstOrDefault`1(System.Collections.Generic.IEnumerable<TSource>,System.Func<TSource,System.Boolean>)"
            }
          },
          {
            "rule": {
              "id": "cs/telemetry/supported-external-api",
              "index": 86,
              "toolComponent": {
                "index": 4
              }
            },
            "ruleId": "cs/telemetry/supported-external-api",
            "value": 1,
            "message": {
              "text": "System.Linq#Enumerable.ToArray`1(System.Collections.Generic.IEnumerable<TSource>)"
            }
          },
          {
            "rule": {
              "id": "cs/telemetry/supported-external-api",
              "index": 86,
              "toolComponent": {
                "index": 4
              }
            },
            "ruleId": "cs/telemetry/supported-external-api",
            "value": 1,
            "message": {
              "text": "System.Net.Http#HttpResponseMessage.EnsureSuccessStatusCode()"
            }
          },
          {
            "rule": {
              "id": "cs/telemetry/supported-external-api",
              "index": 86,
              "toolComponent": {
                "index": 4
              }
            },
            "ruleId": "cs/telemetry/supported-external-api",
            "value": 1,
            "message": {
              "text": "System.IO#StringReader.StringReader(System.String)"
            }
          },
          {
            "rule": {
              "id": "cs/telemetry/supported-external-api",
              "index": 86,
              "toolComponent": {
                "index": 4
              }
            },
            "ruleId": "cs/telemetry/supported-external-api",
            "value": 1,
            "message": {
              "text": "System#Convert.FromBase64String(System.String)"
            }
          },
          {
            "rule": {
              "id": "cs/telemetry/supported-external-api",
              "index": 86,
              "toolComponent": {
                "index": 4
              }
            },
            "ruleId": "cs/telemetry/supported-external-api",
            "value": 1,
            "message": {
              "text": "System.Security.Claims#Claim.get_Value()"
            }
          },
          {
            "rule": {
              "id": "cs/telemetry/supported-external-api",
              "index": 86,
              "toolComponent": {
                "index": 4
              }
            },
            "ruleId": "cs/telemetry/supported-external-api",
            "value": 1,
            "message": {
              "text": "System.Security.Claims#ClaimsPrincipal.get_Claims()"
            }
          },
          {
            "rule": {
              "id": "cs/telemetry/supported-external-api",
              "index": 86,
              "toolComponent": {
                "index": 4
              }
            },
            "ruleId": "cs/telemetry/supported-external-api",
            "value": 1,
            "message": {
              "text": "System.Security.Claims#ClaimsPrincipal.HasClaim(System.Predicate<System.Security.Claims.Claim>)"
            }
          },
          {
            "rule": {
              "id": "cs/telemetry/supported-external-api",
              "index": 86,
              "toolComponent": {
                "index": 4
              }
            },
            "ruleId": "cs/telemetry/supported-external-api",
            "value": 1,
            "message": {
              "text": "System.Xml#XmlDocument.Load(System.IO.Stream)"
            }
          },
          {
            "rule": {
              "id": "cs/telemetry/supported-external-api",
              "index": 86,
              "toolComponent": {
                "index": 4
              }
            },
            "ruleId": "cs/telemetry/supported-external-api",
            "value": 1,
            "message": {
              "text": "System.Xml#XmlElement.GetAttribute(System.String)"
            }
          },
          {
            "rule": {
              "id": "cs/telemetry/supported-external-api",
              "index": 86,
              "toolComponent": {
                "index": 4
              }
            },
            "ruleId": "cs/telemetry/supported-external-api",
            "value": 1,
            "message": {
              "text": "System.Xml#XmlNode.SelectNodes(System.String)"
            }
          },
          {
            "rule": {
              "id": "cs/telemetry/supported-external-api",
              "index": 86,
              "toolComponent": {
                "index": 4
              }
            },
            "ruleId": "cs/telemetry/supported-external-api",
            "value": 1,
            "message": {
              "text": "System.Xml#XmlReader.Create(System.IO.Stream)"
            }
          },
          {
            "rule": {
              "id": "cs/telemetry/supported-external-api",
              "index": 86,
              "toolComponent": {
                "index": 4
              }
            },
            "ruleId": "cs/telemetry/supported-external-api",
            "value": 1,
            "message": {
              "text": "Newtonsoft.Json.Linq#JObject.JObject(System.Object\\[\\])"
            }
          },
          {
            "rule": {
              "id": "cs/telemetry/unsupported-external-api",
              "index": 87,
              "toolComponent": {
                "index": 4
              }
            },
            "ruleId": "cs/telemetry/unsupported-external-api",
            "value": 59,
            "message": {
              "text": "Microsoft.EntityFrameworkCore.Metadata.Builders#EntityTypeBuilder.Property`1(System.String)"
            }
          },
          {
            "rule": {
              "id": "cs/telemetry/unsupported-external-api",
              "index": 87,
              "toolComponent": {
                "index": 4
              }
            },
            "ruleId": "cs/telemetry/unsupported-external-api",
            "value": 25,
            "message": {
              "text": "Microsoft.AspNetCore.Mvc#ControllerBase.get_ModelState()"
            }
          },
          {
            "rule": {
              "id": "cs/telemetry/unsupported-external-api",
              "index": 87,
              "toolComponent": {
                "index": 4
              }
            },
            "ruleId": "cs/telemetry/unsupported-external-api",
            "value": 19,
            "message": {
              "text": "Microsoft.EntityFrameworkCore.Migrations.Operations.Builders#ColumnsBuilder.Column`1(System.String,System.Nullable<System.Boolean>,System.Nullable<System.Int32>,System.Boolean,System.String,System.Boolean,System.Object,System.String,System.String)"
            }
          },
          {
            "rule": {
              "id": "cs/telemetry/unsupported-external-api",
              "index": 87,
              "toolComponent": {
                "index": 4
              }
            },
            "ruleId": "cs/telemetry/unsupported-external-api",
            "value": 18,
            "message": {
              "text": "Microsoft.EntityFrameworkCore.Metadata.Builders#PropertyBuilder`1.IsRequired(System.Boolean)"
            }
          },
          {
            "rule": {
              "id": "cs/telemetry/unsupported-external-api",
              "index": 87,
              "toolComponent": {
                "index": 4
              }
            },
            "ruleId": "cs/telemetry/unsupported-external-api",
            "value": 13,
            "message": {
              "text": "Microsoft.AspNetCore.Mvc#ControllerBase.Ok(System.Object)"
            }
          },
          {
            "rule": {
              "id": "cs/telemetry/unsupported-external-api",
              "index": 87,
              "toolComponent": {
                "index": 4
              }
            },
            "ruleId": "cs/telemetry/unsupported-external-api",
            "value": 12,
            "message": {
              "text": "Microsoft.AspNetCore.Mvc#ControllerBase.BadRequest(Microsoft.AspNetCore.Mvc.ModelBinding.ModelStateDictionary)"
            }
          },
          {
            "rule": {
              "id": "cs/telemetry/unsupported-external-api",
              "index": 87,
              "toolComponent": {
                "index": 4
              }
            },
            "ruleId": "cs/telemetry/unsupported-external-api",
            "value": 9,
            "message": {
              "text": "Microsoft.EntityFrameworkCore#RelationalEntityTypeBuilderExtensions.ToTable(Microsoft.EntityFrameworkCore.Metadata.Builders.EntityTypeBuilder,System.String)"
            }
          },
          {
            "rule": {
              "id": "cs/telemetry/unsupported-external-api",
              "index": 87,
              "toolComponent": {
                "index": 4
              }
            },
            "ruleId": "cs/telemetry/unsupported-external-api",
            "value": 9,
            "message": {
              "text": "Microsoft.EntityFrameworkCore.Metadata.Builders#PropertyBuilder`1.ValueGeneratedOnAdd()"
            }
          },
          {
            "rule": {
              "id": "cs/telemetry/unsupported-external-api",
              "index": 87,
              "toolComponent": {
                "index": 4
              }
            },
            "ruleId": "cs/telemetry/unsupported-external-api",
            "value": 9,
            "message": {
              "text": "Microsoft.EntityFrameworkCore.Metadata.Builders#EntityTypeBuilder.HasKey(System.String\\[\\])"
            }
          },
          {
            "rule": {
              "id": "cs/telemetry/unsupported-external-api",
              "index": 87,
              "toolComponent": {
                "index": 4
              }
            },
            "ruleId": "cs/telemetry/unsupported-external-api",
            "value": 8,
            "message": {
              "text": "Microsoft.AspNetCore.Mvc.ModelBinding#ModelStateDictionary.AddModelError(System.String,System.String)"
            }
          },
          {
            "rule": {
              "id": "cs/telemetry/unsupported-external-api",
              "index": 87,
              "toolComponent": {
                "index": 4
              }
            },
            "ruleId": "cs/telemetry/unsupported-external-api",
            "value": 7,
            "message": {
              "text": "Microsoft.AspNetCore.Mvc#ControllerBase.get_HttpContext()"
            }
          },
          {
            "rule": {
              "id": "cs/telemetry/unsupported-external-api",
              "index": 87,
              "toolComponent": {
                "index": 4
              }
            },
            "ruleId": "cs/telemetry/unsupported-external-api",
            "value": 5,
            "message": {
              "text": "Microsoft.AspNetCore.Mvc.ModelBinding#ModelStateDictionary.get_IsValid()"
            }
          },
          {
            "rule": {
              "id": "cs/telemetry/unsupported-external-api",
              "index": 87,
              "toolComponent": {
                "index": 4
              }
            },
            "ruleId": "cs/telemetry/unsupported-external-api",
            "value": 4,
            "message": {
              "text": "Microsoft.EntityFrameworkCore#ModelBuilder.HasAnnotation(System.String,System.Object)"
            }
          },
          {
            "rule": {
              "id": "cs/telemetry/unsupported-external-api",
              "index": 87,
              "toolComponent": {
                "index": 4
              }
            },
            "ruleId": "cs/telemetry/unsupported-external-api",
            "value": 4,
            "message": {
              "text": "Microsoft.AspNetCore.Mvc#ControllerBase.NotFound()"
            }
          },
          {
            "rule": {
              "id": "cs/telemetry/unsupported-external-api",
              "index": 87,
              "toolComponent": {
                "index": 4
              }
            },
            "ruleId": "cs/telemetry/unsupported-external-api",
            "value": 4,
            "message": {
              "text": "Microsoft.AspNetCore.Http#HttpContext.get_Request()"
            }
          },
          {
            "rule": {
              "id": "cs/telemetry/unsupported-external-api",
              "index": 87,
              "toolComponent": {
                "index": 4
              }
            },
            "ruleId": "cs/telemetry/unsupported-external-api",
            "value": 3,
            "message": {
              "text": "Microsoft.EntityFrameworkCore.Migrations#MigrationBuilder.DropTable(System.String,System.String)"
            }
          },
          {
            "rule": {
              "id": "cs/telemetry/unsupported-external-api",
              "index": 87,
              "toolComponent": {
                "index": 4
              }
            },
            "ruleId": "cs/telemetry/unsupported-external-api",
            "value": 3,
            "message": {
              "text": "Microsoft.AspNetCore.Mvc#ControllerBase.Unauthorized()"
            }
          },
          {
            "rule": {
              "id": "cs/telemetry/unsupported-external-api",
              "index": 87,
              "toolComponent": {
                "index": 4
              }
            },
            "ruleId": "cs/telemetry/unsupported-external-api",
            "value": 3,
            "message": {
              "text": "Microsoft.EntityFrameworkCore.Migrations.Operations.Builders#OperationBuilder`1.Annotation(System.String,System.Object)"
            }
          },
          {
            "rule": {
              "id": "cs/telemetry/unsupported-external-api",
              "index": 87,
              "toolComponent": {
                "index": 4
              }
            },
            "ruleId": "cs/telemetry/unsupported-external-api",
            "value": 2,
            "message": {
              "text": "Newtonsoft.Json.Linq#JProperty.JProperty(System.String,System.Object)"
            }
          },
          {
            "rule": {
              "id": "cs/telemetry/unsupported-external-api",
              "index": 87,
              "toolComponent": {
                "index": 4
              }
            },
            "ruleId": "cs/telemetry/unsupported-external-api",
            "value": 2,
            "message": {
              "text": "Microsoft.EntityFrameworkCore.Metadata.Builders#PropertyBuilder`1.HasMaxLength(System.Int32)"
            }
          },
          {
            "rule": {
              "id": "cs/telemetry/unsupported-external-api",
              "index": 87,
              "toolComponent": {
                "index": 4
              }
            },
            "ruleId": "cs/telemetry/unsupported-external-api",
            "value": 2,
            "message": {
              "text": "Microsoft.AspNetCore.Http#HttpContext.get_Response()"
            }
          },
          {
            "rule": {
              "id": "cs/telemetry/unsupported-external-api",
              "index": 87,
              "toolComponent": {
                "index": 4
              }
            },
            "ruleId": "cs/telemetry/unsupported-external-api",
            "value": 2,
            "message": {
              "text": "Microsoft.IdentityModel.Tokens#SymmetricSecurityKey.SymmetricSecurityKey(System.Byte\\[\\])"
            }
          },
          {
            "rule": {
              "id": "cs/telemetry/unsupported-external-api",
              "index": 87,
              "toolComponent": {
                "index": 4
              }
            },
            "ruleId": "cs/telemetry/unsupported-external-api",
            "value": 1,
            "message": {
              "text": "Microsoft.IdentityModel.Tokens#SigningCredentials.SigningCredentials(Microsoft.IdentityModel.Tokens.SecurityKey,System.String)"
            }
          },
          {
            "rule": {
              "id": "cs/telemetry/unsupported-external-api",
              "index": 87,
              "toolComponent": {
                "index": 4
              }
            },
            "ruleId": "cs/telemetry/unsupported-external-api",
            "value": 1,
            "message": {
              "text": "Newtonsoft.Json.Linq#JToken.ToObject`1()"
            }
          },
          {
            "rule": {
              "id": "cs/telemetry/unsupported-external-api",
              "index": 87,
              "toolComponent": {
                "index": 4
              }
            },
            "ruleId": "cs/telemetry/unsupported-external-api",
            "value": 1,
            "message": {
              "text": "System.IdentityModel.Tokens.Jwt#JwtSecurityToken.JwtSecurityToken(System.String,System.String,System.Collections.Generic.IEnumerable<System.Security.Claims.Claim>,System.Nullable<System.DateTime>,System.Nullable<System.DateTime>,Microsoft.IdentityModel.Tokens.SigningCredentials)"
            }
          },
          {
            "rule": {
              "id": "cs/telemetry/unsupported-external-api",
              "index": 87,
              "toolComponent": {
                "index": 4
              }
            },
            "ruleId": "cs/telemetry/unsupported-external-api",
            "value": 1,
            "message": {
              "text": "System.IdentityModel.Tokens.Jwt#JwtSecurityTokenHandler.WriteToken(Microsoft.IdentityModel.Tokens.SecurityToken)"
            }
          },
          {
            "rule": {
              "id": "cs/telemetry/unsupported-external-api",
              "index": 87,
              "toolComponent": {
                "index": 4
              }
            },
            "ruleId": "cs/telemetry/unsupported-external-api",
            "value": 1,
            "message": {
              "text": "Microsoft.AspNetCore#WebHost.CreateDefaultBuilder(System.String\\[\\])"
            }
          },
          {
            "rule": {
              "id": "cs/telemetry/unsupported-external-api",
              "index": 87,
              "toolComponent": {
                "index": 4
              }
            },
            "ruleId": "cs/telemetry/unsupported-external-api",
            "value": 1,
            "message": {
              "text": "Microsoft.AspNetCore.Builder#AuthAppBuilderExtensions.UseAuthentication(Microsoft.AspNetCore.Builder.IApplicationBuilder)"
            }
          },
          {
            "rule": {
              "id": "cs/telemetry/unsupported-external-api",
              "index": 87,
              "toolComponent": {
                "index": 4
              }
            },
            "ruleId": "cs/telemetry/unsupported-external-api",
            "value": 1,
            "message": {
              "text": "Microsoft.Extensions.DependencyInjection#AuthenticationServiceCollectionExtensions.AddAuthentication(Microsoft.Extensions.DependencyInjection.IServiceCollection,System.String)"
            }
          },
          {
            "rule": {
              "id": "cs/telemetry/unsupported-external-api",
              "index": 87,
              "toolComponent": {
                "index": 4
              }
            },
            "ruleId": "cs/telemetry/unsupported-external-api",
            "value": 1,
            "message": {
              "text": "Microsoft.AspNetCore.Builder#CorsMiddlewareExtensions.UseCors(Microsoft.AspNetCore.Builder.IApplicationBuilder,System.String)"
            }
          },
          {
            "rule": {
              "id": "cs/telemetry/unsupported-external-api",
              "index": 87,
              "toolComponent": {
                "index": 4
              }
            },
            "ruleId": "cs/telemetry/unsupported-external-api",
            "value": 1,
            "message": {
              "text": "Microsoft.AspNetCore.Cors.Infrastructure#CorsPolicyBuilder.AllowCredentials()"
            }
          },
          {
            "rule": {
              "id": "cs/telemetry/unsupported-external-api",
              "index": 87,
              "toolComponent": {
                "index": 4
              }
            },
            "ruleId": "cs/telemetry/unsupported-external-api",
            "value": 1,
            "message": {
              "text": "Microsoft.AspNetCore.Cors.Infrastructure#CorsPolicyBuilder.AllowAnyOrigin()"
            }
          },
          {
            "rule": {
              "id": "cs/telemetry/unsupported-external-api",
              "index": 87,
              "toolComponent": {
                "index": 4
              }
            },
            "ruleId": "cs/telemetry/unsupported-external-api",
            "value": 1,
            "message": {
              "text": "Microsoft.AspNetCore.Cors.Infrastructure#CorsPolicyBuilder.AllowAnyMethod()"
            }
          },
          {
            "rule": {
              "id": "cs/telemetry/unsupported-external-api",
              "index": 87,
              "toolComponent": {
                "index": 4
              }
            },
            "ruleId": "cs/telemetry/unsupported-external-api",
            "value": 1,
            "message": {
              "text": "Microsoft.AspNetCore.Cors.Infrastructure#CorsPolicyBuilder.AllowAnyHeader()"
            }
          },
          {
            "rule": {
              "id": "cs/telemetry/unsupported-external-api",
              "index": 87,
              "toolComponent": {
                "index": 4
              }
            },
            "ruleId": "cs/telemetry/unsupported-external-api",
            "value": 1,
            "message": {
              "text": "Microsoft.AspNetCore.Cors.Infrastructure#CorsPolicyBuilder.Build()"
            }
          },
          {
            "rule": {
              "id": "cs/telemetry/unsupported-external-api",
              "index": 87,
              "toolComponent": {
                "index": 4
              }
            },
            "ruleId": "cs/telemetry/unsupported-external-api",
            "value": 1,
            "message": {
              "text": "Microsoft.AspNetCore.Builder#DeveloperExceptionPageExtensions.UseDeveloperExceptionPage(Microsoft.AspNetCore.Builder.IApplicationBuilder)"
            }
          },
          {
            "rule": {
              "id": "cs/telemetry/unsupported-external-api",
              "index": 87,
              "toolComponent": {
                "index": 4
              }
            },
            "ruleId": "cs/telemetry/unsupported-external-api",
            "value": 1,
            "message": {
              "text": "Microsoft.AspNetCore.Hosting#WebHostBuilderExtensions.UseStartup`1(Microsoft.AspNetCore.Hosting.IWebHostBuilder)"
            }
          },
          {
            "rule": {
              "id": "cs/telemetry/unsupported-external-api",
              "index": 87,
              "toolComponent": {
                "index": 4
              }
            },
            "ruleId": "cs/telemetry/unsupported-external-api",
            "value": 1,
            "message": {
              "text": "Microsoft.AspNetCore.Hosting#HostingEnvironmentExtensions.IsDevelopment(Microsoft.AspNetCore.Hosting.IHostingEnvironment)"
            }
          },
          {
            "rule": {
              "id": "cs/telemetry/unsupported-external-api",
              "index": 87,
              "toolComponent": {
                "index": 4
              }
            },
            "ruleId": "cs/telemetry/unsupported-external-api",
            "value": 1,
            "message": {
              "text": "Microsoft.AspNetCore.Hosting#WebHostExtensions.Run(Microsoft.AspNetCore.Hosting.IWebHost)"
            }
          },
          {
            "rule": {
              "id": "cs/telemetry/unsupported-external-api",
              "index": 87,
              "toolComponent": {
                "index": 4
              }
            },
            "ruleId": "cs/telemetry/unsupported-external-api",
            "value": 1,
            "message": {
              "text": "Microsoft.AspNetCore.Hosting#IWebHostBuilder.Build()"
            }
          },
          {
            "rule": {
              "id": "cs/telemetry/unsupported-external-api",
              "index": 87,
              "toolComponent": {
                "index": 4
              }
            },
            "ruleId": "cs/telemetry/unsupported-external-api",
            "value": 1,
            "message": {
              "text": "Microsoft.AspNetCore.Http#HttpResponseWritingExtensions.WriteAsync(Microsoft.AspNetCore.Http.HttpResponse,System.String,System.Threading.CancellationToken)"
            }
          },
          {
            "rule": {
              "id": "cs/telemetry/unsupported-external-api",
              "index": 87,
              "toolComponent": {
                "index": 4
              }
            },
            "ruleId": "cs/telemetry/unsupported-external-api",
            "value": 1,
            "message": {
              "text": "Microsoft.Extensions.DependencyInjection#MvcServiceCollectionExtensions.AddMvc(Microsoft.Extensions.DependencyInjection.IServiceCollection)"
            }
          },
          {
            "rule": {
              "id": "cs/telemetry/unsupported-external-api",
              "index": 87,
              "toolComponent": {
                "index": 4
              }
            },
            "ruleId": "cs/telemetry/unsupported-external-api",
            "value": 1,
            "message": {
              "text": "Microsoft.AspNetCore.Builder#MvcApplicationBuilderExtensions.UseMvc(Microsoft.AspNetCore.Builder.IApplicationBuilder)"
            }
          },
          {
            "rule": {
              "id": "cs/telemetry/unsupported-external-api",
              "index": 87,
              "toolComponent": {
                "index": 4
              }
            },
            "ruleId": "cs/telemetry/unsupported-external-api",
            "value": 1,
            "message": {
              "text": "Microsoft.AspNetCore.Mvc#ControllerBase.BadRequest()"
            }
          },
          {
            "rule": {
              "id": "cs/telemetry/unsupported-external-api",
              "index": 87,
              "toolComponent": {
                "index": 4
              }
            },
            "ruleId": "cs/telemetry/unsupported-external-api",
            "value": 1,
            "message": {
              "text": "Microsoft.AspNetCore.Mvc#ControllerBase.get_Response()"
            }
          },
          {
            "rule": {
              "id": "cs/telemetry/unsupported-external-api",
              "index": 87,
              "toolComponent": {
                "index": 4
              }
            },
            "ruleId": "cs/telemetry/unsupported-external-api",
            "value": 1,
            "message": {
              "text": "Microsoft.AspNetCore.Mvc#Controller.Json(System.Object)"
            }
          },
          {
            "rule": {
              "id": "cs/telemetry/unsupported-external-api",
              "index": 87,
              "toolComponent": {
                "index": 4
              }
            },
            "ruleId": "cs/telemetry/unsupported-external-api",
            "value": 1,
            "message": {
              "text": "Microsoft.EntityFrameworkCore#DbSet`1.Remove(TEntity)"
            }
          },
          {
            "rule": {
              "id": "cs/telemetry/unsupported-external-api",
              "index": 87,
              "toolComponent": {
                "index": 4
              }
            },
            "ruleId": "cs/telemetry/unsupported-external-api",
            "value": 1,
            "message": {
              "text": "Microsoft.EntityFrameworkCore#DbContext.DbContext(Microsoft.EntityFrameworkCore.DbContextOptions)"
            }
          },
          {
            "rule": {
              "id": "cs/summary/lines-of-code",
              "index": 88,
              "toolComponent": {
                "index": 4
              }
            },
            "ruleId": "cs/summary/lines-of-code",
            "value": 1034,
            "baseline": 1022
          }
        ],
        "codeqlConfigSummary": {
          "disableDefaultQueries": true
        },
        "jobRunUuid": "8c02bd9d-6b7f-4f3c-b07e-1b11472c0adb"
      }
    }
  ]
}